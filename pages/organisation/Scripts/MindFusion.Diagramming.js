(function(dependencies, definition) {
    if (typeof module != 'undefined') module.exports = definition(require("mindfusion-common"));
    else if (typeof define == 'function' && typeof define.amd == 'object') define(dependencies, definition);
    else return definition(MindFusion);
}(['mindfusion-common'], function(MindFusion) {
    MindFusion.registerNamespace("MindFusion.Animations");
    MindFusion.Animations.AnimationType = {
        Linear: 0,
        Power: 1,
        Exponential: 2,
        Circular: 3,
        BackBow: 4,
        Bounce: 5,
        Elastic: 6,
        Custom: 7
    };
    MindFusion.Animations.EasingType = {
        EaseIn: 0,
        EaseOut: 1,
        EaseInOut: 2,
        EaseOutIn: 3
    };
    (function(a) {
        var b = a.Animation = function(f, d, c, e) {
            this.item = f;
            this.duration = 1000;
            this.fromValue = null;
            this.toValue = null;
            this.animationType = a.AnimationType.Linear;
            this.param = null;
            this.easingType = a.EasingType.EaseIn;
            this.repeat = false;
            this.reverse = false;
            this.onUpdateDelegate = mflayer.createDelegate(this, c || this.onUpdate);
            this.onCustomFunctionDelegate = mflayer.createDelegate(this, e || this.onCustomFunction);
            if (d) {
                if (d.duration != null) {
                    this.duration = d.duration
                }
                if (d.fromValue != null) {
                    this.fromValue = d.fromValue
                }
                if (d.toValue != null) {
                    this.toValue = d.toValue
                }
                if (d.animationType) {
                    this.animationType = d.animationType
                }
                if (d.param != null) {
                    this.param = d.param
                } else {
                    if (this.animationType == a.AnimationType.Power) {
                        this.param = 2
                    } else {
                        if (this.animationType == a.AnimationType.BackBow) {
                            this.param = 1.5
                        } else {
                            if (this.animationType == a.AnimationType.Elastic) {
                                this.param = 0.5
                            } else {
                                if (this.animationType == a.AnimationType.Exponential) {
                                    this.param = 10
                                }
                            }
                        }
                    }
                }
                if (d.easingType) {
                    this.easingType = d.easingType
                }
                if (d.repeat != null) {
                    this.repeat = d.repeat
                }
                if (d.reverse != null) {
                    this.reverse = d.reverse
                }
            }
            this.ellapsedTime = 0;
            this.progress = 0;
            this.animationId = null;
            this.eventHandlers = mflayer.eventHandlerList();
            mflayer.registerDisposableObject(this)
        };
        b.prototype = {
            dispose: function() {
                this.stop()
            },
            addEventListener: function(c, d) {
                mflayer.addHandler(this, c, d)
            },
            removeEventListener: function(c, d) {
                mflayer.removeHandler(this, c, d)
            },
            raiseEvent: function(c, d) {
                var e = mflayer.getHandler(this, c);
                if (e != null) {
                    e(this, d)
                }
            },
            start: function() {
                this.startTimeStamp = new Date().getTime();
                this.animationId = b.requestAnimationFrame(this.update.bind(this))
            },
            stop: function() {
                if (this.animationId != null) {
                    b.cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    this.raiseEvent(a.Events.animationComplete, MindFusion.EventArgs.Empty)
                }
            },
            isRunning: function() {
                return this.animationId != null
            },
            getProgress: function() {
                if (this.isRunning()) {
                    return this.progress
                }
                return 0
            },
            animationProgress: function(e) {
                if (e === 0) {
                    return 0
                }
                if (e === 1) {
                    return 1
                }
                switch (this.animationType) {
                    case a.AnimationType.Linear:
                        return e;
                    case a.AnimationType.Power:
                        return Math.pow(e, this.param);
                    case a.AnimationType.Exponential:
                        return (Math.pow(Math.E, this.param * e) - 1) / (Math.pow(Math.E, this.param) - 1);
                    case a.AnimationType.Circular:
                        return 1 - Math.sin(Math.acos(e));
                    case a.AnimationType.BackBow:
                        return Math.pow(e, 2) * ((this.param + 1) * e - this.param);
                    case a.AnimationType.Bounce:
                        var d = 0,
                            c = 1;
                        while (true) {
                            if (e >= (7 - 4 * d) / 11) {
                                return -Math.pow((11 - 6 * d - 11 * e) / 4, 2) + Math.pow(c, 2)
                            }
                            d += c;
                            c /= 2
                        }
                        case a.AnimationType.Elastic:
                            return Math.pow(2, 10 * (e - 1)) * Math.cos(20 * Math.PI * this.param * e);
                        case a.AnimationType.Custom:
                            return this.onCustomFunctionDelegate(e, this.param)
                }
            },
            onCustomFunction: function(d, c) {
                return d
            },
            easeIn: function(c) {
                return this.animationProgress(c)
            },
            easeOut: function(c) {
                return 1 - this.animationProgress(1 - c)
            },
            easeInOut: function(c) {
                if (c <= 0.5) {
                    return this.easeIn(c * 2) / 2
                } else {
                    return this.easeOut((c - 0.5) * 2) / 2 + 0.5
                }
            },
            easeOutIn: function(c) {
                if (c <= 0.5) {
                    return this.easeOut(c * 2) / 2
                } else {
                    return this.easeIn((c - 0.5) * 2) / 2 + 0.5
                }
            },
            update: function() {
                this.animationId = b.requestAnimationFrame(this.update.bind(this));
                this.ellapsedTime = new Date().getTime();
                this.progress = (this.ellapsedTime - this.startTimeStamp) / this.duration;
                if (this.progress >= 1) {
                    this.progress = 1
                }
                switch (this.easingType) {
                    case a.EasingType.EaseIn:
                        this.onUpdateDelegate(this, this.easeIn(this.progress));
                        break;
                    case a.EasingType.EaseOut:
                        this.onUpdateDelegate(this, this.easeOut(this.progress));
                        break;
                    case a.EasingType.EaseInOut:
                        this.onUpdateDelegate(this, this.easeInOut(this.progress));
                        break;
                    case a.EasingType.EaseOutIn:
                        this.onUpdateDelegate(this, this.easeOutIn(this.progress));
                        break
                }
                if (this.progress == 1) {
                    if (this.repeat) {
                        this.progress = 0;
                        this.startTimeStamp = new Date().getTime()
                    } else {
                        this.stop()
                    }
                    if (this.reverse) {
                        var c = this.toValue;
                        this.toValue = this.fromValue;
                        this.fromValue = c
                    }
                }
            },
            onUpdate: function(d, c) {
                if (d.item.updateAnimation) {
                    d.item.updateAnimation(d, c)
                }
            },
            getDuration: function() {
                return this.duration
            },
            setDuration: function(c) {
                if (this.duration != c) {
                    this.duration = c
                }
            },
            getFromValue: function() {
                return this.fromValue
            },
            setFromValue: function(c) {
                if (this.fromValue != c) {
                    this.fromValue = c
                }
            },
            getToValue: function() {
                return this.toValue
            },
            setToValue: function(c) {
                if (this.toValue != c) {
                    this.toValue = c
                }
            },
            getAnimationType: function() {
                return this.animationType
            },
            setAnimationType: function(c) {
                if (this.animationType != c) {
                    this.animationType = c
                }
            },
            getParam: function() {
                return this.param
            },
            setParam: function(c) {
                if (this.param != c) {
                    this.param = c
                }
            },
            getEasingType: function() {
                return this.easingType
            },
            setEasingType: function(c) {
                if (this.easingType != c) {
                    this.easingType = c
                }
            },
            getRepeat: function() {
                return this.repeat
            },
            setRepeat: function(c) {
                if (this.repeat != c) {
                    this.repeat = c
                }
            },
            getReverse: function() {
                return this.reverse
            },
            setReverse: function(c) {
                if (this.reverse != c) {
                    this.reverse = c
                }
            }
        };
        b.requestAnimationFrame = (function() {
            if (typeof window === "undefined") {
                return
            }
            var c = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(d) {
                return window.setTimeout(d, 1000 / 60)
            };
            return c.bind(window)
        })();
        b.cancelAnimationFrame = (function() {
            if (typeof window === "undefined") {
                return
            }
            var c = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(d) {
                window.clearTimeout(d)
            };
            return c.bind(window)
        })();
        MindFusion.registerClass(b, "MindFusion.Animations.Animation", null, "Sys.IDisposable")
    })(MindFusion.Animations);
    MindFusion.Animations.Events = {
        animationComplete: "animationComplete"
    };
    MindFusion.registerNamespace("MindFusion.Graphs");
    if (typeof $skipLayout == "undefined") {
        $skipLayout = {}
    }(function(d) {
        var b = MindFusion.Collections.ArrayList;
        var f = MindFusion.Collections.Dictionary;
        var e = MindFusion.Collections.Set;
        var c = d.BorderedTreeLayout = function() {
            this.levelDistance = 10;
            this.nodeDistance = 10;
            this.keepRootPosition = false;
            this.direction = d.LayoutDirection.TopToBottom;
            this.linkType = d.TreeLayoutLinkType.Default;
            this.anchoring = d.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = d.MultipleGraphsPlacement.Horizontal
        };
        c.prototype.setsLinkPoints = true;
        c.prototype.setsLinkEndPoints = true;
        c.prototype.requiresConnectedGraph = true;
        c.prototype.requiresSimpleGraph = false;
        c.prototype.margins = 10;
        c.prototype.requiresCascadingLinks = function() {
            return this.linkType == d.TreeLayoutLinkType.Cascading
        };
        c.prototype.isStatic = function() {
            return this.keepRootPosition
        };
        c.prototype.arrange = function(C) {
            var A;
            C.vertices.forEach(function(j) {
                if (j.inEdges.length == 0) {
                    A = j;
                    return $break
                }
            });
            if (!A) {
                return $skipLayout
            }
            this.tree = C.tree(A);
            if (!this.tree) {
                return $skipLayout
            }
            var k = A.x + A.width / 2;
            var h = A.y + A.height / 2;
            this.x = 0;
            this.y = 0;
            this.rarrange(A);
            var z = new b();
            for (var t = 0; t < this.tree.treeLevels.length; t++) {
                var u = this.tree.treeLevels[t];
                var w = 0;
                for (var s = 0; s < u.length; s++) {
                    if (this.isHorizontal()) {
                        w = Math.max(w, u[s].width)
                    } else {
                        w = Math.max(w, u[s].height)
                    }
                }
                z.push(w)
            }
            var n = 0;
            var D = 0;
            for (var p = 1; p < z.length; p++) {
                D += z[p];
                D += this.levelDistance
            }
            D += this.margins;
            if (!this.isStraight()) {
                n = D
            }
            for (var t = 0; t < this.tree.treeLevels.length; t++) {
                var u = this.tree.treeLevels[t];
                for (var s = 0; s < u.length; s++) {
                    var o = u[s];
                    if (this.isHorizontal()) {
                        o.x += n
                    } else {
                        o.y += n
                    }
                }
                if (this.isStraight()) {
                    n += this.levelDistance + z[t]
                } else {
                    n += -(this.levelDistance + z[t])
                }
            }
            if (this.keepRootPosition) {
                var r = A.x;
                var q = A.y;
                var B = k - r;
                var v = h - q;
                this.offsetBranch(A, B, v)
            }
            if (this.linkType != d.TreeLayoutLinkType.Default) {
                switch (this.linkType) {
                    case d.TreeLayoutLinkType.Straight:
                        switch (this.direction) {
                            case d.LayoutDirection.TopToBottom:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x + j.origin.width / 2,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.destination.y - j.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.BottomToTop:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x + j.origin.width / 2,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.destination.y + j.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.LeftToRight:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x,
                                        y: j.origin.y + j.origin.height / 2
                                    }, {
                                        x: j.destination.x - j.destination.width / 2,
                                        y: j.destination.y
                                    }]
                                });
                                break;
                            case d.LayoutDirection.RightToLeft:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x,
                                        y: j.origin.y + j.origin.height / 2
                                    }, {
                                        x: j.destination.x + j.destination.width / 2,
                                        y: j.destination.y
                                    }]
                                });
                                break
                        }
                        break;
                    case d.TreeLayoutLinkType.Cascading:
                        switch (this.direction) {
                            case d.LayoutDirection.TopToBottom:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x + j.origin.width / 2,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.destination.y - j.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.BottomToTop:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x + j.origin.width / 2,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.origin.y
                                    }, {
                                        x: j.destination.x,
                                        y: j.destination.y + j.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.LeftToRight:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x,
                                        y: j.origin.y + j.origin.height / 2
                                    }, {
                                        x: j.origin.x,
                                        y: j.destination.y
                                    }, {
                                        x: j.destination.x - j.destination.width / 2,
                                        y: j.destination.y
                                    }]
                                });
                                break;
                            case d.LayoutDirection.RightToLeft:
                                this.tree.edges.forEach(function(j) {
                                    j.points = [{
                                        x: j.origin.x,
                                        y: j.origin.y + j.origin.height / 2
                                    }, {
                                        x: j.origin.x,
                                        y: j.destination.y
                                    }, {
                                        x: j.destination.x + j.destination.width / 2,
                                        y: j.destination.y
                                    }]
                                });
                                break
                        }
                        break
                }
            }
        };
        c.prototype.rarrange = function(k) {
            var n = new MindFusion.Drawing.Rect.fromVertex(k);
            n.x = this.x;
            n.y = this.y;
            if (this.direction == d.LayoutDirection.RightToLeft) {
                var l = MindFusion.Drawing.Rect.fromVertex(this.tree.root);
                var j = n.width;
                n = new Rect(l.right() - j, n.top(), n.width, n.height)
            } else {
                if (this.direction == d.LayoutDirection.BottomToTop) {
                    var l = MindFusion.Drawing.Rect.fromVertex(this.tree.root);
                    var j = n.height;
                    n = new Rect(n.left(), l.bottom() - j, n.width, n.height)
                }
            }
            k.x = n.x + n.width / 2;
            k.y = n.y + n.height / 2;
            if (this.isHorizontal()) {
                this.y += n.height + this.nodeDistance
            } else {
                this.x += n.width + this.nodeDistance
            }
            var h = this;
            g(k).forEach(function(o) {
                h.rarrange(o)
            })
        };
        c.prototype.offsetBranch = function(k, h, l) {
            var j = function(n, o) {
                n.x += o[0];
                n.y += o[1]
            };
            a(k, j, [h, l])
        };
        c.prototype.isHorizontal = function() {
            return this.direction == d.LayoutDirection.LeftToRight || this.direction == d.LayoutDirection.RightToLeft
        };
        c.prototype.isStraight = function() {
            return this.direction == d.LayoutDirection.LeftToRight || this.direction == d.LayoutDirection.TopToBottom
        };

        function g(j) {
            var h = new b();
            j.outEdges.forEach(function(k) {
                h.push(k.destination)
            });
            return h
        }

        function a(k, j, l) {
            j.call(this, k, l);
            var h = g(k);
            h.forEach(function(n) {
                a(n, j, l)
            })
        }
        c.With = function() {
            if (!d.BorderedTreeLayoutBuilder) {
                d.BorderedTreeLayoutBuilder = new MindFusion.Builder(c.prototype)
            } else {
                d.BorderedTreeLayoutBuilder.setInstance(null)
            }
            return d.BorderedTreeLayoutBuilder
        };
        c.prototype.init = function() {
            if (!d.BorderedTreeLayoutBuilder) {
                d.BorderedTreeLayoutBuilder = new MindFusion.Builder(c.prototype, null, this)
            } else {
                d.BorderedTreeLayoutBuilder.setInstance(this)
            }
            return d.BorderedTreeLayoutBuilder
        };
        c.prototype.getType = function() {
            return this.constructor.__typeName
        };
        d.BorderedTreeLayoutBuilder = null;
        c.prototype.getLevelDistance = function() {
            return this.levelDistance
        };
        c.prototype.setLevelDistance = function(h) {
            this.levelDistance = h
        };
        c.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        c.prototype.setNodeDistance = function(h) {
            this.nodeDistance = h
        };
        c.prototype.getKeepRootPosition = function() {
            return this.keepRootPosition
        };
        c.prototype.setKeepRootPosition = function(h) {
            this.keepRootPosition = h
        };
        c.prototype.getDirection = function() {
            return this.direction
        };
        c.prototype.setDirection = function(h) {
            this.direction = h
        };
        c.prototype.getLinkType = function() {
            return this.linkType
        };
        c.prototype.setLinkType = function(h) {
            this.linkType = h
        };
        c.prototype.getAnchoring = function() {
            return this.anchoring
        };
        c.prototype.setAnchoring = function(h) {
            this.anchoring = h
        };
        c.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        c.prototype.setKeepGroupLayout = function(h) {
            this.keepGroupLayout = h
        };
        c.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        c.prototype.setMultipleGraphsPlacement = function(h) {
            this.multipleGraphsPlacement = h
        };
        MindFusion.registerClass(c, "MindFusion.Graphs.BorderedTreeLayout")
    })(MindFusion.Graphs);
    (function(b) {
        var a = b.Edge = function(d, c) {
            this.origin = d;
            this.destination = c
        };
        a.prototype.getOtherEnd = function(c) {
            return this.origin == c ? this.destination : this.origin
        };
        a.prototype.getCommonVertex = function(c) {
            if (this.origin == c.origin || this.origin == c.destination) {
                return this.origin
            }
            if (this.destination == c.origin || this.destination == c.destination) {
                return this.destination
            }
            return null
        };
        a.prototype.joins = function(d, c) {
            if (this.origin == d && this.destination == c || this.origin == c && this.destination == d) {
                return true
            }
            return false
        };
        a.prototype.getEnds = function() {
            return [this.origin, this.destination]
        };
        a.prototype.incidentWith = function(c) {
            return this.origin == c || this.destination == c
        };
        a.prototype.adjacentTo = function(c) {
            return this.origin.edges.contains(c) || this.destination.edges.contains(c)
        };
        a.prototype.changeOrigin = function(c) {
            this.origin.edges.remove(this);
            this.origin.outEdges.remove(this);
            c.edges.push(this);
            c.outEdges.push(this);
            this.origin = c
        };
        a.prototype.changeDestination = function(c) {
            this.destination.edges.remove(this);
            this.destination.inEdges.remove(this);
            c.edges.push(this);
            c.inEdges.push(this);
            this.destination = c
        };
        a.prototype.changeVertex = function(d, c) {
            if (this.origin == d) {
                this.changeOrigin(c)
            } else {
                if (this.destination == d) {
                    this.changeDestination(c)
                }
            }
        };
        a.prototype.reverse = function() {
            var c = this.origin;
            var d = this.destination;
            this.origin = d;
            c.outEdges.remove(this);
            this.origin.outEdges.push(this);
            this.destination = c;
            d.inEdges.remove(this);
            this.destination.inEdges.push(this)
        };
        a.prototype.directTo = function(c) {
            if (this.destination != c) {
                this.reverse()
            }
        };
        a.prototype.createReverseEdge = function() {
            var c = new a(destination, origin, this);
            c.reversed = true;
            return c
        };
        MindFusion.registerClass(a, "MindFusion.Graphs.Edge")
    })(MindFusion.Graphs);
    MindFusion.Graphs.AssistantPosition = {
        Left: 1,
        Right: 2
    };
    MindFusion.Graphs.AssistantType = {
        Normal: 1,
        Left: 2,
        Right: 3
    };
    MindFusion.Graphs.Anchoring = {
        Ignore: 0,
        Keep: 1,
        Reassign: 2,
        Custom: 3
    };
    MindFusion.Graphs.LayoutDirection = {
        TopToBottom: 0,
        LeftToRight: 1,
        BottomToTop: 2,
        RightToLeft: 3
    };
    MindFusion.Graphs.TreeLayoutLinkType = {
        Default: 0,
        Straight: 1,
        Cascading: 2
    };
    MindFusion.Graphs.MultipleGraphsPlacement = {
        Vertical: 0,
        Horizontal: 1
    };
    MindFusion.Graphs.Orientation = {
        Vertical: 0,
        Horizontal: 1
    };
    (function(v) {
        var f = MindFusion.Collections.ArrayList;
        var g = MindFusion.Collections.Dictionary;
        var k = MindFusion.Collections.Set;
        var r = 1;
        var U = v.FlowchartLayout = function() {
            this.nodeDistance = 20;
            this.branchPadding = 12;
            this.linkPadding = 4;
            this.orientation = v.Orientation.Vertical;
            this.anchoring = v.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = v.MultipleGraphsPlacement.Horizontal;
            this.nodeOrder = new g();
            this.progressCounter = 0;
            this.branchings = [];
            this.visitedNodes = new g();
            this.postOrder = new g();
            this.topologicalOrder = new g();
            this.searchCounter = 0;
            this.flowchartNodes = new g()
        };
        U.prototype = {
            setsLinkEndPoints: true,
            setsLinkPoints: true,
            requiresConnectedGraph: true,
            requiresSimpleGraph: true,
            routeRepeatingLinks: true,
            margins: 10,
            arrange: function(aE) {
                r = aE._mf_mm;
                if (aE.vertices.length == 0) {
                    return false
                }
                aE.setItemIndices();
                this.graph = aE;
                var ao = this.orientation;
                this.nodeOrder = new g();
                this.branchings = [];
                this.placedNodes = [];
                this.furthestL = 0;
                this.progressCounter = 0;
                this.flowchartNodes = new g();
                var ar = this.getStartNodes();
                var aR = null;
                var aT = null;
                var at = [];
                if (ar.length == 0) {
                    aR = aE.vertices[0]
                }
                if (ar.length == 1) {
                    aR = ar[0]
                }
                if (ar.length > 1) {
                    aT = aR = new v.Vertex();
                    aR.x = aR.y = 0;
                    aR.width = aR.height = 20;
                    for (var aM = 0; aM < ar.length; aM++) {
                        var aB = ar[aM];
                        at.push(new v.Edge(aT, aB))
                    }
                    aE.vertices.push(aT);
                    for (var aN = 0; aN < at.length; aN++) {
                        var aC = at[aN];
                        aE.addEdge(aC)
                    }
                }
                var aV = aE.topologicalSort();
                if (!aV) {
                    var aS = aE.makeAcyclic();
                    aV = aE.topologicalSort()
                }
                if (aV) {
                    var aX = this.topologicalOrder = this.topologicalSort(aR, aV);
                    for (var aM = 0; aM < aE.vertices.length; aM++) {
                        var aB = aE.vertices[aM];
                        aB.outEdges.sort(function(aZ, aY) {
                            return aX.get(aZ.destination) - aX.get(aY.destination)
                        })
                    }
                }
                if (aS) {
                    aS.forEach(function(aY) {
                        aY.reverse()
                    })
                }
                this.visitedNodes = new g();
                this.postOrder = new g();
                this.searchCounter = 0;
                this.depthFirstSearch(aR);
                if (this.postOrder.getCount() < aE.vertices.length) {
                    return false
                }
                for (var aM = 0; aM < aE.vertices.length; aM++) {
                    var aB = aE.vertices[aM];
                    aB.x = aB.y = 0
                }
                for (var aN = 0; aN < aE.edges.length; aN++) {
                    var ac = aE.edges[aN];
                    ac._fcl_processed = false
                }
                if (!aV) {
                    this.topologicalOrder = this.topologicalSort(aR)
                }
                W.deferredMerge = new f();
                var ax = this.composeFlowChart(aR);
                var aF = ax.measure(this.branchPadding, this.linkPadding, ao);
                ax.arrange(aF / 2, 0, this.nodeDistance, ao);
                if (aT != null) {
                    aE.vertices.remove(aT)
                }
                for (var aN = 0; aN < at.length; aN++) {
                    var aC = at[aN];
                    aE.removeEdge(aC)
                }
                var aa = W.deferredMerge;
                for (var ag = 0; ag < aa.length; ag++) {
                    var aB = aa[ag];
                    var an = this.getDownLinks(aB.inEdges);
                    var ak = q(an, ao);
                    var Z = p.GetLNear(aB, ao);
                    if (ak >= Z) {
                        var aG = ak - Z + this.nodeDistance;
                        p.OffsetL(aB, aG, ao)
                    }
                }
                this.layoutRect = MindFusion.Diagramming.LayoutUtils.getGraphBounds(aE);
                for (var aN = 0; aN < aE.edges.length; aN++) {
                    var ac = aE.edges[aN];
                    if (!n(ac) || K(ac, this)) {
                        var aD = this.findPath(ac, ao);
                        if (!aD) {
                            aD = this.findPath(ac, ao, true)
                        }
                        p.SetLinkPointsA(ac, aD)
                    }
                }
                var ac = a(aE);
                if (ac) {
                    var aJ = w(aE, ac.points, ac);
                    var ah = N;
                    if (aJ > 0) {
                        var aA = this.branchPadding;
                        var aw = MindFusion.Diagramming.LayoutUtils.getGraphBounds(aE);
                        var ae = M(ac.origin);
                        var af = M(ac.destination);
                        var aj = ae.center();
                        var ai = af.center();
                        if (ao == v.Orientation.Vertical) {
                            var aq = aj.x;
                            var ap = ae.bottom();
                            var aL = ae.left();
                            var aK = af.left();
                            var Y = ai.x;
                            var X = af.top();
                            var ad = (aq + Y) / 2;
                            var ab = (ap + X) / 2;
                            var aP = ap + this.nodeDistance / 2;
                            var av = X - this.nodeDistance / 2;
                            var aI = [ac.points];
                            aI.push([ah(aL, aj.y), ah(aw.left() - aA, aj.y), ah(aw.left() - aA, ai.y), ah(aK, ai.y)])
                        } else {
                            var aq = ae.right();
                            var ap = aj.y;
                            var az = ae.top();
                            var au = af.top();
                            var Y = af.left();
                            var X = ai.y;
                            var ad = (aq + Y) / 2;
                            var ab = (ap + X) / 2;
                            var aQ = aq + this.nodeDistance / 2;
                            var ay = Y - this.nodeDistance / 2;
                            var aI = [ac.points];
                            aI.push([ah(aj.x, az), ah(aj.x, aw.top() - aA), ah(ai.x, aw.top() - aA), ah(ai.x, au)])
                        }
                        var aH = null;
                        var al = aJ;
                        for (var aU = 0; aU < aI.length; aU++) {
                            var aD = aI[aU];
                            if (c(aD, ac.origin, ac.destination, aE.vertices)) {
                                aJ = w(aE, aD, ac);
                                if (aJ < al) {
                                    al = aJ;
                                    aH = aD
                                }
                                if (aJ == 0) {
                                    break
                                }
                            }
                        }
                        if (aH) {
                            p.SetLinkPointsA(ac, aH)
                        }
                    }
                }
                for (var aM = 0; aM < aE.vertices.length; aM++) {
                    var aB = aE.vertices[aM];
                    var aO = H(aB, ao);
                    if (aO.length > 1 && P(aO, ao)) {
                        l(aO, ao)
                    }
                    var am = t(aB, ao);
                    if (am.length > 1 && B(am, ao)) {
                        V(am, ao)
                    }
                    var aW = L(aB, ao);
                    if (aW.length > 1 && P(aW, 1 - ao)) {
                        z(aW, ao)
                    }
                }
                this.pullLinksApart(aE.edges)
            },
            composeFlowChart: function(X) {
                return this.composeBlocks(X, null, 0, false, false)
            },
            composeBlocks: function(an, ae, ac, ai, ap) {
                var Y = this.graph;
                var af = [];
                var aa = null;
                if (ae == null) {
                    aa = new T(this);
                    af.push(this.composeBlocks(an, aa, 0, false, false))
                } else {
                    var aj = this.getFlowchartNode(an);
                    aa = aj;
                    var at = this.isVisited(an);
                    if (!at) {
                        this.nodeOrder.set(an, this.progressCounter++)
                    }
                    var ak = this.getIncomingDownLinks(an);
                    if (ak > 1 && this.branchings.length > 0 && !ap) {
                        j(this.branchings).registerMerge(aj);
                        return aa
                    }
                    if (at && ai) {
                        return null
                    }
                    ac += this.getIncomingLoopLinks(an);
                    aa.setLoopDepth(ac);
                    ac -= this.getOutgoingLoopLinks(an);
                    var aq = this.getOutgoingDownLinks(an);
                    if (aq == 1) {
                        aa = new T(this, aj)
                    }
                    if (aq > 1) {
                        var ad = new W(this, aj);
                        this.branchings.push(ad);
                        aa = ad;
                        ac = 0
                    }
                    for (var ar = 0; ar < an.outEdges.length; ++ar) {
                        var Z = an.outEdges[ar];
                        aa.currentLink = Z;
                        var ag = this.composeBlocks(Z.destination, aa, ac, true, false);
                        if (ag != null) {
                            if (ag.getIncomingLink() == null) {
                                ag.setIncomingLink(Z)
                            }
                            af.push(ag)
                        }
                    }
                    if (aa.branches && ad.branches.length == 0) {
                        this.branchings.pop();
                        return null
                    }
                    if (aq > 1 && this.branchings.length > 0) {
                        this.branchings.pop()
                    }
                    if (mflayer.isInstanceOfType(W, ae) && mflayer.isInstanceOfType(W, aa) && !this.followedByMergeNode(aa)) {
                        var ao = new T(this);
                        ao.add(aa);
                        af.length = 0;
                        af.push(aa);
                        aa = ao
                    }
                }
                if (mflayer.isInstanceOfType(T, aa)) {
                    for (var au = 0; au < af.length; ++au) {
                        var ag = af[au];
                        var al = ag.nextNodes();
                        if (al != null) {
                            for (var am = 0; am < al.length; ++am) {
                                var ab = al[am];
                                this.composeBlocks(ab, aa, ac, false, true)
                            }
                        }
                    }
                }
                if (ae != null) {
                    ae.add(aa)
                } else {
                    var X = new MindFusion.Collections.Queue();
                    for (var am = 0; am < Y.vertices.length; am++) {
                        var an = Y.vertices[am];
                        if (!this.flowchartNodes.contains(an)) {
                            X.enqueue(an)
                        }
                    }
                    while (X.getSize() > 0) {
                        var am = X.dequeue();
                        if (am.inEdges.length == 0 || this.flowchartNodes.contains(am)) {
                            continue
                        }
                        var ah = am.inEdges[0].origin;
                        if (!this.flowchartNodes.contains(ah)) {
                            X.enqueue(am)
                        } else {
                            this.composeBlocks(am, this.getSequence(this.getFlowchartNode(ah)), 0, true, true)
                        }
                    }
                }
                return aa
            },
            getSequence: function(X) {
                if (X == null) {
                    return null
                }
                if (mflayer.isInstanceOfType(T, X)) {
                    return X
                }
                return this.getSequence(X.parentBlock)
            },
            followedByMergeNode: function(aa) {
                var Z = aa.nextNodes();
                if (Z != null && Z.length == 1) {
                    var X = this.getDownLinks(Z[0].outEdges);
                    if (X.length != 1) {
                        return false
                    }
                    var Y = this.getIncomingDownLinks(X[0].destination);
                    if (Y > 1 && this.branchings.length > 0) {
                        return true
                    }
                }
                return false
            },
            getFlowchartNode: function(X) {
                if (this.flowchartNodes.contains(X)) {
                    return this.flowchartNodes.get(X)
                }
                var Y = new J(this, X);
                this.flowchartNodes.set(X, Y);
                return Y
            },
            getStartNodes: function() {
                var Y = this.graph;
                var Z = [];
                for (var aa = 0; aa < Y.vertices.length; aa++) {
                    var X = Y.vertices[aa];
                    if (this.isStartNode(X)) {
                        Z.push(X)
                    }
                }
                return Z
            },
            getOutgoingDownLinks: function(Z) {
                var aa = 0;
                for (var X = 0; X < Z.outEdges.length; ++X) {
                    var Y = Z.outEdges[X];
                    if (this.isDownLink(Y)) {
                        aa++
                    }
                }
                return aa
            },
            getIncomingDownLinks: function(Z) {
                var aa = 0;
                for (var X = 0; X < Z.inEdges.length; ++X) {
                    var Y = Z.inEdges[X];
                    if (this.isDownLink(Y)) {
                        aa++
                    }
                }
                return aa
            },
            getOutgoingLoopLinks: function(Z) {
                var aa = 0;
                for (var X = 0; X < Z.outEdges.length; ++X) {
                    var Y = Z.outEdges[X];
                    if (this.isBackLink(Y)) {
                        aa++
                    }
                }
                return aa
            },
            getIncomingLoopLinks: function(Z) {
                var aa = 0;
                for (var X = 0; X < Z.inEdges.length; ++X) {
                    var Y = Z.inEdges[X];
                    if (this.isBackLink(Y)) {
                        aa++
                    }
                }
                return aa
            },
            isVisited: function(X) {
                return this.nodeOrder.contains(X)
            },
            isStartNode: function(X) {
                return this.inDegree(X) == 0
            },
            isEndNode: function(X) {
                return this.outDegree(X) == 0
            },
            inDegree: function(X) {
                return X.inEdges.length
            },
            outDegree: function(X) {
                return X.outEdges.length
            },
            isBackLink: function(X) {
                return !this.isDownLink(X)
            },
            isDownLink: function(X) {
                var Z = X.origin;
                var Y = X.destination;
                return this.postOrder.get(Y) < this.postOrder.get(Z)
            },
            depthFirstSearch: function(Z) {
                if (this.visitedNodes.contains(Z)) {
                    return
                }
                this.visitedNodes.set(Z, true);
                for (var X = 0; X < Z.outEdges.length; ++X) {
                    var Y = Z.outEdges[X];
                    this.depthFirstSearch(Y.destination)
                }
                this.postOrder.set(Z, this.searchCounter++)
            },
            topologicalSort: function(aa, X) {
                var ad = new g();
                if (X) {
                    for (var ab = 0; ab < X.length; ab++) {
                        var ac = this.graph.vertices[X[ab]];
                        ad.set(ac, ab)
                    }
                    return ad
                }
                var ag = new MindFusion.Collections.Queue();
                var Y = 0;
                ag.enqueue(aa);
                ad.set(aa, Y++);
                while (ag.getSize() > 0) {
                    var ac = ag.dequeue();
                    var af = this.getDownLinks(ac.outEdges);
                    for (var ae = 0; ae < af.length; ++ae) {
                        var ah = af[ae];
                        var Z = ah.destination;
                        if (ad.contains(Z)) {
                            continue
                        }
                        ag.enqueue(Z);
                        ad.set(Z, Y++)
                    }
                }
                return ad
            },
            getDownLinks: function(Y) {
                var Z = [];
                for (var X = 0; X < Y.length; ++X) {
                    var aa = Y[X];
                    if (this.isDownLink(aa)) {
                        Z.push(aa)
                    }
                }
                return Z
            },
            getTopologicalOrder: function() {
                return this.topologicalOrder
            },
            findPath: function(ag, at, Y) {
                var aA = this.graph;
                var au = N;
                var ar = M(ag.origin);
                var ay = M(ag.destination);
                var ab = [];
                var av = ar.center();
                var aG = ay.center();
                if (at == v.Orientation.Vertical) {
                    var ac = av.x;
                    var aa = ar.bottom();
                    var Z = ar.left();
                    var ad = ar.right();
                    var am = aG.x;
                    var ak = ay.top();
                    var aq = (ac + am) / 2;
                    var ap = (aa + ak) / 2;
                    var af = this.nodeDistance;
                    var ae = af / 2;
                    var an = aa + ae;
                    var aB = ak - ae;
                    var ah = this.linkPadding;
                    var X = this.layoutRect.right();
                    var ai = this.layoutRect.bottom();
                    if (ar.bottom() < ay.top()) {
                        ab.push([au(ac, aa), au(ac, ap), au(am, ap), au(am, ak)]);
                        ab.push([au(ac, aa), au(ac, an), au(am, an), au(am, ak)]);
                        ab.push([au(ac, aa), au(ac, aB), au(am, aB), au(am, ak)]);
                        for (var aj = 1; aj <= 5; aj++) {
                            ab.push([au(ad, av.y), au(ad + aj * ae, av.y), au(ad + aj * ae, aG.y), au(ay.right(), aG.y)]);
                            ab.push([au(Z, av.y), au(Z - aj * ae, av.y), au(Z - aj * ae, aG.y), au(ay.left(), aG.y)])
                        }
                        ab.push([au(ad, av.y), au(X, av.y), au(X, aG.y), au(ay.right(), aG.y)]);
                        ab.push([au(ac, aa), au(ac, an), au(Z, an), au(Z, aB), au(am, aB), au(am, ak)]);
                        ab.push([au(ac, aa), au(ac, an), au(aq, an), au(aq, aB), au(am, aB), au(am, ak)])
                    } else {
                        ab.push([au(ac, aa), au(ac, an), au(aq, an), au(aq, aB), au(am, aB), au(am, ak)]);
                        ab.push([au(ac, aa), au(ac, an), au(ar.left() - ah, an), au(ar.left() - ah, aG.y), au(ay.right(), aG.y)]);
                        for (var aj = 1; aj <= 5; aj++) {
                            ab.push([au(Z, av.y), au(Z - aj * ae, av.y), au(Z - aj * ae, aG.y), au(ay.left(), aG.y)]);
                            ab.push([au(ad, av.y), au(ad + aj * ae, av.y), au(ad + aj * ae, aG.y), au(ay.right(), aG.y)])
                        }
                    }
                    ab.push([au(ac, aa), au(ac, ai), au(ay.right() + 2 * ae, ai), au(ay.right() + 2 * ae, aG.y), au(ay.right(), aG.y)]);
                    ab.push([au(ac, aa), au(ac, ai), au(ay.right() + ae, ai), au(ay.right() + ae, aG.y), au(ay.right(), aG.y)]);
                    ab.push([au(ac, aa), au(ac, ai), au(ay.right() + af, ai), au(ay.right() + af, aG.y), au(ay.right(), aG.y)]);
                    ab.push([au(ac, aa), au(ac, ai), au(ay.left() - ae, ai), au(ay.left() - ae, aG.y), au(ay.left(), aG.y)]);
                    ab.push([au(ac, aa), au(ac, ai), au(ay.left() - af, ai), au(ay.left() - af, aG.y), au(ay.left(), aG.y)])
                } else {
                    var ac = ar.right();
                    var aa = av.y;
                    var aF = ar.top();
                    var ax = ar.bottom();
                    var am = ay.left();
                    var ak = aG.y;
                    var aq = (ac + am) / 2;
                    var ap = (aa + ak) / 2;
                    var af = this.nodeDistance;
                    var ae = af / 2;
                    var ao = ac + ae;
                    var aC = am - ae;
                    var ah = this.linkPadding;
                    if (ar.right() < ay.left()) {
                        ab.push([au(ac, aa), au(aq, aa), au(aq, ak), au(am, ak)]);
                        ab.push([au(ac, aa), au(ao, aa), au(ao, ak), au(am, ak)]);
                        ab.push([au(ac, aa), au(aC, aa), au(aC, ak), au(am, ak)]);
                        for (var aj = 1; aj <= 5; aj++) {
                            ab.push([au(av.x, ax), au(av.x, ax + ae), au(aG.x, ax + ae), au(aG.x, ay.bottom())]);
                            ab.push([au(av.x, aF), au(av.x, aF - ae), au(aG.x, aF - ae), au(aG.x, ay.top())])
                        }
                        ab.push([au(ac, aa), au(ao, aa), au(ao, aF), au(aC, aF), au(aC, ak), au(am, ak)]);
                        ab.push([au(ac, aa), au(ao, aa), au(ao, ap), au(aC, ap), au(aC, ak), au(am, ak)])
                    } else {
                        ab.push([au(ac, aa), au(ao, aa), au(ao, ap), au(aC, ap), au(aC, ak), au(am, ak)]);
                        ab.push([au(ac, aa), au(ao, aa), au(ao, ar.top() - ah), au(aG.x, ar.top() - ah), au(aG.x, ay.bottom())])
                    }
                }
                if (Y) {
                    var aE = Number.MAX_VALUE;
                    var az;
                    for (var aD = 0; aD < ab.length; aD++) {
                        var aw = ab[aD];
                        var al = F(aw, ag.origin, ag.destination, aA.vertices);
                        if (al < aE) {
                            aE = al;
                            az = aw
                        }
                    }
                    return az
                } else {
                    for (var aD = 0; aD < ab.length; aD++) {
                        var aw = ab[aD];
                        if (c(aw, ag.origin, ag.destination, aA.vertices)) {
                            return aw
                        }
                    }
                }
                return null
            },
            segmentsFromPoints: function(Z) {
                var X = [];
                for (var Y = 0; Y < Z.length - 1; Y++) {
                    var aa = {
                        index: Y,
                        points: Z,
                        horizontal: function() {
                            return this.points[this.index].y == this.points[this.index + 1].y
                        },
                        xint: function() {
                            var ac = this.points[this.index].x;
                            var ab = this.points[this.index + 1].x;
                            return ac < ab ? [ac, ab] : [ab, ac]
                        },
                        yint: function() {
                            var ac = this.points[this.index].y;
                            var ab = this.points[this.index + 1].y;
                            return ac < ab ? [ac, ab] : [ab, ac]
                        }
                    };
                    X.push(aa)
                }
                return X
            },
            pullLinksApart: function(X) {
                for (var Y = 0; Y < X.length; Y++) {
                    var Z = X[Y];
                    Z._mf_segments = this.segmentsFromPoints(Z.points)
                }
                this.splitPaths(X, true);
                this.splitPaths(X, false)
            },
            splitPaths: function(Z, at) {
                var am = [];
                for (var ap = 0; ap < Z.length; ap++) {
                    var af = Z[ap];
                    var aj = af._mf_segments;
                    for (var an = 0; an < aj.length; an++) {
                        var Y = aj[an];
                        if (Y.horizontal() == at) {
                            am.push(Y)
                        }
                    }
                }
                am.sort(at ? u : A);
                var av = -(Number.MAX_VALUE - 1);
                var aw = [];
                var ae = am.length;
                for (var ap = 0; ap <= ae; ++ap) {
                    var Y = ap < ae ? am[ap] : null;
                    var ax = av;
                    if (aw.length > 0) {
                        ax = C(aw[0], at)
                    }
                    if (Y == null || Math.abs(C(Y, at) - ax) > r * 2) {
                        if (aw.length > 1) {
                            var X = e(aw, at);
                            for (var aq = 0; aq < X.length; aq++) {
                                var ag = X[aq];
                                if (ag.length < 2) {
                                    continue
                                }
                                var ab = C(ag[0], at);
                                ag.sort(at ? I : E);
                                var ah = this.linkPadding / 2;
                                var al = ab - ah * 2;
                                var ao = ab + ah * 2;
                                var ak = (al + ao) / 2;
                                var ar = Math.min((ao - al) / 2, (ag.length - 1) * 3 * ah);
                                var ad = ar / (ag.length - 1);
                                var ac = ab - ar / 2 >= al + ad ? ab - ar / 2 : ak - ar / 2;
                                for (var au = 0; au < ag.length; au++) {
                                    var ai = ag[au];
                                    var aa = ac - C(ai, at);
                                    if (at) {
                                        ai.points[ai.index].y = ac;
                                        ai.points[ai.index + 1].y = ac
                                    } else {
                                        ai.points[ai.index].x = ac;
                                        ai.points[ai.index + 1].x = ac
                                    }
                                    ac += ad
                                }
                            }
                        }
                        aw.length = 0
                    }
                    if (Y != null) {
                        av = C(Y, at);
                        if (Y.index >= 0 && Y.index <= Y.points.length - 1) {
                            aw.push(Y)
                        }
                    }
                }
            },
            getBranchPadding: function() {
                return this.branchPadding
            },
            setBranchPadding: function(X) {
                this.branchPadding = X
            },
            getLinkPadding: function() {
                return this.linkPadding
            },
            setLinkPadding: function(X) {
                this.linkPadding = X
            },
            getNodeDistance: function() {
                return this.nodeDistance
            },
            setNodeDistance: function(X) {
                this.nodeDistance = X
            },
            getOrientation: function() {
                return this.orientation
            },
            setOrientation: function(X) {
                this.orientation = X
            },
            getAnchoring: function() {
                return this.anchoring
            },
            setAnchoring: function(X) {
                this.anchoring = X
            },
            getKeepGroupLayout: function() {
                return this.keepGroupLayout
            },
            setKeepGroupLayout: function(X) {
                this.keepGroupLayout = X
            },
            getMultipleGraphsPlacement: function() {
                return this.multipleGraphsPlacement
            },
            setMultipleGraphsPlacement: function(X) {
                this.multipleGraphsPlacement = X
            },
            requiresCascadingLinks: function() {
                return true
            },
            dumpGraph: function() {
                for (var X = 0; X < this.graph.vertices.length; X++) {
                    var Z = this.graph.vertices[X];
                    console.log("************************");
                    console.log(Z.debugId);
                    for (var aa = 0; aa < Z.outEdges.length; aa++) {
                        var Y = Z.outEdges[aa];
                        console.log("    " + Y.debugId)
                    }
                }
            }
        };
        var d = v.FlowchartBlock = function(X) {
            this.flowchartLayout = X;
            this.contentBreadth = 0;
            this.fullBreadth = 0;
            this.loopDepth = 0;
            this.maxLoopDepth = 0;
            this.arranged = false;
            this.incomingLink = null;
            this.currentLink = null;
            this.parentBlock = null
        };
        d.prototype = {
            add: function(X) {
                X.parentBlock = this
            },
            measure: function(Z, X, Y) {},
            arrange: function(X, Y, aa, Z) {},
            getOutLinks: function() {},
            getInLinks: function() {},
            getBackLinks: function(Z) {
                var Y = [];
                for (var X = 0; X < Z.length; ++X) {
                    var aa = Z[X];
                    if (this.flowchartLayout.isBackLink(aa)) {
                        Y.push(aa)
                    }
                }
                return Y
            },
            nextNodes: function() {
                return null
            },
            disjoint: function(X) {
                return true
            },
            getContentBreadth: function() {
                return this.contentBreadth
            },
            getFullBreadth: function() {
                return this.fullBreadth
            },
            getLoopDepth: function() {
                return this.loopDepth
            },
            setLoopDepth: function(X) {
                this.loopDepth = X
            },
            getArranged: function() {
                return this.arranged
            },
            getIncomingLink: function() {
                return this.incomingLink
            },
            setIncomingLink: function(X) {
                this.incomingLink = X
            }
        };
        MindFusion.registerClass(d, "MindFusion.Graphs.FlowchartBlock");

        function Q(X) {
            return function(Z, Y) {
                var ab = 0;
                if (X == v.Orientation.Vertical) {
                    ab = Z.origin.y
                } else {
                    ab = Z.origin.x
                }
                var aa = 0;
                if (X == v.Orientation.Vertical) {
                    aa = Y.origin.y
                } else {
                    aa = Y.origin.x
                }
                if (ab < aa) {
                    return -1
                }
                if (ab > aa) {
                    return 1
                }
                return 0
            }
        }

        function O(X) {
            return function Y(aa, Z) {
                var ac = 0;
                if (X == v.Orientation.Vertical) {
                    ac = aa.origin.x
                } else {
                    ac = aa.origin.y
                }
                var ab = 0;
                if (X == v.Orientation.Vertical) {
                    ab = Z.origin.x
                } else {
                    ab = Z.origin.y
                }
                if (ac < ab) {
                    return -1
                }
                if (ac > ab) {
                    return 1
                }
                return 0
            }
        }

        function R(X) {
            return function(Z, Y) {
                var ac = X.getTopologicalOrder();
                if (ac.contains(Z.getNode()) && ac.contains(Y.getNode())) {
                    var ab = ac.get(Z.getNode());
                    var aa = ac.get(Y.getNode());
                    if (ab < aa) {
                        return -1
                    }
                    if (ab > aa) {
                        return 1
                    }
                }
                return 0
            }
        }
        var J = v.FlowchartNode = function(X, Y) {
            mflayer.initializeBase(J, this, [X]);
            this.node = Y
        };
        J.prototype = {
            measure: function(Z, X, Y) {
                this.maxLoopDepth = this.loopDepth;
                if (Y == v.Orientation.Vertical) {
                    this.contentBreadth = this.fullBreadth = this.node.width
                } else {
                    this.contentBreadth = this.fullBreadth = this.node.height
                }
                return this.contentBreadth
            },
            arrange: function(X, Y, ab, aa) {
                var Z = this.node;
                this.arranged = true;
                Z._fcl_arranged = true;
                this.flowchartLayout.placedNodes.push(Z);
                if (aa == v.Orientation.Vertical) {
                    p.MoveNode(Z, X - Z.width / 2, Y);
                    var Y = M(Z).bottom()
                } else {
                    p.MoveNode(Z, Y, X - Z.height / 2);
                    var Y = M(Z).right()
                }
                this.flowchartLayout.furthestL = Math.max(Y, this.flowchartLayout.furthestL);
                this.furthestL = Y;
                return Y
            },
            getOutLinks: function() {
                return this.node.outEdges
            },
            getInLinks: function() {
                return this.node.inEdges
            },
            getNode: function() {
                return this.node
            }
        };
        MindFusion.registerClass(J, "MindFusion.Graphs.FlowchartNode", d);
        var T = v.FlowchartSequence = function(Y, X) {
            mflayer.initializeBase(T, this, [Y]);
            this.sequence = [];
            if (X) {
                this.sequence.push(X)
            }
        };
        T.prototype = {
            measure: function(ab, Y, aa) {
                this.maxLoopDepth = this.getLoopDepth();
                this.contentBreadth = 0;
                for (var X = 0; X < this.sequence.length; ++X) {
                    var Z = this.sequence[X];
                    Z.measure(ab, Y, aa);
                    this.contentBreadth = Math.max(this.contentBreadth, Z.getContentBreadth());
                    this.maxLoopDepth = Math.max(this.maxLoopDepth, Z.maxLoopDepth)
                }
                this.fullBreadth = this.contentBreadth + this.maxLoopDepth * Y;
                return this.fullBreadth
            },
            arrange: function(av, aq, ae, al) {
                var ai = null;
                var au = 0;
                var ao = 0;
                for (var ac = 0; ac < this.sequence.length; ++ac) {
                    var ah = this.sequence[ac];
                    if (ah.getArranged()) {
                        ai = ah;
                        aq = Math.max(aq, ai.furthestL + ae);
                        continue
                    }
                    if (ah.getIncomingLink() != null) {
                        var an = p.GetLFarCenter(ah.getIncomingLink().origin, al);
                        av = (al == v.Orientation.Vertical) ? an.x : an.y
                    }
                    aq += au;
                    aq = ah.arrange(av, aq, ae, al);
                    if (ah.arrangeOverflow) {
                        ao = Math.max(ah.arrangeOverflow, ao)
                    }
                    au = ae;
                    if (ai != null && ai.disjoint(ah)) {
                        var Y = ai.getOutLinks();
                        if (Y != null) {
                            var Z = this.flowchartLayout.getDownLinks(Y);
                            if (Z.length > 0) {
                                var ax = Z[0].origin;
                                var ap = Z[0].destination;
                                var ad = Math.min(p.GetBreadth(ax, al), p.GetBreadth(ap, al));
                                var aj = p.GetBCenter(ax, al) - ad / 2;
                                for (var ar = 0; ar < Z.length; ++ar) {
                                    var ag = Z[ar];
                                    if (al == v.Orientation.Vertical) {
                                        var ab = aj + (ar + 1) * ad / (Z.length + 1);
                                        if (!ag._fcl_processed) {
                                            p.SetLinkPoints(ag, N(ab, M(ax).bottom()), N(ab, M(ap).top()))
                                        }
                                    } else {
                                        var aa = aj + (ar + 1) * ad / (Z.length + 1);
                                        if (!ag._fcl_processed) {
                                            p.SetLinkPoints(ag, N(M(ax).right(), aa), N(M(ap).left(), aa))
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ai = ah
                }
                for (var ac = 0; ac < this.sequence.length; ++ac) {
                    var ah = this.sequence[ac];
                    if (mflayer.isInstanceOfType(J, ah)) {
                        var am = this.getBackLinks(ah.getInLinks());
                        am.sort(Q(al));
                        for (var ar = 0; ar < am.length; ++ar) {
                            var ag = am[ar];
                            var ak = M(ag.origin);
                            var at = M(ag.destination);
                            var X = p.GetLCenter(ag.origin, al);
                            var af = p.GetLCenter(ag.destination, al);
                            var ay = av - this.getContentBreadth() / 2 + this.getFullBreadth() - (ah.getLoopDepth() - 1 - ar) * this.flowchartLayout.getLinkPadding();
                            var aw = MindFusion.Drawing.Point;
                            if (al == v.Orientation.Vertical) {
                                p.SetLinkPoints(ag, new aw(ak.right(), X), new aw(ay, X), new aw(ay, af), new aw(at.right(), af))
                            } else {
                                p.SetLinkPoints(ag, new aw(X, ak.bottom()), new aw(X, ay), new aw(af, ay), new aw(af, at.bottom()))
                            }
                        }
                    }
                }
                if (ao) {
                    this.arrangeOverflow = ao
                }
                this.furthestL = aq;
                return aq
            },
            getOutLinks: function() {
                return this.sequence[this.sequence.length - 1].getOutLinks()
            },
            getInLinks: function() {
                return this.sequence[0].getInLinks()
            },
            add: function(X) {
                this.sequence.push(X);
                mflayer.callBaseMethod(T, this, "add", [X])
            }
        };
        MindFusion.registerClass(T, "MindFusion.Graphs.FlowchartSequence", d);
        var S = function() {
            this.middleBlock = null;
            this.leftBlock = null;
            this.rightBlock = null
        };
        var W = v.FlowchartBranching = function(Y, X) {
            mflayer.initializeBase(W, this, [Y]);
            this.rootNode = X;
            this.branches = [];
            this.mergeMap = new g();
            this.mergeNodes = new f();
            this.branchPadding = 0;
            this.centeredBranching = null
        };
        W.prototype = {
            measure: function(ae, ab, ad) {
                this.branchPadding = ae;
                this.rootNode.measure(ae, ab, ad);
                for (var Y = 0; Y < this.mergeNodes.length; ++Y) {
                    var Z = this.mergeNodes[Y];
                    Z.measure(ae, ab, ad)
                }
                var aa = this.centeredBranching = this.centerNonEmptyBranch();
                if (aa != null) {
                    this.contentBreadth = aa.middleBlock.measure(ae, ab, ad);
                    this.contentBreadth = Math.max(this.contentBreadth, this.rootNode.getContentBreadth());
                    this.contentBreadth = Math.max(this.contentBreadth, this.mergeNodes[0].getContentBreadth());
                    this.contentBreadth += 2 * ae
                } else {
                    if (this.twoEmptyBranches()) {
                        this.contentBreadth = 2 * ab + Math.max(this.rootNode.getContentBreadth(), this.mergeNodes[0].getContentBreadth())
                    } else {
                        this.contentBreadth = ae * (this.branches.length - 1);
                        for (var X = 0; X < this.branches.length; ++X) {
                            var ac = this.branches[X];
                            this.contentBreadth += ac.measure(ae, ab, ad)
                        }
                        this.contentBreadth = Math.max(this.contentBreadth, this.rootNode.getContentBreadth())
                    }
                }
                this.fullBreadth = this.contentBreadth;
                return this.fullBreadth
            },
            connectNodeBorderCenters: function(Y, Z) {
                var X = p.GetLFarCenter(Y.origin, Z);
                var aa = p.GetLNearCenter(Y.destination, Z);
                p.SetLinkPoints(Y, X, aa)
            },
            arrange: function(aT, aM, al, aH) {
                var ac = this.flowchartLayout;
                var bi = this.rootNode;
                if (!bi.getArranged()) {
                    aM = bi.arrange(aT, aM, al, aH) + al
                }
                var bF = aM;
                var Y = this.sortBranches(this.branches);
                var aZ = false;
                var a9 = 0;
                if (this.centeredBranching == null) {
                    var a7 = aT - this.getContentBreadth() / 2;
                    for (var bw = 0; bw < Y.length; ++bw) {
                        var av = Y[bw];
                        a7 += av.getContentBreadth() / 2;
                        bF = Math.max(bF, av.arrange(a7, aM, al, aH));
                        if (av.arrangeOverflow) {
                            a9 += av.arrangeOverflow
                        }
                        a7 += av.getFullBreadth() - av.getContentBreadth() / 2 + this.branchPadding;
                        if (av.arrangeOverflow) {
                            a7 += av.arrangeOverflow
                        }
                    }
                } else {
                    var av = this.centeredBranching.middleBlock;
                    bF = av.arrange(aT, aM, al, aH);
                    if (av.arrangeOverflow) {
                        a9 += av.arrangeOverflow
                    }
                }
                if (this.mergeNodes.length == 1) {
                    var bo = this.mergeNodes[0];
                    if (!bo.arranged) {
                        bF = bo.arrange(aT, bF + al, al, aH)
                    } else {
                        bF = Math.max(bF, p.GetLFar(bo.getNode(), aH))
                    }
                    bo.arrangedAsMerge = true
                } else {
                    this.mergeNodes.sort(R(ac));
                    var bb = null;
                    var a6 = W.deferredMerge;
                    for (var aK = 0; aK < this.mergeNodes.length; ++aK) {
                        var bo = this.mergeNodes[aK];
                        var aA = h(bo.getInLinks());
                        if (!aA) {
                            continue
                        }
                        if (bo.getNode().outDegree() == 0 && !aA && !a6.contains(bo)) {
                            a6.push(bo.getNode())
                        }
                        var aR = ac.getDownLinks(bo.getInLinks());
                        var bc = o(aR, aH);
                        var aP = q(aR, aH);
                        var br = bo.arranged && bo.getNode()._fcl_arranged && bo.getNode().outDegree() > 0;
                        if (br) {
                            var bG = bo.getNode().edges;
                            for (var aW = 0; aW < bG.length; aW++) {
                                bG[aW]._fcl_multiMerge = true
                            }
                            continue
                        }
                        var aD = bo.arranged;
                        if (aD) {
                            var bv = bo.getNode().x;
                            var bu = bo.getNode().y
                        }
                        var a2 = aP + al;
                        var bC = a2 < this.flowchartLayout.furthestL;
                        var bD = bo.arrange(bc, a2, al, aH);
                        bF = Math.max(bF, bD);
                        var at = M(bo);
                        if (bb) {
                            if (M(bb).intersectsWith(at)) {
                                bF = bo.arrange(bc, p.GetLFar(bb.getNode(), aH) + al, al, aH)
                            }
                        } else {
                            if (bC) {
                                var ba = this.flowchartLayout.placedNodes;
                                for (var aG = 0; aG < ba.length; aG++) {
                                    var bH = ba[aG];
                                    if (bo.node != bH && M(bH).intersectsWith(at)) {
                                        bF = bo.arrange(p.GetBFar(bH, aH) + al + at.width / 2, a2, al, aH);
                                        aZ = true;
                                        break
                                    }
                                }
                            }
                        }
                        bo.arrangedAsMerge = true;
                        if (aD) {
                            var ai = bo.getNode().x - bv;
                            var ah = bo.getNode().y - bu;
                            p.OffsetOutLinks(bo.getNode().outEdges, ai, ah, aH)
                        }
                        var bG = bo.getNode().edges;
                        for (var aW = 0; aW < bG.length; aW++) {
                            bG[aW]._fcl_multiMerge = true
                        }
                        bb = bo;
                        bb._fcl_center = bc
                    }
                }
                var aa = MindFusion.Drawing.Point;
                var aV = this.centeredBranching;
                if (aV != null) {
                    if (aV.rightBlock != null) {
                        var bd = aV.rightBlock.getIncomingLink();
                        var aL = bd.origin;
                        var bm = bd.destination;
                        var bh = p.GetBFarCenter(aL, aH);
                        var am = p.GetBFarCenter(bm, aH);
                        var ab = aT + this.contentBreadth / 2;
                        var by, bx;
                        if (aH == v.Orientation.Vertical) {
                            by = new aa(ab, bh.y);
                            bx = new aa(ab, am.y)
                        } else {
                            by = new aa(bh.x, ab);
                            bx = new aa(am.x, ab)
                        }
                        p.SetLinkPoints(bd, bh, by, bx, am)
                    }
                    if (aV.leftBlock != null) {
                        var bp = aV.leftBlock.getIncomingLink();
                        var bk = bp.origin;
                        var bs = bp.destination;
                        var bh = p.GetBNearCenter(bk, aH);
                        var am = p.GetBNearCenter(bs, aH);
                        var ab = aT - this.contentBreadth / 2;
                        var by, bx;
                        if (aH == v.Orientation.Vertical) {
                            by = new aa(ab, bh.y);
                            bx = new aa(ab, am.y)
                        } else {
                            by = new aa(bh.x, ab);
                            bx = new aa(am.x, ab)
                        }
                        p.SetLinkPoints(bp, bh, by, bx, am)
                    }
                } else {
                    if (Y.length == 2) {
                        var bp = Y[0].getIncomingLink();
                        var bd = Y[1].getIncomingLink();
                        var bs = bp.destination;
                        var bm = bd.destination;
                        var aE = p.GetLNearCenter(bs, aH);
                        var ao = p.GetLNearCenter(bm, aH);
                        var bA = bi.getNode();
                        var ax = this.mergeNodes.contains(ac.getFlowchartNode(bp.destination));
                        if (p.GetB(aE, aH) < p.GetBNear(bA, aH)) {
                            var bE = p.GetBNearCenter(bA, aH);
                            var Z = new aa();
                            if (aH == v.Orientation.Vertical) {
                                Z = new aa(aE.x, bE.y)
                            } else {
                                Z = new aa(bE.x, aE.y)
                            }
                            p.SetLinkPoints(bp, bE, Z, aE)
                        } else {
                            if (!ax) {
                                var bE = p.GetLFarCenter(bA, aH);
                                var bB = (p.GetL(bE, aH) + p.GetL(aE, aH)) / 2;
                                if (aH == v.Orientation.Vertical) {
                                    p.SetLinkPoints(bp, bE, new aa(bE.x, bB), new aa(aE.x, bB), aE)
                                } else {
                                    p.SetLinkPoints(bp, bE, new aa(bB, bE.y), new aa(bB, aE.y), aE)
                                }
                            } else {
                                if (ax) {
                                    var aI = p.GetLinkPoints(bp);
                                    aI[0] = p.GetBNearCenter(bA, aH)
                                }
                            }
                        }
                        var ag = this.mergeNodes.contains(ac.getFlowchartNode(bd.destination));
                        if (p.GetB(ao, aH) > p.GetBFar(bA, aH)) {
                            var ay = p.GetBFarCenter(bA, aH);
                            var az = new aa();
                            if (aH == v.Orientation.Vertical) {
                                az = new aa(ao.x, ay.y)
                            } else {
                                az = new aa(ay.x, ao.y)
                            }
                            p.SetLinkPoints(bd, ay, az, ao)
                        } else {
                            if (!ag) {
                                var ay = p.GetLFarCenter(bA, aH);
                                var bB = (p.GetL(ay, aH) + p.GetL(ao, aH)) / 2;
                                if (aH == v.Orientation.Vertical) {
                                    p.SetLinkPoints(bd, ay, new aa(ay.x, bB), new aa(ao.x, bB), ao)
                                } else {
                                    p.SetLinkPoints(bd, ay, new aa(bB, ay.y), new aa(bB, ao.y), ao)
                                }
                            } else {
                                if (ag) {
                                    var aI = p.GetLinkPoints(bd);
                                    aI[0] = p.GetBFarCenter(bA, aH)
                                }
                            }
                        }
                    } else {
                        var be = s(Y.length, 2);
                        var aC = Y[be].getIncomingLink();
                        var X = Y.length % 2 == 0 || M(aC.origin).center().x == M(aC.destination).center().x;
                        for (var aN = 0; aN < Y.length; ++aN) {
                            var ae = Y[aN].getIncomingLink();
                            var bn = ae.origin;
                            var an = ae.destination;
                            var bz = (aN + 1) * p.GetBreadth(bn, aH) / (Y.length + 1) + p.GetBNear(bn, aH);
                            var aQ = aN < s(Y.length, 2) ? aN + 1 : Y.length - aN;
                            var bl = p.GetLFar(bn, aH) + aQ * al / (be + (X ? 1 : 2));
                            var aq = p.GetLNearCenter(an, aH);
                            if (aH == v.Orientation.Vertical) {
                                p.SetLinkPoints(ae, new aa(bz, M(bn).bottom()), new aa(bz, bl), new aa(aq.x, bl), aq)
                            } else {
                                p.SetLinkPoints(ae, new aa(M(bn).right(), bz), new aa(bl, bz), new aa(bl, aq.y), aq)
                            }
                        }
                    }
                }
                if (aV != null) {
                    this.connectNodeBorderCenters(aV.middleBlock.getIncomingLink(), aH);
                    var aR = ac.getDownLinks(this.mergeNodes[0].getInLinks());
                    for (var aM = 0; aM < aR.length; ++aM) {
                        var ae = aR[aM];
                        if (ae.origin != bi.getNode()) {
                            this.connectNodeBorderCenters(ae, aH)
                        }
                    }
                } else {
                    for (var aK = 0; aK < this.mergeNodes.length; ++aK) {
                        var bo = this.mergeNodes[aK];
                        var aR = ac.getDownLinks(bo.getInLinks());
                        aR.sort(O(aH));
                        if (aR.length == 2) {
                            var bp = aR[0];
                            var bd = aR[1];
                            if (this.twoEmptyBranches()) {
                                var aU = this.getBNearest(bi, this.mergeNodes[0], aH) - ac.getLinkPadding();
                                var a0 = this.getBFurthest(bi, this.mergeNodes[0], aH) + ac.getLinkPadding();
                                var a1 = p.GetBNearCenter(bi.getNode(), aH);
                                var ad = p.GetBFarCenter(bi.getNode(), aH);
                                var a5 = p.GetBNearCenter(this.mergeNodes[0].getNode(), aH);
                                var af = p.GetBFarCenter(this.mergeNodes[0].getNode(), aH);
                                if (aH == v.Orientation.Vertical) {
                                    p.SetLinkPoints(bp, a1, new aa(aU, a1.y), new aa(aU, a5.y), a5);
                                    p.SetLinkPoints(bd, ad, new aa(a0, ad.y), new aa(a0, af.y), af)
                                } else {
                                    p.SetLinkPoints(bp, a1, new aa(a1.x, aU), new aa(a5.x, aU), a5);
                                    p.SetLinkPoints(bd, ad, new aa(ad.x, a0), new aa(af.x, a0), af)
                                }
                            } else {
                                var ak = bp.origin;
                                var aJ = bd.origin;
                                var aS = p.GetLFarCenter(ak, aH);
                                var aX = p.GetLFarCenter(aJ, aH);
                                var bA = bi.getNode();
                                if (p.GetB(aS, aH) < p.GetBNear(bo.getNode(), aH)) {
                                    var bj = p.GetBNearCenter(bo.getNode(), aH);
                                    var Z = new aa();
                                    if (aH == v.Orientation.Vertical) {
                                        Z = new aa(aS.x, bj.y)
                                    } else {
                                        Z = new aa(bj.x, aS.y)
                                    }
                                    p.SetLinkPoints(bp, aS, Z, bj)
                                } else {
                                    if (bp.origin == bA) {
                                        var bj = p.GetBNearCenter(bo.getNode(), aH);
                                        var bJ = p.GetLinkPoints(bp);
                                        var bg = bJ[bJ.length - 2];
                                        if (aH == v.Orientation.Vertical) {
                                            bg.y = bj.y
                                        } else {
                                            bg.x = bj.x
                                        }
                                        bJ[bJ.length - 2] = bg;
                                        bJ[bJ.length - 1] = bj
                                    } else {
                                        if (bp.origin != bA) {
                                            var bj = p.GetLNearCenter(bo.getNode(), aH);
                                            var aO = 0;
                                            if (aH == v.Orientation.Vertical) {
                                                aO = (bj.y + aS.y) / 2
                                            } else {
                                                aO = (bj.x + aS.x) / 2
                                            }
                                            if (aH == v.Orientation.Vertical) {
                                                p.SetLinkPoints(bp, aS, new aa(aS.x, aO), new aa(bj.x, aO), bj)
                                            } else {
                                                p.SetLinkPoints(bp, aS, new aa(aO, aS.y), new aa(aO, bj.y), bj)
                                            }
                                        }
                                    }
                                }
                                if (p.GetB(aX, aH) > p.GetBFar(bo.getNode(), aH)) {
                                    var aF = p.GetBFarCenter(bo.getNode(), aH);
                                    var az = new aa();
                                    if (aH == v.Orientation.Vertical) {
                                        az = new aa(aX.x, aF.y)
                                    } else {
                                        az = new aa(aF.x, aX.y)
                                    }
                                    p.SetLinkPoints(bd, aX, az, aF)
                                } else {
                                    if (bd.origin == bA) {
                                        var bJ = p.GetLinkPoints(bd);
                                        var bg = bJ[bJ.length - 2];
                                        var aF = p.GetB(bg, aH) < p.GetBNear(bo.getNode(), aH) ? p.GetBNearCenter(bo.getNode(), aH) : p.GetBFarCenter(bo.getNode(), aH);
                                        if (aH == v.Orientation.Vertical) {
                                            bg.y = aF.y
                                        } else {
                                            bg.x = aF.x
                                        }
                                        bJ[bJ.length - 2] = bg;
                                        bJ[bJ.length - 1] = aF
                                    } else {
                                        if (bd.origin != bA) {
                                            var aF = p.GetLNearCenter(bo.getNode(), aH);
                                            var aO = 0;
                                            if (aH == v.Orientation.Vertical) {
                                                aO = (aF.y + aX.y) / 2
                                            } else {
                                                aO = (aF.x + aX.x) / 2
                                            }
                                            if (aH == v.Orientation.Vertical) {
                                                p.SetLinkPoints(bd, aX, new aa(aX.x, aO), new aa(aF.x, aO), aF)
                                            } else {
                                                p.SetLinkPoints(bd, aX, new aa(aO, aX.y), new aa(aO, aF.y), aF)
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            for (var aN = 0; aN < aR.length; ++aN) {
                                var ae = aR[aN];
                                var bn = ae.origin;
                                var an = ae.destination;
                                var a8 = (aN + 1) * p.GetBreadth(an, aH) / (aR.length + 1) + p.GetBNear(an, aH);
                                var aQ = aN < s(aR.length, 2) ? aN + 1 : aR.length - aN;
                                var bl = p.GetLNear(an, aH) - aQ * al / (aR.length / 2 + 1);
                                var au = p.GetLFarCenter(bn, aH);
                                if (aH == v.Orientation.Vertical) {
                                    p.SetLinkPoints(ae, au, new aa(au.x, bl), new aa(a8, bl), new aa(a8, M(an).top()))
                                } else {
                                    p.SetLinkPoints(ae, au, new aa(bl, au.y), new aa(bl, a8), new aa(M(an).left(), a8))
                                }
                            }
                        }
                    }
                }
                var ar = this.getBackLinks(bi.getInLinks());
                ar.sort(Q(aH));
                for (var aN = 0; aN < ar.length; ++aN) {
                    var ae = ar[aN];
                    var ap = M(ae.origin);
                    var aw = M(ae.destination);
                    var bz = p.GetBCenter(ae.origin, aH);
                    var bt = p.GetLCenter(ae.origin, aH);
                    var a4 = p.GetLCenter(ae.destination, aH);
                    var aY = aT - this.getContentBreadth() / 2 + this.getFullBreadth() + (bi.getLoopDepth() - 1 + aN) * ac.getLinkPadding();
                    if (aH == v.Orientation.Vertical) {
                        p.SetLinkPoints(ae, new aa(bz, ap.bottom()), new aa(bz, ap.bottom() + al / 2), new aa(aY, ap.bottom() + al / 2), new aa(aY, a4), new aa(aw.right(), a4))
                    } else {
                        p.SetLinkPoints(ae, new aa(ap.right(), bz), new aa(ap.right() + al / 2, bz), new aa(ap.right() + al / 2, aY), new aa(a4, aY), new aa(a4, aw.bottom()))
                    }
                }
                if (aZ) {
                    var bI;
                    for (var bq = 0; bq < this.mergeNodes.length; bq++) {
                        var aj = this.mergeNodes[bq];
                        var a3 = p.GetBFar(aj, aH);
                        if (bq == 0) {
                            bI = a3
                        } else {
                            bI = Math.max(bI, a3)
                        }
                    }
                    var aB = aT + this.contentBreadth / 2;
                    if (aB < bI) {
                        a9 = Math.max(a9, bI - aB)
                    }
                }
                if (a9) {
                    this.arrangeOverflow = a9
                }
                this.furthestL = bF;
                return bF
            },
            sortBranches: function(aa) {
                var Z = new g();
                for (var Y = 0; Y < aa.length; ++Y) {
                    var ab = aa[Y];
                    if (!this.mergeMap.contains(ab.getIncomingLink())) {
                        continue
                    }
                    var ac = this.mergeMap.get(ab.getIncomingLink());
                    if (!Z.contains(ac)) {
                        Z.set(ac, [])
                    }
                    Z.get(ac).push(ab)
                }
                var X = [];
                Z.forEachValue(function(ad) {
                    X = X.concat(ad)
                });
                for (var Y = 0; Y < aa.length; ++Y) {
                    var ab = aa[Y];
                    if (!this.mergeMap.contains(ab.getIncomingLink())) {
                        X.push(ab)
                    }
                }
                return X
            },
            getOutLinks: function() {
                if (this.mergeNodes.length > 0) {
                    return this.mergeNodes[0].getOutLinks()
                }
                return null
            },
            getInLinks: function() {
                return this.rootNode.getInLinks()
            },
            add: function(X) {
                this.branches.push(X);
                mflayer.callBaseMethod(W, this, "add", [X])
            },
            nextNodes: function() {
                var Y = [];
                for (var X = 0; X < this.mergeNodes.length; ++X) {
                    var Z = this.mergeNodes[X];
                    Y.push(Z.getNode())
                }
                return Y
            },
            disjoint: function(Y) {
                var X = mflayer.isInstanceOfType(W, Y) ? Y : null;
                if (X != null && this.mergeNodes.contains(X.rootNode)) {
                    return false
                }
                return true
            },
            registerMerge: function(X) {
                if (!this.mergeNodes.contains(X)) {
                    this.mergeNodes.push(X)
                }
                this.mergeMap.set(this.currentLink, X);
                if (X.parentBlock == null) {
                    X.parentBlock = this
                }
                if (this.currentLink.destination == X.getNode()) {
                    this.branches.push(new G(this.flowchartLayout, this.currentLink))
                }
            },
            twoEmptyBranches: function() {
                return (this.branches.length == 2 && mflayer.isInstanceOfType(G, this.branches[0]) && mflayer.isInstanceOfType(G, this.branches[1]) && this.mergeNodes.length == 1)
            },
            centerNonEmptyBranch: function() {
                if (this.mergeNodes.length != 1) {
                    return null
                }
                var ab = 0;
                var Z = 0;
                for (var X = 0; X < this.branches.length; ++X) {
                    var Y = this.branches[X];
                    if (mflayer.isInstanceOfType(G, Y)) {
                        ab++
                    } else {
                        Z++
                    }
                }
                if (Z != 1 || ab > 2 || ab < 1) {
                    return null
                }
                var aa = new S();
                for (var X = 0; X < this.branches.length; ++X) {
                    var Y = this.branches[X];
                    if (mflayer.isInstanceOfType(G, Y)) {
                        if (aa.rightBlock == null) {
                            aa.rightBlock = Y
                        } else {
                            aa.leftBlock = Y
                        }
                    } else {
                        aa.middleBlock = Y
                    }
                }
                return aa
            },
            getBNearest: function(Y, X, Z) {
                if (Z == v.Orientation.Vertical) {
                    return Math.min(M(Y.getNode()).left(), M(X.getNode()).left())
                } else {
                    return Math.min(M(Y.getNode()).top(), M(X.getNode()).top())
                }
            },
            getBFurthest: function(Y, X, Z) {
                if (Z == v.Orientation.Vertical) {
                    return Math.max(M(Y.getNode()).right(), M(X.getNode()).right())
                } else {
                    return Math.max(M(Y.getNode()).bottom(), M(X.getNode()).bottom())
                }
            },
            getMergeNodes: function() {
                return this.mergeNodes
            }
        };
        MindFusion.registerClass(W, "MindFusion.Graphs.FlowchartBranching", d);
        W.deferredMerge = new f();
        var G = v.EmptyBranch = function(Y, X) {
            mflayer.initializeBase(G, this, [Y]);
            this.setIncomingLink(X)
        };
        G.prototype = {
            measure: function(Z, X, Y) {
                return 0
            },
            arrange: function(X, aa, ac, ab) {
                var Z = p.GetBNearCenter(this.getIncomingLink().origin, ab);
                var Y = p.GetBNearCenter(this.getIncomingLink().destination, ab);
                if (ab == v.Orientation.Vertical) {
                    p.SetLinkPoints(this.getIncomingLink(), Z, N(X, Z.y), N(X, Y.y), Y)
                } else {
                    p.SetLinkPoints(this.getIncomingLink(), Z, N(Z.x, X), N(Y.x, X), Y)
                }
                this.furthestL = p.GetLFar(this.getIncomingLink().origin, ab);
                return this.furthestL
            },
            getOutLinks: function() {
                return null
            },
            getInLinks: function() {
                return null
            }
        };
        MindFusion.registerClass(G, "MindFusion.Graphs.EmptyBranch", d);
        var p = {
            GetLFarCenter: function(Y, Z) {
                var X = M(Y);
                if (Z == v.Orientation.Vertical) {
                    return N(X.x + X.width / 2, X.bottom())
                } else {
                    return N(X.right(), X.y + X.height / 2)
                }
            },
            GetLNearCenter: function(Y, Z) {
                var X = M(Y);
                if (Z == v.Orientation.Vertical) {
                    return N(X.x + X.width / 2, X.top())
                } else {
                    return N(X.left(), X.y + X.height / 2)
                }
            },
            GetBNearCenter: function(Y, Z) {
                var X = M(Y);
                if (Z == v.Orientation.Vertical) {
                    return N(X.left(), X.y + X.height / 2)
                } else {
                    return N(X.x + X.width / 2, X.top())
                }
            },
            GetBFarCenter: function(Y, Z) {
                var X = M(Y);
                if (Z == v.Orientation.Vertical) {
                    return N(X.right(), X.y + X.height / 2)
                } else {
                    return N(X.x + X.width / 2, X.bottom())
                }
            },
            MoveNode: function(Z, X, ab) {
                var Y = M(Z);
                Y.x = X;
                Y.y = ab;
                var aa = Y.center();
                Z.x = aa.x;
                Z.y = aa.y
            },
            SetLinkPoints: function(Y, X) {
                if (Y._fcl_processed) {
                    Y._fcl_multiMerge = true
                }
                Y._fcl_processed = true;
                Y.points = Array.prototype.slice.call(arguments, 1)
            },
            SetLinkPointsA: function(Y, X) {
                if (Y._fcl_processed) {
                    Y._fcl_multiMerge = true
                }
                Y._fcl_processed = true;
                Y.points = X
            },
            GetLinkPoints: function(X) {
                return X.points
            },
            Mirror: function(X, Y) {
                return N(Y.x + X.y - Y.y, Y.y + X.x - Y.x)
            },
            GetBreadth: function(X, Y) {
                return (Y == v.Orientation.Vertical) ? X.width : X.height
            },
            GetBCenter: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.x
                } else {
                    return X.y
                }
            },
            GetLength: function(X, Y) {
                return (Y == v.Orientation.Vertical) ? X.height : X.width
            },
            GetLCenter: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.y
                } else {
                    return X.x
                }
            },
            GetBNear: function(X, Y) {
                return p.GetBNearRect(M(X), Y)
            },
            GetBFar: function(X, Y) {
                return p.GetBFarRect(M(X), Y)
            },
            GetLNear: function(X, Y) {
                return p.GetLNearRect(M(X), Y)
            },
            GetLFar: function(X, Y) {
                return p.GetLFarRect(M(X), Y)
            },
            GetBNearRect: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.left()
                } else {
                    return X.top()
                }
            },
            GetBFarRect: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.right()
                } else {
                    return X.bottom()
                }
            },
            GetLNearRect: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.top()
                } else {
                    return X.left()
                }
            },
            GetLFarRect: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.bottom()
                } else {
                    return X.right()
                }
            },
            GetB: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.x
                } else {
                    return X.y
                }
            },
            GetL: function(X, Y) {
                if (Y == v.Orientation.Vertical) {
                    return X.y
                } else {
                    return X.x
                }
            },
            OffsetL: function(aa, ad, Z) {
                if (Z == v.Orientation.Vertical) {
                    aa.y = aa.y + ad
                } else {
                    aa.x = aa.x + ad
                }
                for (var ac = 0; ac < aa.inEdges.length; ac++) {
                    var ag = aa.inEdges[ac];
                    var Y = ag.points;
                    if (!Y) {
                        continue
                    }
                    var ah = Y.length - 1;
                    if (Z == v.Orientation.Vertical) {
                        var X = Y[0].y;
                        var aj = Y[ah].y;
                        var ab = Y[ah].y + ad;
                        var af = (X - aj) * (X - ab) < 0;
                        if (!af) {
                            for (var ae = 1; ae < ah; ae++) {
                                Y[ae].y += ad
                            }
                        } else {
                            for (var ae = 1; ae < ah; ae++) {
                                var ai = X - Y[ae].y;
                                Y[ae].y += ai
                            }
                        }
                        Y[ah].y += ad
                    } else {
                        var X = Y[0].x;
                        var aj = Y[ah].x;
                        var ab = Y[ah].x + ad;
                        var af = (X - aj) * (X - ab) < 0;
                        if (!af) {
                            for (var ae = 1; ae < ah; ae++) {
                                Y[ae].x += ad
                            }
                        } else {
                            for (var ae = 1; ae < ah; ae++) {
                                var ak = X - Y[ae].x;
                                Y[ae].x += ak
                            }
                        }
                        Y[ah].x += ad
                    }
                }
            },
            OffsetOutLinks: function(ak, ah, ag, Z) {
                for (var aa = 0; aa < ak.length; aa++) {
                    var ai = ak[aa];
                    var Y = ai.points;
                    if (!Y) {
                        continue
                    }
                    var aj = Y.length - 1;
                    if (Z == v.Orientation.Vertical) {
                        var ac = Y[0].y;
                        var ad = Y[0].y + ag;
                        var ab = Y[aj].y;
                        var af = (ac - ab) * (ad - ab) < 0;
                        if (!af) {
                            for (var ae = 1; ae < aj; ae++) {
                                Y[ae].y += ag
                            }
                        } else {
                            for (var ae = 1; ae < aj; ae++) {
                                var al = ab - Y[ae].y;
                                Y[ae].y += al
                            }
                        }
                        Y[0].x += ah;
                        Y[0].y += ag;
                        if (Y.length == 2) {
                            var X = Y[0];
                            var an = Y[1];
                            Y[1] = N(X.x, (X.y + an.y) / 2);
                            Y[2] = N(an.x, (X.y + an.y) / 2);
                            Y[3] = an
                        } else {
                            Y[1].x += ah
                        }
                        ai._fcl_processed = true
                    } else {
                        var ac = Y[0].x;
                        var ad = Y[0].x + ah;
                        var ab = Y[aj].x;
                        var af = (ac - ab) * (ad - ab) < 0;
                        if (!af) {
                            for (var ae = 1; ae < aj; ae++) {
                                Y[ae].x += ah
                            }
                        } else {
                            for (var ae = 1; ae < aj; ae++) {
                                var am = ab - Y[ae].x;
                                Y[ae].x += am
                            }
                        }
                        Y[0].x += ah;
                        Y[0].y += ag;
                        if (Y.length == 2) {
                            var X = Y[0];
                            var an = Y[1];
                            Y[1] = N((X.x + an.x) / 2, X.y);
                            Y[2] = N((X.x + an.x) / 2, an.y);
                            Y[3] = an
                        } else {
                            Y[1].y += ag
                        }
                        ai._fcl_processed = true
                    }
                }
            }
        };
        U.With = function() {
            if (!v.FlowchartLayoutBuilder) {
                v.FlowchartLayoutBuilder = new MindFusion.Builder(U.prototype)
            } else {
                v.FlowchartLayoutBuilder.setInstance(null)
            }
            return v.FlowchartLayoutBuilder
        };
        U.prototype.init = function() {
            if (!v.FlowchartLayoutBuilder) {
                v.FlowchartLayoutBuilder = new MindFusion.Builder(U.prototype, null, this)
            } else {
                v.FlowchartLayoutBuilder.setInstance(this)
            }
            return v.FlowchartLayoutBuilder
        };
        U.prototype.getType = function() {
            return this.constructor.__typeName
        };
        v.FlowchartLayoutBuilder = null;
        MindFusion.registerClass(U, "MindFusion.Graphs.FlowchartLayout");

        function j(X) {
            return X[X.length - 1]
        }

        function N(X, Y) {
            return new MindFusion.Drawing.Point(X, Y)
        }

        function M(X) {
            if (X.node) {
                return MindFusion.Drawing.Rect.fromCenterAndSize(X.node, X.node)
            } else {
                return MindFusion.Drawing.Rect.fromCenterAndSize(X, X)
            }
        }

        function s(X, Y) {
            return (X - X % Y) / Y
        }

        function c(ag, Z, ad, X) {
            var ai = MindFusion.Geometry;
            var ah = M(Z);
            var ac = M(ad);
            for (var Y = 1; Y < ag.length - 1; Y++) {
                var af = ag[Y];
                if (ah.containsPoint(af)) {
                    return false
                }
                if (ac.containsPoint(af)) {
                    return false
                }
            }
            for (var aa = 0; aa < X.length; aa++) {
                var ab = X[aa];
                if (ab == Z || ab == ad) {
                    continue
                }
                var ae = M(ab);
                if (ai.polylineIntersectsRect(ag, ae)) {
                    return false
                }
            }
            return true
        }

        function F(ah, Z, ad, X) {
            var ae = 0;
            var aj = MindFusion.Geometry;
            var ai = M(Z);
            var ac = M(ad);
            for (var Y = 1; Y < ah.length - 1; Y++) {
                var ag = ah[Y];
                if (ai.containsPoint(ag)) {
                    ae += 2
                }
                if (ac.containsPoint(ag)) {
                    ae += 2
                }
            }
            for (var aa = 0; aa < X.length; aa++) {
                var ab = X[aa];
                if (ab == Z || ab == ad) {
                    continue
                }
                var af = M(ab);
                if (aj.polylineIntersectsRect(ah, af)) {
                    ae += 1
                }
            }
            return ae
        }

        function K(Y, X) {
            var Z = Y.points;
            if (Z.length == 2 && D(Z) > 2 * X.nodeDistance) {
                if (!c(Z, Y.origin, Y.destination, X.graph.vertices)) {
                    return true
                }
            }
            if (Y._fcl_multiMerge && D(Z) > 3.3 * X.nodeDistance) {
                if (!c(Z, Y.origin, Y.destination, X.graph.vertices)) {
                    return true
                }
            }
            if (Y._fcl_multiMerge && Z.length == 3) {
                if (!c(Z, Y.origin, Y.destination, X.graph.vertices)) {
                    return true
                }
            }
            return false
        }

        function n(Y) {
            if (!Y._fcl_processed) {
                return false
            }
            if (Y.points.length == 2) {
                var Z = Y.points[0];
                var X = Y.points[1];
                if (Z.x != X.x && Z.y != X.y) {
                    return false
                }
            }
            return true
        }

        function D(aa) {
            var Y = 0;
            for (var ac = 0; ac < aa.length - 1; ac++) {
                var ad = aa[ac];
                var ab = aa[ac + 1];
                var Z = Math.abs(ad.x - ab.x);
                var X = Math.abs(ad.y - ab.y);
                Y += Z + X
            }
            return Y
        }

        function a(ac) {
            var Z = 0;
            var aa = null;
            for (var Y = 0; Y < ac.edges.length; Y++) {
                var ab = ac.edges[Y];
                var X = D(ab.points);
                if (X > Z) {
                    Z = X;
                    aa = ab
                }
            }
            return aa
        }

        function w(ad, aa, ac) {
            var X = MindFusion.Geometry;
            var Z = 0;
            for (var Y = 0; Y < ad.edges.length; Y++) {
                var ab = ad.edges[Y];
                if (ab == ac) {
                    continue
                }
                if (X.polylinesIntersect(aa, ab.points)) {
                    Z++
                }
            }
            return Z
        }

        function H(ac, ad) {
            var ab = M(ac);
            var Z = [];
            for (var Y = 0; Y < ac.inEdges.length; Y++) {
                var aa = ac.inEdges[Y];
                var X = aa.points.length - 1;
                if (ad == v.Orientation.Vertical) {
                    if (aa.points[X].y == ab.y) {
                        Z.push(aa)
                    }
                } else {
                    if (aa.points[X].x == ab.x) {
                        Z.push(aa)
                    }
                }
            }
            return Z
        }

        function t(ac, ad) {
            var ab = M(ac);
            var Z = [];
            for (var Y = 0; Y < ac.outEdges.length; Y++) {
                var aa = ac.outEdges[Y];
                var X = 0;
                if (ad == v.Orientation.Vertical) {
                    if (aa.points[X].y == ab.bottom()) {
                        Z.push(aa)
                    }
                } else {
                    if (aa.points[X].x == ab.right()) {
                        Z.push(aa)
                    }
                }
            }
            return Z
        }

        function L(ac, ad) {
            var ab = M(ac);
            var Z = [];
            for (var Y = 0; Y < ac.inEdges.length; Y++) {
                var aa = ac.inEdges[Y];
                var X = aa.points.length - 1;
                if (ad == v.Orientation.Vertical) {
                    if (aa.points[X].x == ab.right()) {
                        Z.push(aa)
                    }
                } else {
                    if (aa.points[X].y == ab.bottom()) {
                        Z.push(aa)
                    }
                }
            }
            return Z
        }

        function B(aa, ac) {
            for (var Z = 0; Z < aa.length; Z++) {
                var ab = aa[Z];
                for (var X = Z + 1; X < aa.length; X++) {
                    var Y = aa[X];
                    if (ac == v.Orientation.Vertical) {
                        if (ab.points[0].x == Y.points[0].x) {
                            return true
                        }
                    } else {
                        if (ab.points[0].y == Y.points[0].y) {
                            return true
                        }
                    }
                }
            }
            return false
        }

        function P(ac, ae) {
            for (var aa = 0; aa < ac.length; aa++) {
                var ad = ac[aa];
                var Y = ad.points.length - 1;
                for (var X = aa + 1; X < ac.length; X++) {
                    var Z = ac[X];
                    var ab = Z.points.length - 1;
                    if (ae == v.Orientation.Vertical) {
                        if (ad.points[Y].x == Z.points[ab].x) {
                            return true
                        }
                    } else {
                        if (ad.points[Y].y == Z.points[ab].y) {
                            return true
                        }
                    }
                }
            }
            return false
        }

        function l(am, Z) {
            var aa = am[0].destination;
            var X = M(aa);
            var ae = X.center();
            var ac = Z == v.Orientation.Vertical;
            var ak = ac ? {
                x: ae.x,
                y: ae.y - 20
            } : {
                x: ae.x - 20,
                y: ae.y
            };
            var ag = {
                x: ae.x,
                y: ae.y
            };
            am.sort(function(aq, ap) {
                var aw = M(aq.origin).center();
                var at = M(aq.destination).center();
                var av = M(ap.origin).center();
                var ar = M(ap.destination).center();
                var au = MindFusion.Geometry.calcAngle;
                var ao = au(ak, ag, aw, at);
                var an = au(ak, ag, av, ar);
                return ac ? an - ao : ao - an
            });
            for (var ab = 0; ab < am.length; ++ab) {
                var af = am[ab];
                var ai = af.origin;
                var ah = af.destination;
                var al = (ab + 1) * p.GetBreadth(ah, Z) / (am.length + 1) + p.GetBNear(ah, Z);
                var ad = ab < s(am.length, 2) ? ab + 1 : am.length - ab;
                var aj = af.points.length - 1;
                var Y = aj - 1;
                if (ac) {
                    af.points[aj].x = af.points[Y].x = al
                } else {
                    af.points[aj].y = af.points[Y].y = al
                }
            }
        }

        function V(am, Z) {
            var aa = am[0].origin;
            var X = M(aa);
            var ae = X.center();
            var ac = Z == v.Orientation.Vertical;
            var ak = {
                x: ae.x,
                y: ae.y
            };
            var ag = ac ? {
                x: ae.x,
                y: ae.y + 20
            } : {
                x: ae.x + 20,
                y: ae.y
            };
            am.sort(function(aq, ap) {
                var aw = M(aq.origin).center();
                var at = M(aq.destination).center();
                var av = M(ap.origin).center();
                var ar = M(ap.destination).center();
                var au = MindFusion.Geometry.calcAngle;
                var ao = au(ak, ag, aw, at);
                var an = au(ak, ag, av, ar);
                return ac ? ao - an : an - ao
            });
            for (var ab = 0; ab < am.length; ++ab) {
                var af = am[ab];
                var ai = af.origin;
                var ah = af.destination;
                var al = (ab + 1) * p.GetBreadth(ai, Z) / (am.length + 1) + p.GetBNear(ai, Z);
                var ad = ab < s(am.length, 2) ? ab + 1 : am.length - ab;
                var aj = 0;
                var Y = 1;
                if (ac) {
                    af.points[aj].x = af.points[Y].x = al
                } else {
                    af.points[aj].y = af.points[Y].y = al
                }
            }
        }

        function z(am, Z) {
            var aa = am[0].destination;
            var X = M(aa);
            var af = X.center();
            var ad = Z == v.Orientation.Vertical;
            var al = ad ? {
                x: af.x - 20,
                y: af.y
            } : {
                x: af.x,
                y: af.y - 20
            };
            var ah = {
                x: af.x,
                y: af.y
            };
            am.sort(function(aq, ap) {
                var aw = M(aq.origin).center();
                var at = aq.points[aq.points.length - 1];
                var av = M(ap.origin).center();
                var ar = ap.points[ap.points.length - 1];
                var au = MindFusion.Geometry.calcAngle;
                var ao = au(al, ah, aw, at);
                var an = au(al, ah, av, ar);
                return ad ? an - ao : ao - an
            });
            for (var ab = 0; ab < am.length; ++ab) {
                var ag = am[ab];
                var aj = ag.origin;
                var ai = ag.destination;
                var ac = (ab + 1) * p.GetLength(ai, Z) / (am.length + 1) + p.GetLNear(ai, Z);
                var ae = ab < s(am.length, 2) ? ab + 1 : am.length - ab;
                var ak = ag.points.length - 1;
                var Y = ak - 1;
                if (ad) {
                    ag.points[ak].y = ag.points[Y].y = ac
                } else {
                    ag.points[ak].x = ag.points[Y].x = ac
                }
            }
        }

        function A(Y, X) {
            var aa = Y.points[Y.index];
            var Z = X.points[X.index];
            if (aa.x < Z.x) {
                return -1
            }
            if (aa.x > Z.x) {
                return 1
            }
            return 0
        }

        function u(Y, X) {
            var aa = Y.points[Y.index];
            var Z = X.points[X.index];
            if (aa.y < Z.y) {
                return -1
            }
            if (aa.y > Z.y) {
                return 1
            }
            return 0
        }

        function E(ai, ag) {
            var ac = ai.points.length - 1;
            var aa = ag.points.length - 1;
            var aj = ai.index > 0 ? ai.points[ai.index - 1] : ai.points[0];
            var ah = ag.index > 0 ? ag.points[ag.index - 1] : ag.points[0];
            var af = ai.points[ai.index];
            var ae = ag.points[ag.index];
            var Z = ai.index < ac ? ai.points[ai.index + 1] : ai.points[ac];
            var Y = ag.index < aa ? ag.points[ag.index + 1] : ag.points[aa];
            var ad = af.y > Z.y;
            var ab = ae.y > Y.y;
            var X = aj.x > af.x;
            var ak = ah.x > ae.x;
            if (X && ak) {
                if (ad && ab) {
                    if (af.y < ae.y) {
                        return 1
                    }
                    if (af.y > ae.y) {
                        return -1
                    }
                }
                if (!ad && !ab) {
                    if (af.y < ae.y) {
                        return -1
                    }
                    if (af.y > ae.y) {
                        return 1
                    }
                }
            }
            if (ad && ab) {
                if (af.y < ae.y) {
                    return -1
                }
                if (af.y > ae.y) {
                    return 1
                }
            }
            if (!ad && !ab) {
                if (af.y < ae.y) {
                    return 1
                }
                if (af.y > ae.y) {
                    return -1
                }
            }
            if (ad && !ab) {
                return -1
            }
            if (!ad && ab) {
                return 1
            }
            if (aj.x < ah.x) {
                return -1
            }
            if (aj.x > ah.x) {
                return 1
            }
            return 0
        }

        function I(Y, X) {
            var aa = Y.points[0];
            var Z = X.points[0];
            if (aa.y < Z.y) {
                return -1
            }
            if (aa.y > Z.y) {
                return 1
            }
            return 0
        }

        function C(Z, Y) {
            var X = Z.points[Z.index];
            return Y ? X.y : X.x
        }

        function e(ac, X) {
            var ak = new MindFusion.Graphs.Graph();
            var ag = [];
            for (var ab = 0; ab < ac.length; ab++) {
                var af = ac[ab];
                var ae = ak.createVertex(null, af);
                ag.push(ae)
            }
            for (var ab = 0; ab < ac.length - 1; ab++) {
                for (var aa = ab + 1; aa < ac.length; aa++) {
                    var Z = X ? ac[ab].xint() : ac[ab].yint();
                    var Y = X ? ac[aa].xint() : ac[aa].yint();
                    if (b(Z, Y)) {
                        ak.createEdge(ag[ab], ag[aa])
                    }
                }
            }
            var ad = ak.getConnectedComponents();
            var al = [];
            for (var ab = 0; ab < ad.length; ab++) {
                var ah = ad[ab];
                var aj = [];
                for (var ai = 0; ai < ah.vertices.length; ai++) {
                    var ae = ah.vertices[ai];
                    aj.push(ae.owner)
                }
                al.push(aj)
            }
            return al
        }

        function b(Y, X) {
            if (Y[0] >= X[1]) {
                return false
            }
            if (X[0] >= Y[1]) {
                return false
            }
            return true
        }

        function h(Y) {
            for (var X = 0; X < Y.length; ++X) {
                var Z = Y[X];
                if (!Z.origin._fcl_arranged) {
                    return false
                }
            }
            return true
        }

        function o(Y, ad) {
            var Z = MindFusion.Drawing.Rect;
            var ab = Z.empty;
            for (var X = 0; X < Y.length; ++X) {
                var aa = Y[X];
                var ac = M(aa.origin);
                ab = ab.isEmpty() ? ac : ac.union(ab)
            }
            return (ad == v.Orientation.Vertical) ? ab.x + ab.width / 2 : ab.y + ab.height / 2
        }

        function q(Y, ad) {
            var Z = MindFusion.Drawing.Rect;
            var ab = Z.empty;
            for (var X = 0; X < Y.length; ++X) {
                var aa = Y[X];
                var ac = M(aa.origin);
                ab = ab.isEmpty() ? ac : ac.union(ab)
            }
            return (ad == v.Orientation.Vertical) ? ab.bottom() : ab.right()
        }
    })(MindFusion.Graphs);
    (function(c) {
        var d = MindFusion.Collections.Dictionary;
        var a = MindFusion.Collections.ArrayList;
        var e = c.FractalLayout = function() {
            this.anchoring = c.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.root = null;
            this.multipleGraphsPlacement = c.MultipleGraphsPlacement.Horizontal
        };
        e.prototype.setsLinkPoints = false;
        e.prototype.setsLinkEndPoints = false;
        e.prototype.requiresConnectedGraph = true;
        e.prototype.requiresSimpleGraph = true;
        e.prototype.margins = 10;
        e.prototype.arrange = function(h) {
            var f = this.root && this.root.vertex && h.vertices.contains(this.root.vertex) ? this.root.vertex : h.vertices[0];
            f.isRoot = true;
            this.branchCircles = new d();
            this.measureCircles(f);
            var g = this.branchCircles.get(f);
            this.arrangeCircles(g, {
                x: 0,
                y: 0
            }, 0)
        };
        e.prototype.measureCircles = function(t) {
            var p = t.width;
            var v = t.height;
            var l = {};
            var n = Math.sqrt(p * p + v * v) / 2;
            l.node = t;
            this.branchCircles.set(t, l);
            var k = [];
            var j = 0;
            t.getNeighbors().forEach(function(w) {
                if (this.branchCircles.contains(w)) {
                    return
                }
                var h = this.measureCircles(w);
                k.push(h);
                j += h.radius
            }, this);
            k.sort(b);
            if (!t.isRoot) {
                j = j * 72 / 71
            }
            var o = [{
                x: -p / 2,
                y: -v / 2
            }, {
                x: p / 2,
                y: -v / 2
            }, {
                x: p / 2,
                y: v / 2
            }, {
                x: -p / 2,
                y: v / 2
            }];
            var s = 0;
            if (!t.isRoot) {
                s += Math.PI / 72
            }
            var f = 2 * Math.PI;
            for (var u = 0; u < k.length; ++u) {
                var z = k[u];
                var r = f * z.radius / j;
                if (r > Math.PI) {
                    r = Math.PI;
                    f = Math.PI;
                    j -= z.radius
                }
                z.sweepAngle = r
            }
            for (var u = 0; u < k.length; ++u) {
                var z = k[u];
                var A = z.sweepAngle / 2;
                s += A;
                z.angle = s;
                s += A;
                var B = Math.max(n + z.radius, z.radius / Math.sin(A));
                z.centerDelta = B;
                var q = Math.max(n + 2 * z.radius, z.radius + z.radius / Math.sin(A));
                var g = {
                    x: q * Math.cos(z.angle),
                    y: q * Math.sin(z.angle)
                };
                o.push(g)
            }
            if (k.length > 0) {
                var C = MindFusion.Geometry.Circle.fromPoints(o);
                l.radius = C.r;
                l.centerX = C.x;
                l.centerY = C.y
            } else {
                l.radius = n;
                l.centerX = l.centerY = 0
            }
            l.childCircles = k;
            return l
        };
        e.prototype.arrangeCircles = function(h, f, k) {
            var g = k;
            if (!h.node.isRoot) {
                g += Math.PI - h.angle
            }
            var j = {
                x: f.x - h.centerX,
                y: f.y - h.centerY
            };
            a.forEach(h.childCircles, function(n) {
                var l = {
                    x: j.x + n.centerDelta * Math.cos(n.angle),
                    y: j.y + n.centerDelta * Math.sin(n.angle)
                };
                l = MindFusion.Geometry.rotatePoint(l, f, g);
                this.arrangeCircles(n, l, g)
            }, this);
            j = MindFusion.Geometry.rotatePoint(j, f, g);
            h.node.x = j.x;
            h.node.y = j.y
        };

        function b(j, h) {
            var g = j.radius;
            var f = h.radius;
            if (g < f) {
                return 1
            }
            if (g > f) {
                return -1
            }
            return 0
        }
        e.With = function() {
            if (!c.FractalLayoutBuilder) {
                c.FractalLayoutBuilder = new MindFusion.Builder(e.prototype)
            } else {
                c.FractalLayoutBuilder.setInstance(null)
            }
            return c.FractalLayoutBuilder
        };
        e.prototype.init = function() {
            if (!c.FractalLayoutBuilder) {
                c.FractalLayoutBuilder = new MindFusion.Builder(e.prototype, null, this)
            } else {
                c.FractalLayoutBuilder.setInstance(this)
            }
            return c.FractalLayoutBuilder
        };
        e.prototype.getType = function() {
            return this.constructor.__typeName
        };
        c.FractalLayoutBuilder = null;
        e.prototype.getAnchoring = function() {
            return this.anchoring
        };
        e.prototype.setAnchoring = function(f) {
            this.anchoring = f
        };
        e.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        e.prototype.setKeepGroupLayout = function(f) {
            this.keepGroupLayout = f
        };
        e.prototype.getRoot = function() {
            return this.root
        };
        e.prototype.setRoot = function(f) {
            this.root = f
        };
        e.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        e.prototype.setMultipleGraphsPlacement = function(f) {
            this.multipleGraphsPlacement = f
        };
        MindFusion.registerClass(e, "MindFusion.Graphs.FractalLayout")
    })(MindFusion.Graphs);
    (function(c) {
        var g = MindFusion.Collections.ArrayList;
        var d = MindFusion.Collections.Dictionary;
        var a = MindFusion.Graphs.AssistantPosition;
        var j = MindFusion.Graphs.AssistantType;
        var e = c.Graph = function() {
            this.vertices = new g();
            this.edges = new g()
        };
        e.prototype.clone = function(k) {
            var n = new e();
            if (k) {
                n.vertexCopyToOrigMap = new d();
                n.edgeCopyToOrigMap = new d()
            }
            var l = new d();
            this.vertices.forEach(function(o) {
                var p = o.clone();
                l.set(o, p);
                n.vertices.push(p);
                if (k) {
                    n.vertexCopyToOrigMap.set(p, o)
                }
            });
            this.edges.forEach(function(p) {
                if (l.contains(p.origin) && l.contains(p.destination)) {
                    var o = n.createEdge(l.get(p.origin), l.get(p.destination));
                    if (k) {
                        n.edgeCopyToOrigMap.set(o, p)
                    }
                }
            });
            return n
        };
        e.prototype.tree = function(s, v, r) {
            var w = new e();
            s.level = 0;
            w.root = s;
            var q = new g();
            var n = new g();
            w.vertices.push(s);
            q.push(s);
            n.push(s);
            var l = 1;
            while (n.length > 0) {
                var p = n.pop();
                p.outEdges.forEach(function(B) {
                    if (q.contains(B.destination)) {
                        return
                    }
                    var A = B.origin;
                    var z = B.destination;
                    z.level = A.level + 1;
                    z.parent = A;
                    if (l < z.level + 1) {
                        l = z.level + 1
                    }
                    n.push(z);
                    q.push(z);
                    w.vertices.push(z);
                    w.edges.push(B)
                })
            }
            if (v) {
                n.push(s);
                q = new g();
                q.push(s);
                while (n.length > 0) {
                    var p = n.pop();
                    var u = a.Right;
                    for (var o = 0; o < p.outEdges.length; o++) {
                        var k = p.outEdges[o].destination;
                        if (q.contains(k)) {
                            continue
                        }
                        n.push(k);
                        q.push(k);
                        switch (k.owner.getLayoutTraits().treeLayoutAssistant) {
                            case j.Left:
                                k.assistantPosition = a.Left;
                                break;
                            case j.Right:
                                k.assistantPosition = a.Right;
                                break;
                            case j.Normal:
                                if (u === a.Left) {
                                    k.assistantPosition = a.Right
                                } else {
                                    k.assistantPosition = a.Left
                                }
                                break;
                            default:
                                continue
                        }
                        u = k.assistantPosition
                    }
                }
                q = new g();
                l = this.reassignLevels(q, s, r) + 1
            }
            var t = new g();
            for (var o = 0; o < l; o++) {
                t.push(new g())
            }
            w.vertices.forEach(function(z) {
                t[z.level].push(z)
            });
            w.treeLevels = t;
            return w
        };
        e.prototype.reassignLevels = function(r, u, s) {
            var k = u.level;
            var l = u.level;
            var v = u.level;
            var t = -1;
            var q = new g();
            for (var o = 0; o < u.outEdges.length; o++) {
                q.push(u.outEdges[o].destination)
            }
            q.sort(function(z, w) {
                var B = z.owner.getLayoutTraits().treeLayoutAssistant;
                var A = w.owner.getLayoutTraits().treeLayoutAssistant;
                if (B && !A) {
                    return -1
                }
                if (!B && A) {
                    return 1
                }
                return z.index - w.index
            });
            for (var o = 0; o < q.length; o++) {
                var n = q[o];
                if (r.contains(n)) {
                    continue
                }
                r.push(n);
                if (n.owner.getLayoutTraits().treeLayoutAssistant) {
                    if (n.assistantPosition === a.Left) {
                        if (s) {
                            n.level = k + 1
                        } else {
                            n.level = Math.max(k, l) + 1
                        }
                    } else {
                        if (n.assistantPosition === a.Right) {
                            if (s) {
                                n.level = l + 1
                            } else {
                                n.level = v + 1
                            }
                        }
                    }
                } else {
                    if (t === -1) {
                        t = Math.max(k, l) + 1
                    }
                    n.level = t
                }
                var p = this.reassignLevels(r, n, s);
                if (n.owner.getLayoutTraits().treeLayoutAssistant) {
                    if (n.assistantPosition === a.Left) {
                        k = Math.max(k, p)
                    } else {
                        l = Math.max(l, p);
                        v = Math.max(k, l)
                    }
                } else {
                    v = Math.max(v, p)
                }
            }
            return Math.max(v, k)
        };
        e.prototype.createEdge = function(n, l, k) {
            var o = new c.Edge(n, l);
            this.edges.push(o);
            o.origin.outEdges.push(o);
            o.origin.edges.push(o);
            o.destination.inEdges.push(o);
            o.destination.edges.push(o);
            if (k) {
                o.owner = k
            }
            return o
        };
        e.prototype.addEdge = function(k) {
            this.edges.push(k);
            k.origin.outEdges.push(k);
            k.origin.edges.push(k);
            k.destination.inEdges.push(k);
            k.destination.edges.push(k)
        };
        e.prototype.removeEdge = function(k) {
            this.edges.remove(k);
            g.remove(k.origin.outEdges, k);
            g.remove(k.origin.edges, k);
            g.remove(k.destination.inEdges, k);
            g.remove(k.destination.edges, k)
        };
        e.prototype.createVertex = function(l, k) {
            var n = new c.Vertex();
            this.vertices.push(n);
            if (l) {
                n.x = l.x;
                n.y = l.y;
                n.width = l.width;
                n.height = l.height
            }
            if (k) {
                n.owner = k
            }
            return n
        };
        e.prototype.addVertexAndOutEdges = function(k) {
            this.vertices.push(k);
            g.forEach(k.outEdges, function(l) {
                this.edges.push(l)
            }, this)
        };
        e.prototype.setItemIndices = function() {
            for (var k = 0; k < this.vertices.length; ++k) {
                var n = this.vertices[k];
                n.index = k
            }
            for (var k = 0; k < this.edges.length; ++k) {
                var l = this.edges[k];
                l.index = k
            }
        };
        e.prototype.getConnectedComponents = function() {
            this.searchCounter = 0;
            this.setItemIndices();
            var l = h(this.vertices.length, -1);
            for (var k = 0; k < this.vertices.length; k++) {
                if (l[k] == -1) {
                    this.dfsConnectivity(l, k);
                    this.searchCounter++
                }
            }
            var o = [];
            for (var n = 0; n < this.searchCounter; ++n) {
                o[n] = new e()
            }
            for (var n = 0; n < l.length; ++n) {
                var p = o[l[n]];
                p.addVertexAndOutEdges(this.vertices[n])
            }
            return o
        };
        e.prototype.dfsConnectivity = function(l, k) {
            l[k] = this.searchCounter;
            var n = this.vertices[k];
            g.forEach(n.edges, function(q) {
                var p = q.getOtherEnd(n);
                var o = p.index;
                if (l[o] == -1) {
                    this.dfsConnectivity(l, o)
                }
            }, this)
        };
        e.prototype.getBiconnectedComponents = function() {
            var k = [];
            this.setItemIndices();
            this.edges.forEach(function(v) {
                delete v.processed
            });
            var w = 0;
            var r = [];
            var s = [];
            var l = [];
            for (var D = 0; D < this.vertices.length; D++) {
                var t = this.vertices[D];
                if (r[t.index] !== undefined) {
                    continue
                }
                if (t.edges.length == 0) {
                    var B = new e();
                    B.addVertexAndOutEdges(t);
                    k.push(B.clone(true));
                    continue
                }
                var p = [];
                var o = [];
                r[t.index] = w++;
                l[t.index] = r[t.index];
                p.push(t);
                o.push(t.edges.slice(0));
                while (true) {
                    while (o[o.length - 1].length > 0) {
                        var u = p[p.length - 1];
                        var n = o[o.length - 1].shift();
                        var A = n.getOtherEnd(u);
                        if (n.processed) {
                            continue
                        }
                        s.push(n);
                        n.processed = true;
                        if (r[A.index] === undefined) {
                            r[A.index] = w++;
                            p.push(A);
                            o.push(A.edges.slice(0));
                            l[A.index] = r[u.index]
                        } else {
                            if (r[A.index] < l[u.index]) {
                                l[u.index] = r[A.index]
                            }
                        }
                    }
                    if (p.length > 1) {
                        var z = p[p.length - 1];
                        var q = p[p.length - 2];
                        if (l[z.index] == r[q.index]) {
                            var B = new e();
                            var C = s[s.length - 1];
                            while (r[C.origin.index] >= r[q.index] && r[C.destination.index] >= r[q.index]) {
                                s.pop();
                                if (!B.vertices.contains(C.origin)) {
                                    B.addVertexAndOutEdges(C.origin)
                                }
                                if (!B.vertices.contains(C.destination)) {
                                    B.addVertexAndOutEdges(C.destination)
                                }
                                if (s.length == 0) {
                                    break
                                }
                                C = s[s.length - 1]
                            }
                            k.push(B.clone(true))
                        } else {
                            if (l[q.index] > l[z.index]) {
                                l[q.index] = l[z.index]
                            }
                        }
                        p.pop();
                        o.pop()
                    } else {
                        break
                    }
                }
            }
            return k
        };
        e.prototype.get3EdgeConnectedComponents = function() {
            return this.test3EdgeConnectivity(false)
        };
        e.prototype.getCutPairs = function() {
            return this.test3EdgeConnectivity(true)
        };
        e.prototype.test3EdgeConnectivity = function(s) {
            if (this.vertices.length < 2) {
                return s ? new g() : [this]
            }
            if (this.vertices[0].index === undefined) {
                this.setItemIndices()
            }
            this.edges.forEach(function(E) {
                delete E.cutEdge;
                delete E.treeEdge
            });
            var o = new g();
            var n = 0;
            var C = [];
            var r = [];
            var u = [];
            var A = [];
            var p = [];
            var q = [];
            var w = [];
            var B = [];
            var D = [];
            var v = new d();

            function l(F, E) {
                var J = F.index;
                C[J] = n++;
                D[J] = F;
                r[J] = 1;
                u[J] = C[J];
                A[J] = F;
                p[J] = C[J];
                q[J] = F;
                if (B[J] === undefined) {
                    B[J] = []
                }
                F.edges.forEach(function(O) {
                    if (O == E) {
                        return
                    }
                    var L = O.getOtherEnd(F);
                    var K = L.index;
                    if (C[K] === undefined) {
                        O.treeEdge = true;
                        O.child = L;
                        l(L, O);
                        var M = B[K];
                        var N = M.length > 0 ? M[M.length - 1] : null;
                        if (N != null && L == N.q) {
                            M.pop();
                            o.push([O, N.edge]);
                            O.cutEdge = true;
                            N.edge.cutEdge = true;
                            if (s) {
                                if (!v.contains(N.edge)) {
                                    v.set(N.edge, new g())
                                }
                                v.get(N.edge).push(O)
                            }
                            if (F != N.p) {
                                M.push({
                                    edge: N.edge,
                                    p: N.p,
                                    q: F
                                })
                            }
                            if (N.edge.treeEdge) {
                                var P = N.edge.child.index;
                                D[P] = F
                            }
                        }
                        r[J] = r[J] + r[K];
                        if (u[K] < u[J]) {
                            p[J] = u[J];
                            u[J] = u[K];
                            q[J] = A[J];
                            A[J] = A[K];
                            B[J] = B[K].slice(0);
                            w[J] = O
                        } else {
                            if (u[K] < p[J]) {
                                p[J] = u[K];
                                q[J] = A[K];
                                B[K] = []
                            }
                        }
                    } else {
                        if (C[J] > C[K]) {
                            if (C[K] <= u[J]) {
                                p[J] = u[J];
                                u[J] = C[K];
                                q[J] = A[J];
                                A[J] = L;
                                B[J] = [];
                                w[J] = O
                            } else {
                                if (C[K] < p[J]) {
                                    p[J] = C[K];
                                    q[J] = L
                                }
                            }
                        }
                    }
                });
                var G = B[J];
                var I = G.length > 0 ? G[G.length - 1] : null;
                if (I == null) {
                    if (p[J] > u[J]) {
                        G.push({
                            edge: w[J],
                            p: A[J],
                            q: q[J]
                        })
                    }
                } else {
                    if (p[J] > C[I.q.index]) {
                        G.push({
                            edge: w[J],
                            p: I.q,
                            q: q[J]
                        })
                    } else {
                        while (G.length > 0 && p[J] <= C[G[G.length - 1].p.index]) {
                            G.pop()
                        }
                        if (G.length > 0 && p[J] < C[G[G.length - 1].q.index]) {
                            var H = G.pop();
                            G.push({
                                edge: H.edge,
                                p: H.p,
                                q: q[J]
                            })
                        }
                    }
                }
                F.edges.forEach(function(O) {
                    var K = O.getOtherEnd(F);
                    var M = K.index;
                    if (O.treeEdge || C[J] > C[M]) {
                        return
                    }
                    var N = G.length > 0 ? G[G.length - 1] : null;
                    var P = N == null ? null : N.edge.child;
                    var L = P ? P.index : 0;
                    while (N != null && N.edge.treeEdge && C[L] <= C[M] && C[M] <= C[L] + r[L] - 1) {
                        G.pop();
                        N = G.length > 0 ? G[G.length - 1] : null;
                        P = N == null ? null : N.edge.child;
                        L = P ? P.index : 0
                    }
                })
            }
            l(this.vertices[0], null);
            if (s) {
                v.forEach(function(H, E) {
                    for (var G = 0; G < E.length; G++) {
                        for (var F = G + 1; F < E.length; F++) {
                            if (!o.any(function(I) {
                                    return I[0] == E[G] && I[1] == E[F]
                                })) {
                                o.push([E[G], E[F]])
                            }
                        }
                    }
                });
                return o
            }
            var t = new g();
            this.edges.forEach(function(E) {
                if (E.cutEdge) {
                    t.push(E)
                }
            });
            t.forEach(function(E) {
                this.removeEdge(E)
            }, this);
            var z = [];
            this.vertices.forEach(function(E) {
                if (D[E.index] != E) {
                    var F = this.createEdge(E, D[E.index]);
                    z.push(F)
                }
            }, this);
            var k = this.getConnectedComponents();
            z.forEach(function(E) {
                this.removeEdge(E)
            }, this);
            t.forEach(function(E) {
                this.addEdge(E)
            }, this);
            return k
        };
        e.prototype.findBlockSeparationPairs = function() {
            var o = this.vertices;
            if (o.length < 4) {
                return []
            }

            function n(w, t) {
                var q = [];
                var r = [];
                var u = 1;
                o.forEach(function(z) {
                    if (z != w && z != t) {
                        q.push(z);
                        r[z.index] = true;
                        return $break
                    }
                });
                while (q.length > 0) {
                    var s = q.shift();
                    s.getNeighbors().forEach(function(v) {
                        if (r[v.index] || w == v || t == v) {
                            return
                        }
                        q.push(v);
                        r[v.index] = true;
                        u++
                    })
                }
                return u == o.length - 2
            }
            this.setItemIndices();
            var p = [];
            for (var l = 0; l < o.length - 1; l++) {
                for (var k = l + 1; k < o.length; k++) {
                    if (!n(o[l], o[k])) {
                        p.push([o[l], o[k]])
                    }
                }
            }
            return p
        };
        e.prototype.findBlockSeparationPairsB = function() {
            var G = 0;
            var B = [];
            var u = [];
            var J = [];
            var I = [];
            var z = [];
            var n = [];
            var r = [];
            var D = [];
            var q = new g();
            var E = new g();
            var t = this;
            var H = t.vertices.length;
            this.edges.forEach(function(K) {
                delete K.spTreeEdge
            });

            function F(N, Q) {
                var S = N.index;
                n[S] = [];
                B[S] = G++;
                u[B[S]] = N;
                z[S] = Q;
                J[S] = I[S] = B[S];
                r[S] = 1;
                N.edges.forEach(function(V) {
                    var P = V.getOtherEnd(N);
                    var U = P.index;
                    if (B[U] === undefined) {
                        V.spTreeEdge = true;
                        n[S].push(P);
                        F(P, N);
                        if (J[U] < J[S]) {
                            I[S] = Math.min(J[S], I[U]);
                            J[S] = J[U]
                        } else {
                            if (J[U] == J[S]) {
                                I[S] = Math.min(I[S], I[U])
                            } else {
                                I[S] = Math.min(I[S], J[U])
                            }
                        }
                        r[S] += r[U]
                    } else {
                        if (B[U] < B[S] && (U != Q.index || D[S])) {
                            if (B[U] < J[S]) {
                                I[S] = J[S];
                                J[S] = B[U]
                            } else {
                                if (B[U] > J[S]) {
                                    I[S] = Math.min(I[S], B[U])
                                }
                            }
                        }
                    }
                    if (P == Q) {
                        D[S] = true
                    }
                });
                if (Q) {
                    var L = u[J[S]];
                    var O = r[S];
                    if (L != Q && I[S] >= B[Q.index] && O < H - 2) {
                        q.push([L, Q])
                    } else {
                        if (B[L.index] > 0 && o(L, Q, N)) {
                            q.push([L, Q])
                        }
                    }
                }
                var T = false;
                k(N).forEach(function(P) {
                    if (J[S] == J[P.index]) {
                        T = true;
                        return $break
                    }
                });
                if (r[S] > 1 && !T) {
                    var R = t.createVertex();
                    R.index = t.vertices.length - 1;
                    g.forEach(N.edges.slice(0), function(U) {
                        if (!U.spTreeEdge) {
                            var P = U.getOtherEnd(N);
                            if (B[S] > B[P.index]) {
                                U.changeVertex(N, R)
                            }
                        }
                    });
                    var M = t.createEdge(N, R);
                    M.index = t.edges.length - 1;
                    M.spTreeEdge = true;
                    B[R.index] = B[S];
                    J[R.index] = J[S];
                    r[R.index] = 1;
                    z[R.index] = N;
                    A(R, N);
                    E.push(R)
                }
                var K = 0;
                N.edges.forEach(function(P) {
                    if (!P.spTreeEdge) {
                        K++
                    }
                });
                if (K > 1) {
                    A(N, N);
                    E.push(N)
                }
            }

            function C(K, M) {
                var L = new g();
                while (z[M.index] != K) {
                    L.push(z[M.index]);
                    M = z[M.index]
                }
                return L
            }

            function o(L, O, M) {
                var N = C(L, O);
                var K = true;
                N.forEach(function(P) {
                    P.edges.forEach(function(R) {
                        var Q = R.getOtherEnd(P);
                        if (Q == L || Q == O) {
                            return
                        }
                        if (B[Q.index] === undefined) {
                            K = false
                        } else {
                            if (B[Q.index] < B[L.index]) {
                                K = false
                            } else {
                                if (B[Q.index] > B[O.index] && B[Q.index] < B[M.index]) {
                                    K = false
                                } else {
                                    if (J[Q.index] < B[L.index]) {
                                        K = false
                                    }
                                }
                            }
                        }
                    });
                    if (!K) {
                        return $break
                    }
                });
                return K
            }

            function k(K) {
                var L = K.index;
                var M = new g();
                K.edges.forEach(function(O) {
                    if (O.spTreeEdge) {
                        var N = O.getOtherEnd(K);
                        if (B[L] < B[N.index]) {
                            M.push(N)
                        }
                    }
                });
                return M
            }

            function A(N, U) {
                var Y = N.index;
                var K = new g();
                var R = new g();
                N.edges.forEach(function(ab) {
                    if (ab.spTreeEdge) {
                        return
                    }
                    var V = ab.getOtherEnd(N);
                    if (B[Y] > B[V.index]) {
                        if (!K.contains(V)) {
                            K.push(V)
                        }
                    } else {
                        if (!R.contains(V)) {
                            R.push(V)
                        }
                    }
                });
                K.sort(v);
                R.sort(v);
                var aa = new g();
                K.forEach(function(ab) {
                    var V = t.createVertex();
                    V.replacementFor = U;
                    V.index = t.vertices.length - 1;
                    r[V.index] = r[Y];
                    aa.push(V)
                });
                var Q = new g();
                R.forEach(function(ab) {
                    var V = t.createVertex();
                    V.replacementFor = U;
                    V.index = t.vertices.length - 1;
                    r[V.index] = r[Y];
                    Q.push(V)
                });
                var M = [];
                aa.forReverse(function(V) {
                    M.push(V)
                });
                Q.forReverse(function(V) {
                    M.push(V)
                });
                for (var P = 0; P < M.length - 1; P++) {
                    var T = t.createEdge(M[P], M[P + 1]);
                    T.index = t.edges.length - 1;
                    T.replacementFor = U;
                    T.spTreeEdge = true
                }
                var O = null;
                var L = new g();
                N.edges.forEach(function(ab) {
                    if (ab.spTreeEdge) {
                        var V = ab.getOtherEnd(N);
                        if (B[Y] < B[V.index]) {
                            L.push(ab)
                        } else {
                            if (B[Y] >= B[V.index]) {
                                O = ab
                            }
                        }
                    }
                });
                if (O) {
                    O.changeVertex(N, M[0]);
                    O.replacementFor = U
                }
                L.forEach(function(V) {
                    V.changeVertex(N, M[M.length - 1]);
                    V.replacementFor = U
                });
                z[M[0].index] = z[Y];
                for (var P = 0; P < K.length; P++) {
                    var Z = K[P];
                    var X = N.getCommonEdges(Z);
                    X.forEach(function(V) {
                        if (!V.spTreeEdge) {
                            V.changeVertex(N, aa[P])
                        }
                    });
                    J[aa[P].index] = J[Y];
                    B[aa[P].index] = B[Y]
                }
                for (var P = 0; P < R.length; P++) {
                    var W = R[P];
                    var S = N.getCommonEdges(W);
                    S.forEach(function(V) {
                        if (!V.spTreeEdge) {
                            V.changeVertex(N, Q[P])
                        }
                    });
                    J[Q[P].index] = J[Y];
                    B[Q[P].index] = B[Y]
                }
            }

            function v(L, K) {
                if (B[L.index] < B[K.index]) {
                    return -1
                }
                if (B[L.index] > B[K.index]) {
                    return 1
                }
                return 0
            }

            function s(K, L) {
                while (z[L.index] != K) {
                    L = z[L.index]
                }
                return L
            }
            this.setItemIndices();
            F(this.vertices[0], null);
            E.forEach(function(K) {
                t.vertices.remove(K)
            });
            var l = new g();
            var w = this.getCutPairs();
            w.forEach(function(Q) {
                if (!(Q[0].spTreeEdge && Q[1].spTreeEdge)) {
                    return
                }
                var M = Q[0].getEnds();
                var N = Q[1].getEnds();
                M.sort(v);
                N.sort(v);
                if (!z[M[0].index] && r[N[1].index] === 1) {
                    return
                }
                if (!z[N[0].index] && r[M[1].index] === 1) {
                    return
                }
                var P = [];
                P.push(Q[0].origin);
                P.push(Q[0].destination);
                var O = [];
                O.push(Q[1].origin);
                O.push(Q[1].destination);
                for (var L = 0; L < P.length; L++) {
                    for (var K = 0; K < O.length; K++) {
                        if (P[L] != O[K]) {
                            l.push([P[L], O[K]])
                        }
                    }
                }
            });
            l.forEach(function(N) {
                var K, M;
                if (B[N[0].index] < B[N[1].index]) {
                    K = N[0];
                    M = N[1]
                } else {
                    M = N[0];
                    K = N[1]
                }
                if (K.replacementFor) {
                    K = K.replacementFor
                }
                if (M.replacementFor) {
                    M = M.replacementFor
                }
                if (K == M) {
                    return
                }
                var L = p(K, M, n[M.index][0], n[M.index]);
                if (L[1] != 0 && L[0] + L[2] != 0 && !q.any(function(O) {
                        return O[0] == K && O[1] == M
                    })) {
                    q.push([K, M])
                }
            });

            function p(K, R, M, N) {
                var O = N.length == 0 ? 0 : r[M.index];
                var L = s(K, R);
                var P = r[L.index] - O - 1;
                N.forEach(function(S) {
                    if (S == M) {
                        return
                    }
                    if (J[S.index] < B[K.index]) {
                        P -= r[S.index]
                    }
                });
                var Q = H - P - O - 2;
                return [Q, P, O]
            }
            return q
        };
        e.prototype.makeAcyclic = function() {
            if (this.vertices.length <= 1 || this.edges.length <= 1) {
                return []
            }
            if (this.vertices.length == 2) {
                var E = [];
                var q = this.edges[0];
                q.reverse();
                E.push(q);
                return E
            }
            var p = this.clone(true);
            var r = this.vertices.length;
            var z = new d();
            p.vertices.forEach(function(n) {
                b(n, r, z)
            });
            var t = [];
            var o = [];
            while (p.vertices.length > 0) {
                if (z.contains(2 - r)) {
                    var u = z.get(2 - r);
                    while (u.length > 0) {
                        var D = u.pop();
                        D.edges.forEach(function(v) {
                            var n = v.getOtherEnd(D);
                            var F = f(n, r);
                            z.get(F).remove(n);
                            n.removeEdge(v);
                            b(n, r, z)
                        });
                        p.vertices.remove(D);
                        o.unshift(D)
                    }
                }
                if (z.contains(r - 2)) {
                    var l = z.get(r - 2);
                    while (l.length > 0) {
                        var k = l.pop();
                        k.edges.forEach(function(v) {
                            var n = v.getOtherEnd(k);
                            var F = f(n, r);
                            z.get(F).remove(n);
                            n.removeEdge(v);
                            b(n, r, z)
                        });
                        p.vertices.remove(k);
                        t.push(k)
                    }
                }
                if (p.vertices.length > 0) {
                    for (var w = r - 3; w > 2 - r; w--) {
                        if (z.contains(w) && z.get(w).length > 0) {
                            var s = z.get(w);
                            var C = s.pop();
                            C.edges.forEach(function(v) {
                                var n = v.getOtherEnd(C);
                                var F = f(n, r);
                                z.get(F).remove(n);
                                n.removeEdge(v);
                                b(n, r, z)
                            });
                            p.vertices.remove(C);
                            t.push(C);
                            break
                        }
                    }
                }
            }
            g.addRange(t, o);
            var B = new d();
            for (var w = 0; w < this.vertices.length; w++) {
                B.set(p.vertexCopyToOrigMap.get(t[w]), w)
            }
            var A = new g();
            this.edges.forEach(function(n) {
                if (B.get(n.origin) > B.get(n.destination)) {
                    n.reverse();
                    A.push(n)
                }
            });
            return A
        };
        e.prototype.topologicalSort = function() {
            this.setItemIndices();
            this.searchCounter = 0;
            this.postCounter = 0;
            var l = this.vertices;
            var p = h(l.length, -1);
            var o = h(l.length, -1);
            this.searchOrder = h(l.length, -1);
            for (var k = 0; k < l.length; k++) {
                if (this.searchOrder[k] == -1) {
                    var n = this.topologicalSortDfs(p, o, k);
                    if (!n) {
                        return null
                    }
                }
            }
            o.reverse();
            return o
        };
        e.prototype.topologicalSortDfs = function(s, q, k) {
            var n = this.vertices[k];
            this.searchOrder[k] = this.searchCounter++;
            for (var o = 0; o < n.outEdges.length; o++) {
                var l = n.outEdges[o];
                var r = l.destination.index;
                if (this.searchOrder[r] == -1) {
                    var p = this.topologicalSortDfs(s, q, r);
                    if (!p) {
                        return false
                    }
                } else {
                    if (s[r] == -1) {
                        return false
                    }
                }
            }
            q[this.postCounter] = k;
            s[k] = this.postCounter++;
            return true
        };

        function f(k, l) {
            if (k.outEdges.length == 0) {
                return 2 - l
            } else {
                if (k.inEdges.length == 0) {
                    return l - 2
                } else {
                    return k.outEdges.length - k.inEdges.length
                }
            }
        }

        function b(k, p, o) {
            var l = f(k, p);
            if (!o.contains(l)) {
                o.set(l, new g())
            }
            o.get(l).push(k)
        }

        function h(l, n) {
            var o = [];
            for (var k = 0; k < l; ++k) {
                o[k] = n
            }
            return o
        }
        MindFusion.registerClass(e, "MindFusion.Graphs.Graph")
    })(MindFusion.Graphs);
    (function(b) {
        var a = MindFusion.Collections.ArrayList;
        var c = b.Path = function(d) {
            if (d) {
                this.nodes = a.clone(d.nodes);
                this.links = a.clone(d.links);
                this.items = a.clone(d.items)
            } else {
                this.nodes = new a();
                this.links = new a();
                this.items = new a()
            }
        };
        c.prototype = {
            contains: function(d) {
                if (mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramNode, d)) {
                    if (a.contains(this.nodes, d)) {
                        return true
                    }
                    return false
                } else {
                    if (a.contains(this.links, d)) {
                        return true
                    }
                    return false
                }
            },
            getWeight: function(f, e) {
                var d = 0;
                if (f) {
                    this.nodes.forEach(function(g) {
                        d += g.weight
                    })
                }
                if (e) {
                    this.links.forEach(function(g) {
                        d += g.weight
                    })
                }
                return d
            },
            add: function(e, d) {
                if (e && mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramLink, e.owner)) {
                    this.links.push(e);
                    this.items.push(e)
                }
                if (d && mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramNode, d.owner)) {
                    this.nodes.push(d);
                    this.items.push(d)
                }
                if (e && mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramNode, e.owner)) {
                    this.nodes.push(e);
                    this.items.push(e)
                }
            },
        };
        MindFusion.registerClass(c, "MindFusion.Graphs.Path")
    })(MindFusion.Graphs);
    (function(c) {
        var a = MindFusion.Collections.ArrayList;
        var e = MindFusion.Collections.Queue;
        var d = MindFusion.Collections.Dictionary;
        var b = c.PathFinder = function() {};
        MindFusion.Graphs.PathFinder.findAllPaths = function(f, h, g) {
            return b.findPaths(f, h, g, false, 0)
        };
        MindFusion.Graphs.PathFinder.findPaths = function(g, u, j, q, B) {
            var r = [];
            if (u == j && q) {
                var t = new c.Path();
                t.add(u);
                r.push(t);
                return r
            }
            var p = new e();
            var w = new c.Path();
            w.add(u);
            p.enqueue(w);
            var A = false;
            while (true) {
                var s = p.getSize();
                if (s == 0) {
                    break
                }
                if (A && q) {
                    break
                }
                for (var z = 0; z < s; z++) {
                    w = p.dequeue();
                    var n = w.nodes[w.nodes.length - 1];
                    var h = n.outEdges;
                    for (var v = 0; v < h.length; v++) {
                        var o = h[v];
                        var l = o.destination;
                        if (w.contains(o)) {
                            continue
                        }
                        if (l == j) {
                            var f = new c.Path(w);
                            f.add(o, l);
                            r.push(f);
                            if (B != 0 && r.length >= B) {
                                return r
                            }
                            A = true;
                            continue
                        }
                        if (!w.contains(l)) {
                            var f = new c.Path(w);
                            f.add(o, l);
                            p.enqueue(f)
                        }
                    }
                }
            }
            return r
        };
        MindFusion.Graphs.PathFinder.findShortestPath = function(p, l, n, h, o) {
            if (!h && !o) {
                var q = MindFusion.Graphs.PathFinder.findPaths(p, l, n, true);
                if (q.length > 0) {
                    return q[0]
                } else {
                    return null
                }
            }
            var q = MindFusion.Graphs.PathFinder.findPaths(p, l, n, false);
            if (q.length == 0) {
                return null
            }
            var k = Number.MAX_VALUE;
            var f = null;
            for (var g = 0; g < q.length; g++) {
                var j = q[g].getWeight(h, o);
                if (j < k) {
                    k = j;
                    f = q[g]
                }
            }
            return f
        };
        MindFusion.Graphs.PathFinder.findLongestPath = function(f, j, h) {
            var g = MindFusion.Graphs.PathFinder.findPaths(f, j, h, false);
            if (g.length > 0) {
                return g[g.length - 1]
            } else {
                return null
            }
        };
        MindFusion.Graphs.PathFinder.findCycle = function(h, f) {
            if (f) {
                var k = MindFusion.Graphs.PathFinder.findPaths(h, f, f, false);
                if (k.length > 0) {
                    var j = k[0];
                    a.removeAt(j.nodes, j.nodes.length - 1);
                    a.removeAt(j.items, j.items.length - 1);
                    return j
                }
                return null
            } else {
                for (var g = 0; g < this.graph.vertices.length; g++) {
                    var k = MindFusion.Graphs.PathFinder.findPaths(h, this.graph.vertices[g], this.graph.vertices[g], false);
                    if (k.length > 0) {
                        var j = k[0];
                        a.removeAt(j.nodes, j.nodes.length - 1);
                        a.removeAt(j.items, j.items.length - 1);
                        return j
                    }
                }
                return null
            }
        };
        b.enumAllCycles = function(g) {
            var f = [];
            var h = function(j) {
                f.push(j)
            };
            b.enumAllCyclesDirected(g, h);
            return f
        };
        b.enumAllCyclesDirected = function(h, f) {
            b.mark = new d();
            b.markedStack = new a();
            b.pointStack = new a();
            b.vertexIdx = new d();
            b.toDelete = new d();
            var g = 0;
            var k = h.vertices;
            k.forEach(function(l) {
                b.vertexIdx.set(l, g++)
            });
            var j = function(l) {
                while (b.markedStack.length != 0) {
                    b.mark.remove(b.markedStack.pop())
                }
                return f(l)
            };
            k.forEach(function(l) {
                MindFusion.Graphs.PathFinder.enumCircuitsTarjan(l, l, j)
            })
        };
        b.enumCircuitsTarjan = function(l, j, k, g) {
            var h = false;
            var g = function(n) {
                h = true;
                return k(n)
            };
            b.pointStack.push(j);
            b.mark.set(j, true);
            b.markedStack.push(j);
            var f = j.outEdges;
            f.forEach(function(n) {
                var o = n.destination;
                if (!b.deleted(j).contains(o)) {
                    var q = b.vertexIdx.get(o) - b.vertexIdx.get(l);
                    if (q < 0) {
                        b.deleted(j).set(o, true)
                    } else {
                        if (q == 0) {
                            h = true;
                            var z = new c.Path();
                            var t = b.pointStack.indexOf(l);
                            for (var u = t; u < b.pointStack.length; u++) {
                                z.nodes.push(b.pointStack[u])
                            }
                            for (var u = 0; u < z.nodes.length; u++) {
                                var w = z.nodes[u];
                                var v = z.nodes[(u + 1) % z.nodes.length];
                                var r = null;
                                var p = w.outEdges;
                                for (var s = 0; s < p.length; s++) {
                                    if (p[s].getOtherEnd(w) == v) {
                                        r = p[s];
                                        break
                                    }
                                }
                                z.links.push(r);
                                z.items.push(w);
                                z.items.push(r)
                            }
                            g(z);
                            return $break
                        } else {
                            if (!b.mark.contains(o)) {
                                b.enumCircuitsTarjan(l, o, k, g)
                            }
                        }
                    }
                }
            });
            if (h) {
                while (b.markedStack.length > 0) {
                    b.mark.remove(b.markedStack.pop())
                }
            }
            a.removeAt(b.pointStack, b.pointStack.length - 1)
        };
        b.deleted = function(g) {
            var f = b.toDelete.contains(g) ? b.toDelete.get(g) : null;
            if (f == null) {
                f = new d();
                b.toDelete.set(g, f)
            }
            return f
        };
        b.markedStack;
        b.pointStack;
        b.mark;
        b.vertexIdx;
        b.toDelete;
        MindFusion.registerClass(b, "MindFusion.Graphs.PathFinder")
    })(MindFusion.Graphs);
    (function(d) {
        var f = MindFusion.Collections.ArrayList;
        var e = MindFusion.Collections.Dictionary;
        var j = MindFusion.Collections.Set;
        var b = MindFusion.Graphs.AssistantPosition;
        var a = d.TreeLayout = function() {
            this.levelDistance = 10;
            this.nodeDistance = 10;
            this.keepRootPosition = false;
            this.direction = d.LayoutDirection.TopToBottom;
            this.linkType = d.TreeLayoutLinkType.Default;
            this.anchoring = d.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.enableAssistants = false;
            this.compactAssistants = false;
            this.multipleGraphsPlacement = d.MultipleGraphsPlacement.Horizontal
        };
        a.prototype.setsLinkPoints = true;
        a.prototype.setsLinkEndPoints = true;
        a.prototype.requiresConnectedGraph = true;
        a.prototype.requiresSimpleGraph = false;
        a.prototype.margins = 10;
        a.prototype.requiresCascadingLinks = function() {
            return this.linkType == d.TreeLayoutLinkType.Cascading
        };
        a.prototype.isStatic = function() {
            return this.keepRootPosition
        };
        a.prototype.arrange = function(V) {
            var J;
            V.vertices.forEach(function(s) {
                if (s.inEdges.length == 0) {
                    J = s;
                    return $break
                }
            });
            if (!J) {
                return $skipLayout
            }
            var F = V.tree(J, this.enableAssistants, this.compactAssistants);
            if (!F) {
                return $skipLayout
            }
            F.vertices.forEach(function(s) {
                s.assistantType = s.owner.getLayoutTraits().treeLayoutAssistant
            });
            var T = J.x + J.width / 2;
            var R = J.y + J.height / 2;
            h(F, J, function(s, aj) {
                s.x = s.width / 2;
                s.y = s.height / 2
            }, null);
            var ab = new f();
            for (var ah = 0; ah < F.treeLevels.length; ah++) {
                var P = F.treeLevels[ah];
                var z = 0;
                for (var ag = 0; ag < P.length; ag++) {
                    if (this.isHorizontal()) {
                        z = Math.max(z, P[ag].width)
                    } else {
                        z = Math.max(z, P[ag].height)
                    }
                }
                ab.push(z)
            }
            var Q = F.treeLevels[F.treeLevels.length - 1];
            var ac = 0;
            for (var ah = 0; ah < Q.length; ah++) {
                var O = Q[ah];
                if (this.isHorizontal()) {
                    O.y = ac + O.height / 2;
                    ac += O.height + this.nodeDistance
                } else {
                    O.x = ac + O.width / 2;
                    ac += O.width + this.nodeDistance
                }
            }
            var E = new e();
            var ad = new e();
            for (var ah = F.treeLevels.length - 1; ah >= 0; ah--) {
                var P = F.treeLevels[ah];
                for (var ag = 0; ag < P.length; ag++) {
                    var O = P[ag];
                    var D = g(F, O);
                    if (D.length > 0) {
                        if (this.hasAssistants(O) && this.enableAssistants) {
                            var B = undefined;
                            var L = undefined;
                            D.forEach(function(s) {
                                if (s.assistantPosition === b.Left) {
                                    B = s
                                } else {
                                    if (s.assistantPosition === b.Right) {
                                        L = s
                                    }
                                }
                            });
                            if (B && L) {
                                var ae = this.branchBounds(B);
                                var l = this.branchBounds(L);
                                if (this.isHorizontal()) {
                                    O.y += ae.bottom() + (l.top() - ae.bottom()) / 2 - O.height / 2
                                } else {
                                    O.x += ae.right() + (l.left() - ae.right()) / 2 - O.width / 2
                                }
                            } else {
                                if (B) {
                                    var o = this.branchBounds(B);
                                    if (this.isHorizontal()) {
                                        O.y = o.bottom() + this.nodeDistance / 2
                                    } else {
                                        O.x = o.right() + this.nodeDistance / 2
                                    }
                                } else {
                                    var o = this.branchBounds(L);
                                    if (this.isHorizontal()) {
                                        O.y = o.top() - this.nodeDistance / 2
                                    } else {
                                        O.x = o.left() - this.nodeDistance / 2
                                    }
                                }
                            }
                        } else {
                            var U = MindFusion.Drawing.Rect.fromVertex(D[0]);
                            for (var ai = 1; ai < D.length; ai++) {
                                U = U.union(MindFusion.Drawing.Rect.fromVertex(D[ai]))
                            }
                            if (this.isHorizontal()) {
                                O.y += (U.top() + U.bottom()) / 2 - O.height / 2
                            } else {
                                O.x += (U.left() + U.right()) / 2 - O.width / 2
                            }
                        }
                    }
                    if (O.assistantType && this.enableAssistants) {
                        var r = [];
                        if (O.parent) {
                            for (var ai = 0; ai < O.parent.outEdges.length; ai++) {
                                var q = O.parent.outEdges[ai].destination;
                                if (q.assistantType) {
                                    continue
                                }
                                r.push(q)
                            }
                        }
                        if (r.length > 0) {
                            var U = MindFusion.Drawing.Rect.fromVertex(r[0]);
                            for (var ai = 1; ai < r.length; ai++) {
                                U = U.union(MindFusion.Drawing.Rect.fromVertex(r[ai]))
                            }
                            var Y = this.branchBounds(O);
                            if (this.isHorizontal()) {
                                var W = 0;
                                if (O.assistantPosition === b.Left) {
                                    W = U.y + U.height / 2 - Y.bottom() - this.nodeDistance / 2
                                } else {
                                    W = U.y + U.height / 2 - Y.top() + this.nodeDistance / 2
                                }
                                this.offsetBranch(F, O, 0, W)
                            } else {
                                var W = 0;
                                if (O.assistantPosition === b.Left) {
                                    W = U.x + U.width / 2 - Y.right() - this.nodeDistance / 2
                                } else {
                                    W = U.x + U.width / 2 - Y.left() + this.nodeDistance / 2
                                }
                                this.offsetBranch(F, O, W, 0)
                            }
                        } else {
                            if (O.parent) {
                                var aa = undefined;
                                if (E.contains(O.parent)) {
                                    aa = E.get(O.parent)
                                }
                                var u = undefined;
                                if (ad.contains(O.parent)) {
                                    u = ad.get(O.parent)
                                }
                                if (aa || u) {
                                    var C = this.branchBounds(O);
                                    if (O.assistantPosition === b.Right) {
                                        if (u) {
                                            var A = this.branchBounds(u);
                                            if (this.isHorizontal()) {
                                                var W = A.top() - C.top();
                                                this.offsetBranch(F, O, 0, W)
                                            } else {
                                                var W = A.left() - C.left();
                                                this.offsetBranch(F, O, W, 0)
                                            }
                                        } else {
                                            if (aa) {
                                                var A = this.branchBounds(aa);
                                                if (this.isHorizontal()) {
                                                    var W = A.bottom() + this.nodeDistance - C.top();
                                                    this.offsetBranch(F, O, 0, W)
                                                } else {
                                                    var W = A.right() + this.nodeDistance - C.left();
                                                    this.offsetBranch(F, O, W, 0)
                                                }
                                            }
                                        }
                                    } else {
                                        if (aa) {
                                            var A = this.branchBounds(aa);
                                            if (this.isHorizontal()) {
                                                var W = A.bottom() - C.bottom();
                                                this.offsetBranch(F, O, 0, W)
                                            } else {
                                                var W = A.right() - C.right();
                                                this.offsetBranch(F, O, W, 0)
                                            }
                                        } else {
                                            if (u) {
                                                var A = this.branchBounds(u);
                                                if (this.isHorizontal()) {
                                                    var W = A.top() - this.nodeDistance - C.bottom();
                                                    this.offsetBranch(F, O, 0, W)
                                                } else {
                                                    var W = A.left() - this.nodeDistance - C.right();
                                                    this.offsetBranch(F, O, W, 0)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (O.assistantType && this.enableAssistants) {
                        if (O.assistantPosition === b.Left) {
                            E.set(O.parent, O)
                        } else {
                            if (O.assistantPosition === b.Right) {
                                ad.set(O.parent, O)
                            }
                        }
                    }
                }
                for (var ag = 0; ag < P.length - 1; ag++) {
                    for (var af = ag; af >= 0; af--) {
                        if (P[af].assistantType || P[ag + 1].assistantType) {
                            continue
                        }
                        var p = this.branchDistance(F, P[af], P[ag + 1]);
                        var N = af != ag;
                        if (N ? p < this.nodeDistance : true) {
                            if (this.isHorizontal()) {
                                this.offsetBranch(F, P[ag + 1], 0, this.nodeDistance - p)
                            } else {
                                this.offsetBranch(F, P[ag + 1], this.nodeDistance - p, 0)
                            }
                        }
                    }
                }
            }
            var G;
            var t;
            var S;
            if (this.isStraight()) {
                G = 0;
                t = F.treeLevels.length;
                S = +1
            } else {
                G = F.treeLevels.length - 1;
                t = -1;
                S = -1
            }
            var M = 0;
            for (var ah = G; this.isStraight() ? ah < t : ah > t; ah += S) {
                var K = 0;
                var P = F.treeLevels[ah];
                for (var ag = 0; ag < P.length; ag++) {
                    var O = P[ag];
                    var w = 0;
                    if (this.isHorizontal()) {
                        w = O.width;
                        var n = 0;
                        if (this.direction == d.LayoutDirection.RightToLeft) {
                            n = ab[ah] - w
                        }
                        O.x = M + n + this.margins + O.width / 2;
                        O.y = O.y + this.margins
                    } else {
                        w = O.height;
                        var I = 0;
                        if (this.direction == d.LayoutDirection.BottomToTop) {
                            I = ab[ah] - w
                        }
                        O.x = O.x + this.margins;
                        O.y = M + I + this.margins + O.height / 2
                    }
                    K = Math.max(K, w)
                }
                M += K + this.levelDistance
            }
            if (this.keepRootPosition) {
                var Z = J.x;
                var X = J.y;
                var n = T - Z;
                var I = R - X;
                this.offsetBranch(F, J, n, I)
            }
            if (this.linkType != d.TreeLayoutLinkType.Default) {
                switch (this.linkType) {
                    case d.TreeLayoutLinkType.Straight:
                        switch (this.direction) {
                            case d.LayoutDirection.TopToBottom:
                                F.edges.forEach(function(s) {
                                    s.points = [{
                                        x: s.origin.x,
                                        y: s.origin.y + s.origin.height / 2
                                    }, {
                                        x: s.destination.x,
                                        y: s.destination.y - s.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.BottomToTop:
                                F.edges.forEach(function(s) {
                                    s.points = [{
                                        x: s.origin.x,
                                        y: s.origin.y - s.origin.height / 2
                                    }, {
                                        x: s.destination.x,
                                        y: s.destination.y + s.destination.height / 2
                                    }]
                                });
                                break;
                            case d.LayoutDirection.LeftToRight:
                                F.edges.forEach(function(s) {
                                    s.points = [{
                                        x: s.origin.x + s.origin.width / 2,
                                        y: s.origin.y
                                    }, {
                                        x: s.destination.x - s.destination.width / 2,
                                        y: s.destination.y
                                    }]
                                });
                                break;
                            case d.LayoutDirection.RightToLeft:
                                F.edges.forEach(function(s) {
                                    s.points = [{
                                        x: s.origin.x - s.origin.width / 2,
                                        y: s.origin.y
                                    }, {
                                        x: s.destination.x + s.destination.width / 2,
                                        y: s.destination.y
                                    }]
                                });
                                break
                        }
                        break;
                    case d.TreeLayoutLinkType.Cascading:
                        var H = this.enableAssistants;
                        var v = this.levelDistance / 2;
                        switch (this.direction) {
                            case d.LayoutDirection.TopToBottom:
                                F.edges.forEach(function(s) {
                                    if (H && s.destination.assistantType) {
                                        s.points = [{
                                            x: s.origin.x,
                                            y: s.origin.y + s.origin.height / 2
                                        }, {
                                            x: s.origin.x,
                                            y: s.destination.y
                                        }, s.destination.assistantPosition === b.Left ? {
                                            x: s.destination.x + s.destination.width / 2,
                                            y: s.destination.y
                                        } : {
                                            x: s.destination.x - s.destination.width / 2,
                                            y: s.destination.y
                                        }]
                                    } else {
                                        s.points = [{
                                            x: s.origin.x,
                                            y: s.origin.y + s.origin.height / 2
                                        }, {
                                            x: s.origin.x,
                                            y: s.destination.y - s.destination.height / 2 - v
                                        }, {
                                            x: s.destination.x,
                                            y: s.destination.y - s.destination.height / 2 - v
                                        }, {
                                            x: s.destination.x,
                                            y: s.destination.y - s.destination.height / 2
                                        }]
                                    }
                                });
                                break;
                            case d.LayoutDirection.BottomToTop:
                                F.edges.forEach(function(s) {
                                    if (H && s.destination.assistantType) {
                                        s.points = [{
                                            x: s.origin.x,
                                            y: s.origin.y - s.origin.height / 2
                                        }, {
                                            x: s.origin.x,
                                            y: s.destination.y
                                        }, s.destination.assistantPosition === b.Left ? {
                                            x: s.destination.x + s.destination.width / 2,
                                            y: s.destination.y
                                        } : {
                                            x: s.destination.x - s.destination.width / 2,
                                            y: s.destination.y
                                        }]
                                    } else {
                                        s.points = [{
                                            x: s.origin.x,
                                            y: s.origin.y - s.origin.height / 2
                                        }, {
                                            x: s.origin.x,
                                            y: s.destination.y + s.destination.height / 2 + v
                                        }, {
                                            x: s.destination.x,
                                            y: s.destination.y + s.destination.height / 2 + v
                                        }, {
                                            x: s.destination.x,
                                            y: s.destination.y + s.destination.height / 2
                                        }]
                                    }
                                });
                                break;
                            case d.LayoutDirection.LeftToRight:
                                F.edges.forEach(function(s) {
                                    if (H && s.destination.assistantType) {
                                        s.points = [{
                                            x: s.origin.x + s.origin.width / 2,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x,
                                            y: s.origin.y
                                        }, s.destination.assistantPosition === b.Left ? {
                                            x: s.destination.x,
                                            y: s.destination.y + s.destination.height / 2
                                        } : {
                                            x: s.destination.x,
                                            y: s.destination.y - s.destination.height / 2
                                        }]
                                    } else {
                                        s.points = [{
                                            x: s.origin.x + s.origin.width / 2,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x - s.destination.width / 2 - v,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x - s.destination.width / 2 - v,
                                            y: s.destination.y
                                        }, {
                                            x: s.destination.x - s.destination.width / 2,
                                            y: s.destination.y
                                        }]
                                    }
                                });
                                break;
                            case d.LayoutDirection.RightToLeft:
                                F.edges.forEach(function(s) {
                                    if (H && s.destination.assistantType) {
                                        s.points = [{
                                            x: s.origin.x - s.origin.width / 2,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x,
                                            y: s.origin.y
                                        }, s.destination.assistantPosition === b.Left ? {
                                            x: s.destination.x,
                                            y: s.destination.y + s.destination.height / 2
                                        } : {
                                            x: s.destination.x,
                                            y: s.destination.y - s.destination.height / 2
                                        }]
                                    } else {
                                        s.points = [{
                                            x: s.origin.x - s.origin.width / 2,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x + s.destination.width / 2 + v,
                                            y: s.origin.y
                                        }, {
                                            x: s.destination.x + s.destination.width / 2 + v,
                                            y: s.destination.y
                                        }, {
                                            x: s.destination.x + s.destination.width / 2,
                                            y: s.destination.y
                                        }]
                                    }
                                });
                                break
                        }
                }
            }
        };
        a.prototype.hasAssistants = function(n) {
            for (var l = 0; l < n.outEdges.length; l++) {
                if (n.outEdges[l].destination.assistantType) {
                    return true
                }
            }
            return false
        };
        a.prototype.branchBounds = function(o) {
            var q = MindFusion.Drawing.Rect;
            var p = [];
            p.push(o);
            var n = new f();
            var l;
            while (p.length > 0) {
                var s = p[0];
                p.splice(0, 1);
                n.push(s);
                if (!l) {
                    l = q.fromVertex(s)
                } else {
                    l = l.union(q.fromVertex(s))
                }
                for (var r = 0; r < s.outEdges.length; r++) {
                    var t = s.outEdges[r].destination;
                    if (!n.contains(t)) {
                        p.push(t)
                    }
                }
            }
            return l
        };
        a.prototype.branchDistance = function(D, C, A) {
            var v = this.left(A) - this.right(C);
            var t = new e();
            var s = new e();
            k(D, C, t);
            k(D, A, s);
            var B = t.keys();
            for (var u = 0; u < B.length; u++) {
                var o = B[u];
                if (!s.contains(o)) {
                    continue
                }
                var z = t.get(o);
                var w = s.get(o);
                var n = 0;
                for (var q = 0; q < z.length; q++) {
                    n = Math.max(n, this.right(z[q]))
                }
                var p = Number.MAX_VALUE;
                for (var q = 0; q < w.length; q++) {
                    p = Math.min(p, this.left(w[q]))
                }
                if ((p - n < v) && (z.length > 0 && w.length > 0)) {
                    v = p - n
                }
            }
            return v
        };
        a.prototype.right = function(l) {
            if (this.isHorizontal()) {
                return l.y + l.height / 2
            } else {
                return l.x + l.width / 2
            }
        };
        a.prototype.left = function(l) {
            if (this.isHorizontal()) {
                return l.y - l.height / 2
            } else {
                return l.x - l.width / 2
            }
        };

        function k(l, n, o) {
            var q = n.level;
            var p = null;
            if (o.contains(q)) {
                p = o.get(q)
            } else {
                p = new f();
                o.set(q, p)
            }
            p.push(n);
            g(l, n).forEach(function(r) {
                k(l, r, o)
            })
        }
        a.prototype.offsetBranch = function(l, p, n, q) {
            if (!n && !q) {
                return
            }
            var o = function(r, s) {
                r.x += s[0];
                r.y += s[1]
            };
            h(l, p, o, [n, q])
        };
        a.prototype.isHorizontal = function() {
            return this.direction == d.LayoutDirection.LeftToRight || this.direction == d.LayoutDirection.RightToLeft
        };
        a.prototype.isStraight = function() {
            return this.direction == d.LayoutDirection.LeftToRight || this.direction == d.LayoutDirection.TopToBottom
        };

        function c(l, n) {
            return (l - l % n) / n
        }

        function g(l, o) {
            var n = new f();
            o.outEdges.forEach(function(p) {
                if (l.edges.contains(p)) {
                    n.push(p.destination)
                }
            });
            return n
        }

        function h(l, p, o, q) {
            o.call(this, p, q);
            var n = g(l, p);
            n.forEach(function(r) {
                h(l, r, o, q)
            })
        }
        a.With = function() {
            if (!d.TreeLayoutBuilder) {
                d.TreeLayoutBuilder = new MindFusion.Builder(a.prototype)
            } else {
                TreeMapLayoutBuilder.setInstance(null)
            }
            return d.TreeLayoutBuilder
        };
        a.prototype.init = function() {
            if (!d.TreeLayoutBuilder) {
                d.TreeLayoutBuilder = new MindFusion.Builder(a.prototype, null, this)
            } else {
                d.TreeLayoutBuilder.setInstance(this)
            }
            return d.TreeLayoutBuilder
        };
        a.prototype.getType = function() {
            return this.constructor.__typeName
        };
        d.TreeLayoutBuilder = null;
        a.prototype.getLevelDistance = function() {
            return this.levelDistance
        };
        a.prototype.setLevelDistance = function(l) {
            this.levelDistance = l
        };
        a.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        a.prototype.setNodeDistance = function(l) {
            this.nodeDistance = l
        };
        a.prototype.getKeepRootPosition = function() {
            return this.keepRootPosition
        };
        a.prototype.setKeepRootPosition = function(l) {
            this.keepRootPosition = l
        };
        a.prototype.getDirection = function() {
            return this.direction
        };
        a.prototype.setDirection = function(l) {
            this.direction = l
        };
        a.prototype.getLinkType = function() {
            return this.linkType
        };
        a.prototype.setLinkType = function(l) {
            this.linkType = l
        };
        a.prototype.getAnchoring = function() {
            return this.anchoring
        };
        a.prototype.setAnchoring = function(l) {
            this.anchoring = l
        };
        a.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        a.prototype.setKeepGroupLayout = function(l) {
            this.keepGroupLayout = l
        };
        MindFusion.registerClass(a, "MindFusion.Graphs.TreeLayout")
    })(MindFusion.Graphs);
    (function(c) {
        var b = MindFusion.Collections.ArrayList;
        var e = MindFusion.Collections.Dictionary;
        var d = MindFusion.Collections.Set;
        var a = c.TreeMapLayout = function() {
            this.orientation = c.Orientation.Vertical;
            this.squarify = true;
            this.padding = 1;
            this.layoutArea = null;
            this.containerPadding = 0;
            this.minNodeSize = 1
        };
        a.prototype.setsLinkPoints = false;
        a.prototype.setsLinkEndPoints = false;
        a.prototype.requiresConnectedGraph = false;
        a.prototype.requiresSimpleGraph = false;
        a.prototype.requiresHierarchyInfo = true;
        a.prototype.margins = 10;
        a.prototype.requiresCascadingLinks = function() {
            return false
        };
        a.prototype.isStatic = function() {
            return false
        };
        a.prototype.arrange = function(j) {
            if (this.layoutArea == null) {
                this.layoutArea = j.layoutArea
            }
            var h = [];
            this.weights = new e();
            var g = 0;
            j.vertices.forEach(function(k) {
                if (k.master == null) {
                    g += this.calcWeights(k);
                    h.push(k)
                }
            }, this);
            if (this.squarify) {
                this.arrangeSquare(h, this.layoutArea, [], g)
            } else {
                this.arrangeSiblings(h, this.layoutArea, this.orientation == c.Orientation.Horizontal, g)
            }
        };
        a.prototype.arrangeSquare = function(h, l, n, g) {
            var j = h.slice();
            var k = this.weights;
            j.sort(function(p, o) {
                return k.get(o) - k.get(p)
            });
            this.doSquarify(j, l, n, g)
        };
        a.prototype.doSquarify = function(l, n, t, k) {
            var h = n.width > n.height;
            var g = Math.min(n.width, n.height);
            var q = 0,
                p = 0;
            var s = t.slice();
            if (l.length > 0) {
                var o = l[0];
                s.push(o);
                var j = n.width * n.height;
                q = this.evalRatio(t, g, j * this.weight(t) / k);
                p = this.evalRatio(s, g, j * this.weight(s) / k)
            }
            if (l.length > 0 && (q == 0 || q >= p)) {
                l.shift();
                this.doSquarify(l, n, s, k)
            } else {
                var r = this.layoutRow(n, t, !h, k);
                k -= this.weight(t);
                if (h) {
                    n.x += r;
                    n.width -= r
                } else {
                    n.y += r;
                    n.height -= r
                }
                if (l.length > 0) {
                    this.doSquarify(l, n, [], k)
                }
            }
        };
        a.prototype.weight = function(h) {
            var g = 0;
            h.forEach(function(j) {
                g += this.weights.get(j)
            }, this);
            return g
        };
        a.prototype.subtractPadding = function(g) {
            var h = -this.padding / 2;
            g = g.inflate(h);
            var j = this.minNodeSize;
            if (g.width < j) {
                g.width = j
            }
            if (g.height < j) {
                g.height = j
            }
        };
        a.prototype.layoutRow = function(l, s, j, k) {
            var h = MindFusion.Drawing.Rect;
            var n = l.width * l.height;
            var g = j ? l.width : l.height;
            var q = 0;
            s.forEach(function(t) {
                q += this.weights.get(t)
            }, this);
            var r = n * q / k;
            var o = r / g;
            var p = j ? l.x : l.y;
            s.forEach(function(w) {
                var z = this.weights.get(w);
                var v = j ? new h(p, l.y, r * z / q / o, o) : new h(l.x, p, o, r * z / q / o);
                this.subtractPadding(v);
                f(w, v);
                p += r * z / q / o;
                if (w.subordinates != null) {
                    var u = w.subordinates.slice();
                    var t = this.layOutArea(w);
                    this.subtractPadding(t);
                    this.arrangeSquare(u, t, [], z)
                }
            }, this);
            return o
        };
        a.prototype.arrangeSiblings = function(j, n, h, g) {
            var k = MindFusion.Drawing.Rect;
            var o = h ? n.x : n.y;
            var l = h ? n.width : n.height;
            j.forEach(function(t) {
                var p = l * this.weights.get(t) / g;
                var s = h ? new k(o, n.y, p, n.height) : new k(n.x, o, n.width, p);
                this.subtractPadding(s);
                f(t, s);
                if (t.subordinates != null) {
                    var r = t.subordinates.slice();
                    var q = this.layOutArea(t);
                    this.subtractPadding(q);
                    this.arrangeSiblings(r, q, !h, this.weights.get(t))
                }
                o += p
            }, this)
        };
        a.prototype.evalRatio = function(l, k, j) {
            var g = 0;
            var h = 0;
            l.forEach(function(n) {
                var o = this.weights.get(n);
                h += o
            }, this);
            l.forEach(function(o) {
                var p = this.weights.get(o);
                var n = j * p / h;
                g = Math.max(g, Math.max(k * k * n / (j * j), j * j / (k * k * n)))
            }, this);
            return g
        };
        a.prototype.calcWeights = function(g) {
            if (this.weights.contains(g)) {
                return this.weights.get(g)
            }
            if (g.subordinates == null) {
                this.weights.set(g, g.weight);
                return g.weight
            }
            var h = 0;
            g.subordinates.forEach(function(j) {
                h += this.calcWeights(j)
            }, this);
            this.weights.set(g, h);
            return h
        };
        a.prototype.layOutArea = function(j) {
            var h = MindFusion.Drawing.Rect;
            var k = h.fromVertex(j);
            if (j.headerSize) {
                var g = j.headerSize;
                if (g < k.height) {
                    k.y += g;
                    k.height -= g
                } else {
                    k.y += k.height / 2;
                    k.height /= 2
                }
            }
            if (j.subordinates != null) {
                return k.inflate(-this.containerPadding)
            }
            return k
        };

        function f(h, g) {
            var j = g.center();
            h.x = j.x;
            h.y = j.y;
            h.width = g.width;
            h.height = g.height
        }
        a.With = function() {
            if (!c.TreeMapLayoutBuilder) {
                c.TreeMapLayoutBuilder = new MindFusion.Builder(a.prototype)
            } else {
                c.TreeMapLayoutBuilder.setInstance(null)
            }
            return c.TreeMapLayoutBuilder
        };
        a.prototype.init = function() {
            if (!c.TreeMapLayoutBuilder) {
                c.TreeMapLayoutBuilder = new MindFusion.Builder(a.prototype, null, this)
            } else {
                c.TreeMapLayoutBuilder.setInstance(this)
            }
            return c.TreeMapLayoutBuilder
        };
        a.prototype.getType = function() {
            return this.constructor.__typeName
        };
        c.TreeMapLayoutBuilder = null;
        a.prototype.getOrientation = function() {
            return this.orientation
        };
        a.prototype.setOrientation = function(g) {
            this.orientation = g
        };
        a.prototype.getSquarify = function() {
            return this.squarify
        };
        a.prototype.setSquarify = function(g) {
            this.squarify = g
        };
        a.prototype.getPadding = function() {
            return this.padding
        };
        a.prototype.setPadding = function(g) {
            this.padding = g
        };
        a.prototype.getLayoutArea = function() {
            return this.layoutArea
        };
        a.prototype.setLayoutArea = function(g) {
            this.layoutArea = g
        };
        a.prototype.getContainerPadding = function() {
            return this.containerPadding
        };
        a.prototype.setContainerPadding = function(g) {
            this.containerPadding = g
        };
        MindFusion.registerClass(a, "MindFusion.Graphs.TreeMapLayout")
    })(MindFusion.Graphs);
    (function(b) {
        var a = MindFusion.Collections.ArrayList;
        var c = b.Vertex = function() {
            this.edges = new a();
            this.outEdges = new a();
            this.inEdges = new a();
            this.weight = 1
        };
        c.prototype.clone = function() {
            var d = new c();
            if (this.layer !== undefined) {
                d.layer = this.layer
            }
            if (this.weight !== undefined) {
                d.weight = this.weight
            }
            if (this.balance !== undefined) {
                d.balance = this.balance
            }
            if (this.owner !== undefined) {
                d.owner = this.owner
            }
            return d
        };
        c.prototype.removeEdge = function(d) {
            if (d.origin == this) {
                this.edges.remove(d);
                this.outEdges.remove(d);
                d.origin = null
            }
            if (d.destination == this) {
                this.edges.remove(d);
                this.inEdges.remove(d);
                d.destination = null
            }
        };
        c.prototype.incidentWith = function(d) {
            return this.edges.contains(d)
        };
        c.prototype.adjacentTo = function(d) {
            return this.getCommonEdge(d) !== null
        };
        c.prototype.getCommonEdge = function(e) {
            var d = this;
            return this.edges.any(function(f) {
                return f.getOtherEnd(d) === e
            }, this)
        };
        c.prototype.getCommonEdges = function(d) {
            return this.edges.all(function(e) {
                return e.getOtherEnd(this) === d
            }, this)
        };
        c.prototype.edgeTo = function(d) {
            return this.outEdges.any(function(e) {
                return e.destination == d
            })
        };
        c.prototype.getNeighbors = function() {
            var d = new a();
            this.inEdges.forEach(function(f) {
                d.push(f.getOtherEnd(this))
            }, this);
            this.outEdges.forEach(function(f) {
                d.push(f.getOtherEnd(this))
            }, this);
            return d
        };
        c.prototype.degree = function() {
            return this.edges.length
        };
        c.prototype.inDegree = function() {
            return this.inEdges.length
        };
        c.prototype.outDegree = function() {
            return this.outEdges.length
        };
        MindFusion.registerClass(c, "MindFusion.Graphs.Vertex")
    })(MindFusion.Graphs);
    (function(c) {
        var a = c.SpringLayout = function() {
            this.nodeDistance = 30;
            this.iterations = 300;
            this.refineStage = false;
            this.initialTemperature = 0;
            this.temperature = 0;
            this.anchoring = c.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = c.MultipleGraphsPlacement.Horizontal
        };
        a.prototype.requiresSimpleGraph = true;
        a.prototype.margins = 10;
        a.prototype.arrange = function(g) {
            this.initialTemperature = this.nodeDistance * 9;
            this.temperature = this.initialTemperature;
            this.graph = g;
            var e = b(g, d(g), 1, 4);
            this.width = e.width;
            this.height = e.height;
            for (var f = 0; f < this.iterations; f++) {
                this.refineStage = f >= this.iterations * 3 / 4;
                g.vertices.forEach(function(h) {
                    this.calcRepulsionForce(h)
                }, this);
                g.edges.forEach(function(h) {
                    this.calcSpringForce(h)
                }, this);
                g.vertices.forEach(function(h) {
                    this.applyForce(h)
                }, this);
                this.temperature = this.refineStage ? this.initialTemperature / 30 : this.initialTemperature * (1 - f / this.iterations / 2)
            }
        };
        a.prototype.moveToEpsilonCircle = function(h, e) {
            var g = Math.random() * 2 * Math.PI;
            var f = e * Math.random();
            if (f == 0) {
                f = e / 2
            }
            h.x += f * Math.cos(g);
            h.y -= f * Math.sin(g)
        };
        a.prototype.attraction = function(e, f, q, o) {
            var p = 0;
            if (this.refineStage) {
                var n = q.x - o.x;
                var l = q.y - o.y;
                var k = q.width / 2;
                var j = q.height / 2;
                var h = o.width / 2;
                var g = o.height / 2;
                p = (n * n) / Math.pow(k + h + f, 2) + (l * l) / Math.pow(j + g + f, 2)
            } else {
                p = e * e / f / f
            }
            return p * 4 / 3
        };
        a.prototype.repulsion = function(h, e, g, f) {
            return 1 / this.attraction(h, e, g, f)
        };
        a.prototype.calcRepulsionForce = function(e) {
            e.dx = 0;
            e.dy = 0;
            var f = this.nodeDistance;
            this.graph.vertices.forEach(function(k) {
                if (k == e) {
                    return
                }
                while (e.x == k.x && e.y == k.y) {
                    this.moveToEpsilonCircle(k, f / 4)
                }
                var h = e.x - k.x;
                var g = e.y - k.y;
                var l = Math.sqrt(h * h + g * g);
                var j = this.repulsion(l, f, e, k);
                e.dx += (h / l) * j;
                e.dy += (g / l) * j
            }, this)
        };
        a.prototype.calcSpringForce = function(h) {
            var o = h.origin;
            var l = h.destination;
            var g = this.nodeDistance;
            while (o.x == l.x && o.y == l.y) {
                this.moveToEpsilonCircle(l, g / 4)
            }
            var k = o.x - l.x;
            var j = o.y - l.y;
            var f = Math.sqrt(k * k + j * j);
            var n = this.attraction(f, g, o, l);
            var q = (k / f) * n;
            var p = (j / f) * n;
            o.dx -= q;
            o.dy -= p;
            l.dx += q;
            l.dy += p
        };
        a.prototype.applyForce = function(e) {
            var f = Math.sqrt(e.dx * e.dx + e.dy * e.dy);
            if (f == 0) {
                return
            }
            e.x += Math.min(f, this.temperature) * e.dx / f;
            e.y += Math.min(f, this.temperature) * e.dy / f;
            e.x = Math.min(this.width, Math.max(e.width / 2, e.x));
            e.y = Math.min(this.height, Math.max(e.height / 2, e.y))
        };

        function d(f) {
            var e = 0;
            if (f.vertices.length == 0) {
                return e
            }
            f.vertices.forEach(function(g) {
                var h = g.width * g.height;
                if (h > 0) {
                    e += Math.sqrt(h)
                }
            });
            return e / f.vertices.length
        }

        function b(j, h, l, k) {
            var f = h * Math.ceil(Math.sqrt(j.vertices.length));
            var g = f * Math.sqrt(l);
            var e = f / Math.sqrt(l);
            return {
                width: g * k,
                height: e * k
            }
        }
        a.With = function() {
            if (!c.SpringLayoutBuilder) {
                c.SpringLayoutBuilder = new MindFusion.Builder(a.prototype)
            } else {
                c.SpringLayoutBuilder.setInstance(null)
            }
            return c.SpringLayoutBuilder
        };
        a.prototype.init = function() {
            if (!c.SpringLayoutBuilder) {
                c.SpringLayoutBuilder = new MindFusion.Builder(a.prototype, null, this)
            } else {
                c.SpringLayoutBuilder.setInstance(this)
            }
            return c.SpringLayoutBuilder
        };
        a.prototype.getType = function() {
            return this.constructor.__typeName
        };
        c.SpringLayoutBuilder = null;
        a.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        a.prototype.setNodeDistance = function(e) {
            this.nodeDistance = e
        };
        a.prototype.getIterations = function() {
            return this.iterations
        };
        a.prototype.setIterations = function(e) {
            this.iterations = e
        };
        a.prototype.getAnchoring = function() {
            return this.anchoring
        };
        a.prototype.setAnchoring = function(e) {
            this.anchoring = e
        };
        a.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        a.prototype.setKeepGroupLayout = function(e) {
            this.keepGroupLayout = e
        };
        a.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        a.prototype.setMultipleGraphsPlacement = function(e) {
            this.multipleGraphsPlacement = e
        };
        MindFusion.registerClass(a, "MindFusion.Graphs.SpringLayout")
    })(MindFusion.Graphs);
    (function(l) {
        var o = MindFusion.Collections.ArrayList;
        var n = MindFusion.Collections.Dictionary;
        var q = MindFusion.Collections.Set;
        var k = MindFusion.Graphs.Edge;
        var p = MindFusion.Graphs.Vertex;
        var g = l.LayeredLayout = function() {
            this.nodeDistance = 20;
            this.layerDistance = 25;
            this.direction = l.LayoutDirection.TopToBottom;
            this.siftingRounds = 1;
            this.anchoring = l.Anchoring.Ignore;
            this.keepGroupLayout = false;
            this.multipleGraphsPlacement = l.MultipleGraphsPlacement.Horizontal
        };
        g.prototype.setsLinkPoints = true;
        g.prototype.requiresConnectedGraph = true;
        g.prototype.requiresSimpleGraph = true;
        g.prototype.margins = 10;
        g.prototype.arrange = function(G) {
            G.setItemIndices();
            this.graph = G;
            var E = G.makeAcyclic();
            for (var s = 0; s < G.vertices.length; s++) {
                var t = G.vertices[s];
                t.layer = -1;
                t.uBaryCenter = 0;
                t.dBaryCenter = 0;
                t.uLinkCount = 0;
                t.dLinkCount = 0;
                t.uPriority = 0;
                t.dPriority = 0;
                t.gridPosition = 0;
                t.dummy = false
            }
            for (var u = 0; u < G.edges.length; u++) {
                var F = G.edges[u];
                F.dummificationLevel = 0
            }
            var v = [];
            var D = [];
            var H = new n();
            G.vertices.forEach(function(I) {
                if (I.inEdges.length == 0) {
                    v.push(I);
                    H.set(I, 0);
                    D.push(I)
                }
            });
            while (D.length > 0) {
                var A = D.shift();
                A.outEdges.forEach(function(J) {
                    var I = J.destination;
                    if (!H.contains(I)) {
                        H.set(I, H.get(A) + 1)
                    } else {
                        H.set(I, Math.max(H.get(I), H.get(A) + 1))
                    }
                    if (!o.contains(D, I)) {
                        D.push(I)
                    }
                })
            }
            var C = 0;
            H.forEachValue(function(I) {
                C = Math.max(C, I)
            });
            var r = [];
            o.addRange(r, H.keys());
            r.sort(function(L, K) {
                var J = H.get(L);
                var I = H.get(K);
                if (J < I) {
                    return 1
                }
                if (J > I) {
                    return -1
                }
                return 0
            });
            for (var s = 0; s < r.length; ++s) {
                var t = r[s];
                var z = Number.MAX_VALUE;
                if (t.outEdges.length == 0) {
                    continue
                }
                for (var u = 0; u < t.outEdges.length; ++u) {
                    var F = t.outEdges[u];
                    z = Math.min(z, H.get(F.destination))
                }
                if (z > 1) {
                    H.set(t, z - 1)
                }
            }
            this.layers = [];
            for (var w = 0; w < C + 1; w++) {
                this.layers.push([])
            }
            H.forEach(function(J, I) {
                J.layer = I;
                this.layers[I].push(J)
            }, this);
            for (var u = 0; u < this.layers.length; u++) {
                var B = this.layers[u];
                for (var w = 0; w < B.length; w++) {
                    B[w].gridPosition = w
                }
            }
            this.dummify();
            this.minimizeCrossings();
            this.swapPairs();
            this.layout();
            this.assignCoordinates();
            this.dedummify();
            E.forEach(function(I) {
                if (I.points) {
                    I.points.reverse()
                }
            })
        };
        g.prototype.setMinDist = function(r, v, t) {
            var s = r.layer;
            var u = r.indexInLayer;
            this.minDistances[s][u] = t
        };
        g.prototype.getMinDist = function(s, r) {
            var u = s.layer;
            var v = s.indexInLayer;
            var t = r.indexInLayer;
            var w = Math.min(v, t);
            var B = Math.max(v, t);
            var A = 0;
            for (var z = w; z < B; ++z) {
                A += this.minDistances[u][z]
            }
            return A
        };
        g.prototype.computeLeftClasses = function() {
            var s = {
                value: null
            };
            var r = this.computeClasses(s, 1);
            this.nodeLeftClass = s.value;
            return r
        };
        g.prototype.computeRightClasses = function() {
            var s = {
                value: null
            };
            var r = this.computeClasses(s, -1);
            this.nodeRightClass = s.value;
            return r
        };
        g.prototype.computeClasses = function(B, C) {
            var r = B.value = new n();
            var w = 0;
            for (var v = 0; v < this.layers.length; ++v) {
                w = v;
                var A = this.layers[v];
                for (var s = C == 1 ? 0 : A.length - 1; 0 <= s && s < A.length; s += C) {
                    var t = A[s];
                    if (!r.contains(t)) {
                        r.set(t, w);
                        if (t.dummy) {
                            this.nodesInLongLink(t).forEach(function(D) {
                                r.set(D, w)
                            })
                        }
                    } else {
                        w = r.get(t)
                    }
                }
            }
            var u = [];
            for (var z = 0; z < this.layers.length; z++) {
                u.push(null)
            }
            r.forEach(function(E, D) {
                if (u[D] === null) {
                    u[D] = []
                }
                u[D].push(E)
            });
            return u
        };
        g.prototype.placeLeftToRight = function(u) {
            var v = new n();
            for (var C = 0; C < this.layers.length; ++C) {
                var z = u[C];
                if (z == null) {
                    continue
                }
                for (var s = 0; s < z.length; s++) {
                    var t = z[s];
                    if (!v.contains(t)) {
                        this.placeLeft(t, v, C)
                    }
                }
                var B = Number.POSITIVE_INFINITY;
                for (var s = 0; s < z.length; s++) {
                    var t = z[s];
                    var w = this.rightSibling(t);
                    if (w != null && this.nodeLeftClass.get(w) != C) {
                        B = Math.min(B, v.get(w) - v.get(t) - this.getMinDist(t, w))
                    }
                }
                if (B == Number.POSITIVE_INFINITY) {
                    var r = [];
                    for (var s = 0; s < z.length; s++) {
                        var t = z[s];
                        var F = [];
                        o.addRange(F, this.upNodes.get(t));
                        o.addRange(F, this.downNodes.get(t));
                        for (var A = 0; A < F.length; A++) {
                            var E = F[A];
                            if (this.nodeLeftClass.get(E) < C) {
                                r.push(v.get(E) - v.get(t))
                            }
                        }
                    }
                    r.sort(function(G, D) {
                        return G - D
                    });
                    if (r.length == 0) {
                        B = 0
                    } else {
                        if (r.length % 2 == 1) {
                            B = r[j(r.length, 2)]
                        } else {
                            B = (r[j(r.length, 2) - 1] + r[j(r.length, 2)]) / 2
                        }
                    }
                }
                for (var s = 0; s < z.length; s++) {
                    var t = z[s];
                    v.set(t, v.get(t) + B)
                }
            }
            return v
        };
        g.prototype.dump = function(w) {
            for (var r = 0; r < this.layers.length; ++r) {
                var u = "";
                u += "layer " + r + ": ";
                var t = this.layers[r];
                for (var v = 0; v < t.length; ++v) {
                    u += w.get(t[v]) + " "
                }
                console.log(u)
            }
        };
        g.prototype.placeRightToLeft = function(C) {
            var z = new n();
            for (var B = 0; B < this.layers.length; ++B) {
                var v = C[B];
                if (v == null) {
                    continue
                }
                for (var t = 0; t < v.length; t++) {
                    var u = v[t];
                    if (!z.contains(u)) {
                        this.placeRight(u, z, B)
                    }
                }
                var A = Number.NEGATIVE_INFINITY;
                for (var t = 0; t < v.length; t++) {
                    var u = v[t];
                    var s = this.leftSibling(u);
                    if (s != null && this.nodeRightClass.get(s) != B) {
                        A = Math.max(A, z.get(s) - z.get(u) + this.getMinDist(s, u))
                    }
                }
                if (A == Number.NEGATIVE_INFINITY) {
                    var r = [];
                    for (var t = 0; t < v.length; t++) {
                        var u = v[t];
                        var F = [];
                        o.addRange(F, this.upNodes.get(u));
                        o.addRange(F, this.downNodes.get(u));
                        for (var w = 0; w < F.length; w++) {
                            var E = F[w];
                            if (this.nodeRightClass.get(E) < B) {
                                r.push(z.get(u) - z.get(E))
                            }
                        }
                    }
                    r.sort(function(G, D) {
                        return G - D
                    });
                    if (r.length == 0) {
                        A = 0
                    } else {
                        if (r.length % 2 == 1) {
                            A = r[j(r.length, 2)]
                        } else {
                            A = (r[j(r.length, 2) - 1] + r[j(r.length, 2)]) / 2
                        }
                    }
                }
                for (var t = 0; t < v.length; t++) {
                    var u = v[t];
                    z.set(u, z.get(u) + A)
                }
            }
            return z
        };
        g.prototype.assignCoordinates = function() {
            for (var L = 0; L < this.layers.length; ++L) {
                var T = this.layers[L];
                T.sort(c)
            }
            this.minDistances = [];
            for (var L = 0; L < this.layers.length; ++L) {
                var T = this.layers[L];
                this.minDistances[L] = [];
                for (var G = 0; G < T.length; ++G) {
                    var I = T[G];
                    I.indexInLayer = G;
                    this.minDistances[L][G] = this.nodeDistance;
                    if (G < T.length - 1) {
                        if (this.direction % 2 == 0) {
                            this.minDistances[L][G] += (I.width + T[G + 1].width) / 2
                        } else {
                            this.minDistances[L][G] += (I.height + T[G + 1].height) / 2
                        }
                    }
                }
            }
            this.downNodes = new n();
            this.upNodes = new n();
            this.graph.vertices.forEach(function(u) {
                this.downNodes.set(u, []);
                this.upNodes.set(u, [])
            }, this);
            this.graph.edges.forEach(function(W) {
                var U = W.origin;
                var V = W.destination;
                var X = null,
                    u = null;
                if (U.layer > V.layer) {
                    X = W.origin;
                    u = W.destination
                } else {
                    u = W.origin;
                    X = W.destination
                }
                this.downNodes.get(u).push(X);
                this.upNodes.get(X).push(u)
            }, this);
            this.downNodes.forEachValue(function(u) {
                u.sort(c)
            });
            this.upNodes.forEachValue(function(u) {
                u.sort(c)
            });
            for (var L = 0; L < this.layers.length - 1; ++L) {
                var T = this.layers[L];
                for (var B = 0; B < T.length - 1; B++) {
                    var s = T[B];
                    if (!s.dummy) {
                        continue
                    }
                    var R = this.downNodes.get(s)[0];
                    if (!R.dummy) {
                        continue
                    }
                    for (var G = B + 1; G < T.length; ++G) {
                        var I = T[G];
                        if (!I.dummy) {
                            continue
                        }
                        var J = this.downNodes.get(I)[0];
                        if (!J.dummy) {
                            continue
                        }
                        if (R.gridPosition > J.gridPosition) {
                            var w = R.gridPosition;
                            R.gridPosition = J.gridPosition;
                            J.gridPosition = w;
                            var K = R.indexInLayer;
                            var H = J.indexInLayer;
                            this.layers[L + 1][K] = J;
                            this.layers[L + 1][H] = R;
                            R.indexInLayer = H;
                            J.indexInLayer = K
                        }
                    }
                }
            }
            var C = this.computeLeftClasses();
            var v = this.computeRightClasses();
            var F = this.placeLeftToRight(C);
            var P = this.placeRightToLeft(v);
            var z = new n();
            this.graph.vertices.forEach(function(u) {
                z.set(u, (F.get(u) + P.get(u)) / 2)
            });
            var M = new n();
            var Q = new n();
            for (var L = 0; L < this.layers.length; ++L) {
                var T = this.layers[L];
                var O = -1,
                    t = -1;
                for (var G = 0; G < T.length; ++G) {
                    var I = T[G];
                    M.set(I, 0);
                    Q.set(I, false);
                    if (I.dummy) {
                        if (O == -1) {
                            O = G
                        } else {
                            if (O == G - 1) {
                                O = G
                            } else {
                                t = G;
                                M.set(T[O], 0);
                                var r = z.get(I) - z.get(T[O]);
                                if (Math.abs(r - this.getMinDist(T[O], I)) < 0.0001) {
                                    Q.set(T[O], true)
                                } else {
                                    Q.set(T[O], false)
                                }
                                O = G
                            }
                        }
                    }
                }
            }
            var A = [1, -1];
            o.forEach(A, function(ab) {
                var u = ab == 1 ? 0 : this.layers.length - 1;
                var X = ab == 1 ? this.layers.length - 1 : 0;
                for (var V = u; 0 <= V && V < this.layers.length; V += ab) {
                    var Z = this.layers[V];
                    var ac = e(Z);
                    var aa = null;
                    var W = null;
                    if (ac != -1) {
                        aa = Z[ac];
                        W = [];
                        for (var Y = 0; Y < ac; Y++) {
                            W.push(Z[Y])
                        }
                    } else {
                        aa = null;
                        W = Z
                    }
                    if (W.length > 0) {
                        this.placeSequence(z, null, aa, ab, W);
                        for (var Y = 0; Y < W.length - 1; ++Y) {
                            this.setMinDist(W[Y], W[Y + 1], z.get(W[Y + 1]) - z.get(W[Y]))
                        }
                        if (aa != null) {
                            this.setMinDist(W[W.length - 1], aa, z.get(aa) - z.get(W[W.length - 1]))
                        }
                    }
                    while (aa != null) {
                        var ad = h(Z, aa);
                        if (ad == null) {
                            ac = aa.indexInLayer;
                            W = [];
                            for (var Y = ac + 1; Y < Z.length; Y++) {
                                W.push(Z[Y])
                            }
                            if (W.length > 0) {
                                this.placeSequence(z, aa, null, ab, W);
                                for (var Y = 0; Y < W.length - 1; ++Y) {
                                    this.setMinDist(W[Y], W[Y + 1], z.get(W[Y + 1]) - z.get(W[Y]))
                                }
                                this.setMinDist(aa, W[0], z.get(W[0]) - z.get(aa))
                            }
                        } else {
                            if (M.get(aa) == ab) {
                                ac = aa.indexInLayer;
                                var U = ad.indexInLayer;
                                W = [];
                                for (var Y = ac + 1; Y < U; Y++) {
                                    W.push(Z[Y])
                                }
                                if (W.length > 0) {
                                    this.placeSequence(z, aa, ad, ab, W)
                                }
                                Q.set(aa, true)
                            }
                        }
                        aa = ad
                    }
                    this.adjustDirections(V, ab, M, Q)
                }
            }, this);
            var S = this.margins;
            for (var N = (this.direction < 2 ? 0 : this.layers.length - 1); this.direction < 2 ? N < this.layers.length : N >= 0; N += (this.direction < 2 ? 1 : -1)) {
                var T = this.layers[N];
                var E = Number.MIN_VALUE;
                for (var G = 0; G < T.length; ++G) {
                    var I = T[G];
                    if (this.direction % 2 == 0) {
                        E = Math.max(E, I.height)
                    } else {
                        E = Math.max(E, I.width)
                    }
                }
                for (var G = 0; G < T.length; ++G) {
                    var I = T[G];
                    var D = I.gridPosition;
                    if (this.direction % 2 == 0) {
                        I.x = z.get(I);
                        I.y = S + E / 2
                    } else {
                        I.x = S + E / 2;
                        I.y = z.get(I)
                    }
                }
                S += this.layerDistance + E
            }
        };
        g.prototype.adjustDirections = function(D, J, F, I) {
            if (D + J < 0 || D + J >= this.layers.length) {
                return
            }
            var u = null,
                H = null;
            var K = this.layers[D + J];
            for (var A = 0; A < K.length; ++A) {
                var v = K[A];
                if (v.dummy) {
                    var z = this.getNeighborOnLayer(v, D);
                    if (z.dummy) {
                        if (u != null) {
                            var w = I.get(H);
                            var t = this.layers[D];
                            var C = H.indexInLayer;
                            var B = z.indexInLayer;
                            for (var G = C + 1; G < B; ++G) {
                                if (t[G].dummy) {
                                    w = w && I.get(t[G])
                                }
                            }
                            if (w) {
                                F.set(u, J);
                                var s = u.indexInLayer;
                                var r = v.indexInLayer;
                                for (var E = s + 1; E < r; ++E) {
                                    if (K[E].dummy) {
                                        F.set(K[E], J)
                                    }
                                }
                            }
                        }
                        u = v;
                        H = z
                    }
                }
            }
        };
        g.prototype.getNeighborOnLayer = function(s, r) {
            var t = this.upNodes.get(s)[0];
            if (t.layer == r) {
                return t
            }
            t = this.downNodes.get(s)[0];
            if (t.layer == r) {
                return t
            }
            return null
        };
        g.prototype.placeSequence = function(s, B, z, u, A) {
            if (A.length == 1) {
                this.placeSingle(s, B, z, u, A[0])
            }
            if (A.length > 1) {
                var w = A.length,
                    v = j(w, 2);
                this.placeSequence(s, B, z, u, A.slice(0, v));
                this.placeSequence(s, B, z, u, A.slice(v));
                this.combineSequences(s, B, z, u, A)
            }
        };
        g.prototype.placeSingle = function(r, z, v, s, u) {
            var t = s == -1 ? this.downNodes.get(u) : this.upNodes.get(u);
            var w = t.length;
            if (w != 0) {
                if (w % 2 == 1) {
                    r.set(u, r.get(t[j(w, 2)]))
                } else {
                    r.set(u, (r.get(t[j(w, 2) - 1]) + r.get(t[j(w, 2)])) / 2)
                }
                if (z != null) {
                    r.set(u, Math.max(r.get(u), r.get(z) + this.getMinDist(z, u)))
                }
                if (v != null) {
                    r.set(u, Math.min(r.get(u), r.get(v) - this.getMinDist(u, v)))
                }
            }
        };
        g.prototype.combineSequences = function(B, v, s, G, A) {
            var E = A.length,
                D = j(E, 2);
            var u = [];
            for (var L = 0; L < D; ++L) {
                var M = 0;
                var J = G == -1 ? this.downNodes.get(A[L]) : this.upNodes.get(A[L]);
                for (var I = 0; I < J.length; ++I) {
                    var z = J[I];
                    if (B.get(z) >= B.get(A[L])) {
                        M++
                    } else {
                        M--;
                        u.push({
                            k: B.get(z) + this.getMinDist(A[L], A[D - 1]),
                            v: 2
                        })
                    }
                }
                u.push({
                    k: B.get(A[L]) + this.getMinDist(A[L], A[D - 1]),
                    v: M
                })
            }
            if (v != null) {
                u.push({
                    k: B.get(v) + this.getMinDist(v, A[D - 1]),
                    v: Number.MAX_VALUE
                })
            }
            u.sort(d);
            var F = [];
            for (var L = D; L < E; ++L) {
                var M = 0;
                var J = G == -1 ? this.downNodes.get(A[L]) : this.upNodes.get(A[L]);
                for (var I = 0; I < J.length; ++I) {
                    var z = J[I];
                    if (B.get(z) <= B.get(A[L])) {
                        M++
                    } else {
                        M--;
                        F.push({
                            k: B.get(z) - this.getMinDist(A[L], A[D]),
                            v: 2
                        })
                    }
                }
                F.push({
                    k: B.get(A[L]) - this.getMinDist(A[L], A[D]),
                    v: M
                })
            }
            if (s != null) {
                F.push({
                    k: B.get(s) - this.getMinDist(s, A[D]),
                    v: Number.MAX_VALUE
                })
            }
            F.sort(b);
            var w = 0,
                C = 0;
            var K = this.getMinDist(A[D - 1], A[D]);
            while (B.get(A[D]) - B.get(A[D - 1]) < K) {
                if (w < C) {
                    if (u.length == 0) {
                        B.set(A[D - 1], B.get(A[D]) - K);
                        break
                    } else {
                        var H = u.shift();
                        w = w + H.v;
                        B.set(A[D - 1], H.k);
                        B.set(A[D - 1], Math.max(B.get(A[D - 1]), B.get(A[D]) - K))
                    }
                } else {
                    if (F.length == 0) {
                        B.set(A[D], B.get(A[D - 1]) + K);
                        break
                    } else {
                        var H = F.shift();
                        C = C + H.v;
                        B.set(A[D], H.k);
                        B.set(A[D], Math.min(B.get(A[D]), B.get(A[D - 1]) + K))
                    }
                }
            }
            for (var L = D - 2; L >= 0; L--) {
                B.set(A[L], Math.min(B.get(A[L]), B.get(A[D - 1]) - this.getMinDist(A[L], A[D - 1])))
            }
            for (var L = D + 1; L < E; L++) {
                B.set(A[L], Math.max(B.get(A[L]), B.get(A[D]) + this.getMinDist(A[L], A[D])))
            }
        };
        g.prototype.placeLeft = function(s, r, t) {
            var u = Number.NEGATIVE_INFINITY;
            this.L(s).forEach(function(z) {
                var w = this.leftSibling(z);
                if (w != null && this.nodeLeftClass.get(w) == this.nodeLeftClass.get(z)) {
                    if (!r.contains(w)) {
                        this.placeLeft(w, r, t)
                    }
                    u = Math.max(u, r.get(w) + this.getMinDist(w, z))
                }
            }, this);
            if (u == Number.NEGATIVE_INFINITY) {
                u = 0
            }
            this.L(s).forEach(function(w) {
                r.set(w, u)
            })
        };
        g.prototype.placeRight = function(t, s, r) {
            var u = Number.POSITIVE_INFINITY;
            this.L(t).forEach(function(w) {
                var z = this.rightSibling(w);
                if (z != null && this.nodeRightClass.get(z) == this.nodeRightClass.get(w)) {
                    if (!s.contains(z)) {
                        this.placeRight(z, s, r)
                    }
                    u = Math.min(u, s.get(z) - this.getMinDist(w, z))
                }
            }, this);
            if (u == Number.POSITIVE_INFINITY) {
                u = 0
            }
            this.L(t).forEach(function(w) {
                s.set(w, u)
            })
        };
        g.prototype.leftSibling = function(t) {
            var s = this.layers[t.layer];
            var r = t.indexInLayer;
            if (r == 0) {
                return null
            }
            return s[r - 1]
        };
        g.prototype.rightSibling = function(t) {
            var s = this.layers[t.layer];
            var r = t.indexInLayer;
            if (r == s.length - 1) {
                return null
            }
            return s[r + 1]
        };
        g.prototype.L = function(r) {
            if (r.dummy) {
                return this.nodesInLongLink(r)
            }
            var s = new o();
            s.push(r);
            return s
        };
        g.prototype.layout = function() {
            for (var r = 0; r < this.layers.length; r++) {
                var u = this.layers[r];
                for (var t = 0; t < u.length; t++) {
                    var z = u[t];
                    z.uPriority = z.uLinkCount;
                    z.dPriority = z.dLinkCount
                }
            }
            var w = 2;
            for (var v = 0; v < w; v++) {
                for (var s = this.layers.length - 1; s >= 1; s--) {
                    this.layoutLayer(false, s)
                }
                for (var s = 0; s < this.layers.length - 1; s++) {
                    this.layoutLayer(true, s)
                }
            }
            var A = Number.MAX_VALUE;
            for (var r = 0; r < this.layers.length; r++) {
                var u = this.layers[r];
                for (var t = 0; t < u.length; t++) {
                    var z = u[t];
                    A = Math.min(A, z.gridPosition)
                }
            }
            if (A < 0) {
                for (var r = 0; r < this.layers.length; r++) {
                    var u = this.layers[r];
                    for (var t = 0; t < u.length; t++) {
                        var z = u[t];
                        z.gridPosition = z.gridPosition - A
                    }
                }
            }
        };
        g.prototype.layoutLayer = function(w, t) {
            var s;
            var u;
            if (w) {
                u = this.layers[s = t + 1]
            } else {
                u = this.layers[s = t - 1]
            }
            var r = [];
            for (var v = 0; v < u.length; v++) {
                r.push(u[v])
            }
            r.sort(function(A, z) {
                var C = (A.uPriority + A.dPriority) / 2;
                var B = (z.uPriority + z.dPriority) / 2;
                if (Math.abs(C - B) < 0.0001) {
                    return 0
                }
                if (C < B) {
                    return 1
                }
                return -1
            });
            o.forEach(r, function(C) {
                var B = C.gridPosition;
                var z = f(C);
                var A = (C.uPriority + C.dPriority) / 2;
                if (Math.abs(B - z) < 0.0001) {
                    return
                }
                if (Math.abs(B - z) < 0.25 + 0.0001) {
                    return
                }
                if (B < z) {
                    while (B < z) {
                        if (!this.moveRight(C, u, A)) {
                            break
                        }
                        B = C.gridPosition
                    }
                } else {
                    while (B > z) {
                        if (!this.moveLeft(C, u, A)) {
                            break
                        }
                        B = C.gridPosition
                    }
                }
            }, this);
            if (s > 0) {
                this.calcDownData(s - 1)
            }
            if (s < this.layers.length - 1) {
                this.calcUpData(s + 1)
            }
        };
        g.prototype.moveRight = function(w, v, u) {
            var t = o.indexOf(v, w);
            if (t == v.length - 1) {
                w.gridPosition = w.gridPosition + 0.5;
                return true
            }
            var s = v[t + 1];
            var r = (s.uPriority + s.dPriority) / 2;
            if (s.gridPosition > w.gridPosition + 1) {
                w.gridPosition = w.gridPosition + 0.5;
                return true
            }
            if (r > u || Math.abs(r - u) < 0.0001) {
                return false
            }
            if (this.moveRight(s, v, u)) {
                w.gridPosition = w.gridPosition + 0.5;
                return true
            }
            return false
        };
        g.prototype.moveLeft = function(v, t, s) {
            var r = o.indexOf(t, v);
            if (r == 0) {
                v.gridPosition = v.gridPosition - 0.5;
                return true
            }
            var w = t[r - 1];
            var u = (w.uPriority + w.dPriority) / 2;
            if (w.gridPosition < v.gridPosition - 1) {
                v.gridPosition = v.gridPosition - 0.5;
                return true
            }
            if (u > s || Math.abs(u - s) < 0.0001) {
                return false
            }
            if (this.moveLeft(w, t, s)) {
                v.gridPosition = v.gridPosition - 0.5;
                return true
            }
            return false
        };
        g.prototype.mapVirtualNode = function(s, r) {
            this.nodeToLinkMap.set(s, r);
            if (!this.linkToNodeMap.contains(r)) {
                this.linkToNodeMap.set(r, new o())
            }
            this.linkToNodeMap.get(r).push(s)
        };
        g.prototype.nodesInLongLink = function(r) {
            return this.linkToNodeMap.get(this.nodeToLinkMap.get(r))
        };
        g.prototype.dummify = function() {
            this.linkToNodeMap = new n();
            this.nodeToLinkMap = new n();
            var s = this.graph.edges.slice(0);
            for (var G = 0; G < s.length; G++) {
                var z = s[G];
                var E = z.origin;
                var K = z.destination;
                var J = E.layer;
                var A = K.layer;
                var u = E.gridPosition;
                var B = K.gridPosition;
                var w = (B - u) / Math.abs(A - J);
                var D = E;
                if (J - A > 1) {
                    for (var I = J - 1; I > A; I--) {
                        var t = new p();
                        t.x = E.x;
                        t.y = E.y;
                        t.width = E.width / 100;
                        t.height = E.height / 100;
                        var L = this.layers[I];
                        var v = (I - A) * w + u;
                        if (v > L.length) {
                            v = L.length
                        }
                        if (u >= this.layers[J].length - 1 && B >= this.layers[A].length - 1) {
                            v = L.length
                        } else {
                            if (u == 0 && B == 0) {
                                v = 0
                            }
                        }
                        t.layer = I;
                        t.uBaryCenter = 0;
                        t.dBaryCenter = 0;
                        t.uLinkCount = 0;
                        t.dLinkCount = 0;
                        t.gridPosition = v;
                        t.dummy = true;
                        o.insert(L, v, t);
                        for (var C = v + 1; C < L.length; C++) {
                            var F = L[C];
                            F.gridPosition = F.gridPosition + 1
                        }
                        var H = new k(D, t);
                        H.dummificationLevel = 0;
                        D = t;
                        this.graph.vertices.push(t);
                        this.graph.addEdge(H);
                        t.index = this.graph.vertices.length - 1;
                        this.mapVirtualNode(t, z)
                    }
                    z.changeOrigin(D);
                    z.dummificationLevel = J - A - 1
                }
                if (J - A < -1) {
                    for (var I = J + 1; I < A; I++) {
                        var t = new p();
                        t.x = E.x;
                        t.y = E.y;
                        t.width = E.width / 100;
                        t.height = E.height / 100;
                        var L = this.layers[I];
                        var v = (I - J) * w + u;
                        if (v > L.length) {
                            v = L.length
                        }
                        if (u >= this.layers[J].length - 1 && B >= this.layers[A].length - 1) {
                            v = L.length
                        } else {
                            if (u == 0 && B == 0) {
                                v = 0
                            }
                        }
                        t.layer = I;
                        t.uBaryCenter = 0;
                        t.dBaryCenter = 0;
                        t.uLinkCount = 0;
                        t.dLinkCount = 0;
                        t.gridPosition = v;
                        t.dummy = true;
                        v = v & v;
                        o.insert(L, v, t);
                        for (var C = v + 1; C < L.length; C++) {
                            var F = L[C];
                            F.gridPosition = F.gridPosition + 1
                        }
                        var H = new k(D, t);
                        H.dummificationLevel = 0;
                        D = t;
                        this.graph.vertices.push(t);
                        this.graph.addEdge(H);
                        t.index = this.graph.vertices.length - 1;
                        this.mapVirtualNode(t, z)
                    }
                    z.changeOrigin(D);
                    z.dummificationLevel = A - J - 1
                }
            }
        };
        g.prototype.dedummify = function() {
            var s = true;
            while (s) {
                s = false;
                for (var u = 0; u < this.graph.edges.length; u++) {
                    var z = this.graph.edges[u];
                    if (z.dummificationLevel == 0) {
                        continue
                    }
                    var A = [];
                    o.insert(A, 0, {
                        x: z.destination.x,
                        y: z.destination.y
                    });
                    o.insert(A, 0, {
                        x: z.origin.x,
                        y: z.origin.y
                    });
                    var B = z;
                    var r = z.dummificationLevel;
                    for (var w = 0; w < r; w++) {
                        var t = B.origin;
                        var v = t.inEdges[0];
                        o.insert(A, 0, {
                            x: v.origin.x,
                            y: v.origin.y
                        });
                        B = v
                    }
                    z.changeOrigin(B.origin);
                    z.dummificationLevel = 0;
                    z.points = A;
                    s = true;
                    break
                }
            }
        };
        g.prototype.minimizeCrossings = function() {
            var s = -1;
            var u = 3;
            var r = 0;
            while (s != 0) {
                if (r++ > u) {
                    break
                }
                s = 0;
                for (var t = this.layers.length - 1; t >= 1; t--) {
                    s += this.minimizeCrossingsDir(false, t)
                }
                for (var t = 0; t < this.layers.length - 1; t++) {
                    s += this.minimizeCrossingsDir(true, t)
                }
            }
        };
        g.prototype.calcUpData = function(v) {
            if (v == 0) {
                return
            }
            var A = this.layers[v];
            var r = new q();
            var C = this.layers[v - 1];
            for (var u = 0; u < C.length; u++) {
                r.add(C[u])
            }
            for (var u = 0; u < A.length; u++) {
                var s = A[u];
                var w = 0;
                var B = 0;
                for (var t = 0; t < s.inEdges.length; t++) {
                    var z = s.inEdges[t];
                    if (r.contains(z.origin)) {
                        B++;
                        w += z.origin.gridPosition
                    }
                }
                for (var t = 0; t < s.outEdges.length; t++) {
                    var z = s.outEdges[t];
                    if (r.contains(z.destination)) {
                        B++;
                        w += z.destination.gridPosition
                    }
                }
                if (B > 0) {
                    s.uBaryCenter = w / B;
                    s.uLinkCount = B
                } else {
                    s.uBaryCenter = u;
                    s.uLinkCount = 0
                }
            }
        };
        g.prototype.calcDownData = function(u) {
            if (u == this.layers.length - 1) {
                return
            }
            var z = this.layers[u];
            var B = new q();
            var C = this.layers[u + 1];
            for (var t = 0; t < C.length; t++) {
                B.add(C[t])
            }
            for (var t = 0; t < z.length; t++) {
                var r = z[t];
                var v = 0;
                var A = 0;
                for (var s = 0; s < r.inEdges.length; s++) {
                    var w = r.inEdges[s];
                    if (B.contains(w.origin)) {
                        A++;
                        v += w.origin.gridPosition
                    }
                }
                for (var s = 0; s < r.outEdges.length; s++) {
                    var w = r.outEdges[s];
                    if (B.contains(w.destination)) {
                        A++;
                        v += w.destination.gridPosition
                    }
                }
                if (A > 0) {
                    r.dBaryCenter = v / A;
                    r.dLinkCount = A
                } else {
                    r.dBaryCenter = t;
                    r.dLinkCount = 0
                }
            }
        };
        g.prototype.minimizeCrossingsDir = function(B, z) {
            var t;
            var A;
            if (B) {
                A = this.layers[t = z + 1]
            } else {
                A = this.layers[t = z - 1]
            }
            var v = A.slice(0);
            if (B) {
                this.calcUpData(t)
            } else {
                this.calcDownData(t)
            }
            A.sort(function(F, E) {
                var G = f(F);
                var D = f(E);
                if (Math.abs(G - D) < 0.0001) {
                    if (F.degree() == E.degree()) {
                        return a(F, E)
                    } else {
                        if (F.degree() < E.degree()) {
                            return 1
                        }
                    }
                    return -1
                }
                var C = (D - G) * 1000;
                if (C > 0) {
                    return -1
                } else {
                    if (C < 0) {
                        return 1
                    }
                }
                return a(F, E)
            });
            var r = 0;
            for (var w = 0; w < A.length; w++) {
                if (A[w] != v[w]) {
                    r++
                }
            }
            if (r > 0) {
                var s = 0;
                for (var w = 0; w < A.length; w++) {
                    var u = A[w];
                    u.gridPosition = s++
                }
            }
            return r
        };
        g.prototype.swapPairs = function() {
            var E = this.siftingRounds;
            var G = 0;
            while (true) {
                if (G++ > E) {
                    break
                }
                var K = (G % 4 <= 1);
                var I = (G % 4 == 1);
                for (var F = (K ? 0 : this.layers.length - 1); K ? F <= this.layers.length - 1 : F >= 0; F += (K ? 1 : -1)) {
                    var L = this.layers[F];
                    var v = false;
                    var w = true;
                    var A = 0;
                    for (var D = 0; D < L.length - 1; D++) {
                        var B = 0;
                        var C = 0;
                        var t = 0;
                        if (w) {
                            if (F != 0) {
                                B = this.countCrossings(F - 1, F)
                            }
                            if (F != this.layers.length - 1) {
                                C = this.countCrossings(F, F + 1)
                            }
                            if (K) {
                                B *= 2
                            } else {
                                C *= 2
                            }
                            t = B + C
                        } else {
                            t = A
                        }
                        if (t == 0) {
                            continue
                        }
                        var s = L[D];
                        var r = L[D + 1];
                        var z = s.gridPosition;
                        var H = r.gridPosition;
                        L[D] = r;
                        L[D + 1] = s;
                        s.gridPosition = H;
                        r.gridPosition = z;
                        B = 0;
                        if (F != 0) {
                            B = this.countCrossings(F - 1, F)
                        }
                        C = 0;
                        if (F != this.layers.length - 1) {
                            C = this.countCrossings(F, F + 1)
                        }
                        if (K) {
                            B *= 2
                        } else {
                            C *= 2
                        }
                        var J = B + C;
                        var u = false;
                        if (I) {
                            u = J >= t
                        } else {
                            u = J > t
                        }
                        if (u) {
                            s = L[D];
                            r = L[D + 1];
                            z = s.gridPosition;
                            H = r.gridPosition;
                            L[D] = r;
                            L[D + 1] = s;
                            s.gridPosition = H;
                            r.gridPosition = z;
                            A = t;
                            w = false
                        } else {
                            v = true;
                            w = true
                        }
                    }
                    if (v) {
                        if (F != this.layers.length - 1) {
                            this.calcUpData(F + 1)
                        }
                        if (F != 0) {
                            this.calcDownData(F - 1)
                        }
                    }
                }
            }
        };
        g.prototype.countCrossings = function(z, t) {
            var G = 0;
            var H = new q();
            var R = this.layers[z];
            for (var L = 0; L < R.length; L++) {
                H.add(R[L])
            }
            var A = new q();
            var Q = this.layers[t];
            for (var L = 0; L < Q.length; L++) {
                A.add(Q[L])
            }
            var v = new q();
            var s = [];
            var O = [];
            H.forEach(function(S) {
                o.addRange(O, S.inEdges);
                o.addRange(O, S.outEdges)
            });
            for (var u = 0; u < O.length; u++) {
                var w = O[u];
                if (H.contains(w.origin) && A.contains(w.destination)) {
                    v.add(w);
                    s.push(w)
                } else {
                    if (A.contains(w.origin) && H.contains(w.destination)) {
                        s.push(w)
                    }
                }
            }
            for (var K = 0; K < s.length; K++) {
                var F = s[K];
                for (var J = 0; J < s.length; J++) {
                    if (K == J) {
                        continue
                    }
                    var D = s[J];
                    var C, B;
                    var N, M;
                    if (v.contains(F)) {
                        C = F.origin;
                        B = F.destination
                    } else {
                        C = F.destination;
                        B = F.origin
                    }
                    if (v.contains(D)) {
                        N = D.origin;
                        M = D.destination
                    } else {
                        N = D.destination;
                        M = D.origin
                    }
                    var P = C.gridPosition;
                    var E = B.gridPosition;
                    var r = N.gridPosition;
                    var I = M.gridPosition;
                    if ((P - r) * (E - I) < 0) {
                        G++
                    }
                }
            }
            return G / 2
        };

        function f(v) {
            var u = v.uLinkCount;
            var r = v.dLinkCount;
            var t = v.uBaryCenter;
            var s = v.dBaryCenter;
            if (u > 0 && r > 0) {
                return (t + s) / 2
            }
            if (u > 0) {
                return t
            }
            if (r > 0) {
                return s
            }
            return 0
        }

        function c(r, s) {
            if (r.gridPosition < s.gridPosition) {
                return -1
            }
            if (r.gridPosition > s.gridPosition) {
                return 1
            }
            return 0
        }

        function b(r, s) {
            if (r.k < s.k) {
                return -1
            }
            if (r.k > s.k) {
                return 1
            }
            return 0
        }

        function d(r, s) {
            if (r.k < s.k) {
                return 1
            }
            if (r.k > s.k) {
                return -1
            }
            return 0
        }

        function e(r) {
            for (var s = 0; s < r.length; s++) {
                if (r[s].dummy) {
                    return s
                }
            }
            return -1
        }

        function a(u, t) {
            var s = u.index;
            var r = t.index;
            if (s < r) {
                return 1
            }
            if (s > r) {
                return -1
            }
            return 0
        }

        function j(r, s) {
            return (r - r % s) / s
        }

        function h(s, t) {
            var u = t.indexInLayer;
            for (var r = u + 1; r < s.length; ++r) {
                if (s[r].dummy) {
                    return s[r]
                }
            }
            return null
        }
        g.With = function() {
            if (!l.LayeredLayoutBuilder) {
                l.LayeredLayoutBuilder = new MindFusion.Builder(g.prototype)
            } else {
                l.LayeredLayoutBuilder.setInstance(null)
            }
            return l.LayeredLayoutBuilder
        };
        g.prototype.init = function() {
            if (!l.LayeredLayoutBuilder) {
                l.LayeredLayoutBuilder = new MindFusion.Builder(g.prototype, null, this)
            } else {
                l.LayeredLayoutBuilder.setInstance(this)
            }
            return l.LayeredLayoutBuilder
        };
        g.prototype.getType = function() {
            return this.constructor.__typeName
        };
        l.LayeredLayoutBuilder = null;
        g.prototype.getNodeDistance = function() {
            return this.nodeDistance
        };
        g.prototype.setNodeDistance = function(r) {
            this.nodeDistance = r
        };
        g.prototype.getLayerDistance = function() {
            return this.layerDistance
        };
        g.prototype.setLayerDistance = function(r) {
            this.layerDistance = r
        };
        g.prototype.getDirection = function() {
            return this.direction
        };
        g.prototype.setDirection = function(r) {
            this.direction = r
        };
        g.prototype.getSiftingRounds = function() {
            return this.siftingRounds
        };
        g.prototype.setSiftingRounds = function(r) {
            this.siftingRounds = r
        };
        g.prototype.getAnchoring = function() {
            return this.anchoring
        };
        g.prototype.setAnchoring = function(r) {
            this.anchoring = r
        };
        g.prototype.getKeepGroupLayout = function() {
            return this.keepGroupLayout
        };
        g.prototype.setKeepGroupLayout = function(r) {
            this.keepGroupLayout = r
        };
        g.prototype.getMultipleGraphsPlacement = function() {
            return this.multipleGraphsPlacement
        };
        g.prototype.setMultipleGraphsPlacement = function(r) {
            this.multipleGraphsPlacement = r
        };
        MindFusion.registerClass(g, "MindFusion.Graphs.LayeredLayout")
    })(MindFusion.Graphs);
    MindFusion.Diagramming.AnchorPoint = function(a, g, d, f, e, b, c) {
        this.x = (a) ? a : 0;
        this.y = (g) ? g : 0;
        this.allowIncoming = (d != undefined) ? d : true;
        this.allowOutgoing = (f != undefined) ? f : true;
        this.markStyle = (e !== undefined) ? e : MindFusion.Diagramming.MarkStyle.Cross;
        this.color = (b) ? b : "#000000";
        this.col = -1;
        this.tag = null;
        this.size = (c) ? c : 3
    };
    MindFusion.Diagramming.AnchorPoint.prototype = {
        toJson: function() {
            return {
                x: this.x,
                y: this.y,
                allowIncoming: this.allowIncoming,
                allowOutgoing: this.allowOutgoing,
                markStyle: this.markStyle,
                color: this.color,
                column: this.col,
                tag: this.tag,
                size: this.size
            }
        },
        fromJson: function(a) {
            this.setX(a.x);
            this.setY(a.y);
            this.setAllowIncoming(a.allowIncoming);
            this.setAllowOutgoing(a.allowOutgoing);
            this.setMarkStyle(a.markStyle);
            this.setColor(a.color);
            this.setColumn(a.column);
            this.setTag(a.tag);
            this.setSize(a.size)
        },
        saveToXml: function(b, a) {
            a.writeBool(this.allowIncoming, "AllowIncoming", b);
            a.writeBool(this.allowOutgoing, "AllowOutgoing", b);
            a.writeColor(this.color, "Color", b);
            a.writeInt(this.col, "Column", b);
            a.writeInt(this.markStyle, "MarkStyle", b);
            a.writeTag(this, this.tag, "Tag", b);
            a.writeString(this.toolTip, "Tooltip", b);
            a.writeFloat(this.x, "X", b);
            a.writeFloat(this.y, "Y", b)
        },
        getPosition: function(a) {
            return new Point(a.x + a.width * this.x / 100, a.y + a.height * this.y / 100)
        },
        getX: function() {
            return this.x
        },
        setX: function(a) {
            this.x = a
        },
        getY: function() {
            return this.y
        },
        setY: function(a) {
            this.y = a
        },
        getColumn: function() {
            return this.col
        },
        setColumn: function(a) {
            this.col = a
        },
        getAllowIncoming: function() {
            return this.allowIncoming
        },
        setAllowIncoming: function(a) {
            this.allowIncoming = a
        },
        getAllowOutgoing: function() {
            return this.allowOutgoing
        },
        setAllowOutgoing: function(a) {
            this.allowOutgoing = a
        },
        getMarkStyle: function() {
            return this.markStyle
        },
        setMarkStyle: function(a) {
            this.markStyle = a
        },
        getColor: function() {
            return this.color
        },
        setColor: function(a) {
            this.color = a
        },
        getTag: function() {
            return this.tag
        },
        setTag: function(a) {
            this.tag = a
        },
        getToolTip: function() {
            return this.toolTip
        },
        setToolTip: function(a) {
            if (this.toolTip != a) {
                if (a == null) {
                    this.toolTip = ""
                } else {
                    this.toolTip = a
                }
            }
        },
        getSize: function() {
            return this.size
        },
        setSize: function(a) {
            this.size = a
        },
        updatePointData: function(c, b, h, a, e) {
            var j = b.x + b.width * this.x / 100;
            var g = b.y + b.height * this.y / 100;
            var f = e / 2
        }
    };
    MindFusion.registerClass(MindFusion.Diagramming.AnchorPoint, "MindFusion.Diagramming.AnchorPoint");
    (function(a) {
        var d = MindFusion.Drawing.GraphicsUnit;
        var b = MindFusion.Drawing.Rect;
        var c = a.Manipulator = function(e) {
            mflayer.initializeBase(c, this);
            this.node = e
        };
        c.prototype = {
            updateLocation: function() {},
            hitTest: function(e) {},
            onClick: function(e) {},
            needsMouseMessages: function(e) {
                return false
            },
            onMouseDown: function(e) {},
            onMouseMove: function(e) {},
            onMouseUp: function(e) {},
            cancel: function() {},
            setMouseCursor: function(e) {}
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.Manipulator", MindFusion.Drawing.Container)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.LengthType = {
        Auto: 0,
        Relative: 1
    };
    MindFusion.Diagramming.Cursors = {
        TopLeft: 0,
        TopCenter: 1,
        TopRight: 2,
        MiddleLeft: 3,
        MiddleCenter: 4,
        MiddleRight: 5,
        BottomLeft: 6,
        BottomCenter: 7,
        BottomRight: 8,
        Rotate: 9,
        Pointer: 10,
        Default: 11
    };
    MindFusion.Diagramming.ImageAlign = MindFusion.Drawing.ImageAlign;
    MindFusion.Diagramming.Alignment = {
        Near: 0,
        Center: 1,
        Far: 2
    };
    MindFusion.Diagramming.CellFrameStyle = {
        None: 0,
        Simple: 1,
        System3D: 2
    };
    MindFusion.Diagramming.AdjustmentHandles = {
        None: 0,
        ResizeTopLeft: 1,
        ResizeTopRight: 2,
        ResizeBottomRight: 4,
        ResizeBottomLeft: 8,
        ResizeTopCenter: 16,
        ResizeMiddleRight: 32,
        ResizeBottomCenter: 64,
        ResizeMiddleLeft: 128,
        Move: 256,
        Rotate: 512,
        All: 1023
    };
    MindFusion.Diagramming.Behavior = {
        Modify: 0,
        DrawShapes: 1,
        DrawLinks: 2,
        LinkShapes: 3,
        LinkTables: 4,
        DrawTables: 5,
        DoNothing: 8,
        Custom: 9,
        DrawContainers: 10,
        LinkContainers: 11,
        Pan: 12,
        DrawSvgNodes: 15,
        LinkSvgNodes: 16,
        SelectOnly: 17,
        DrawFreeForms: 23,
        LinkFreeForms: 24,
        DrawFreeShapes: 25,
        LinkFreeShapes: 26
    };
    MindFusion.Diagramming.Action = {
        None: 0,
        Create: 1,
        Modify: 2,
        Split: 3
    };
    MindFusion.Diagramming.ConnectionStyle = {
        Node: 0,
        Rows: 1
    };
    MindFusion.Diagramming.DelKeyAction = {
        None: 0,
        DeleteActiveItem: 1,
        DeleteSelectedItems: 2
    };
    MindFusion.Diagramming.MarkStyle = {
        None: 0,
        Cross: 1,
        X: 2,
        Circle: 3,
        Rectangle: 4
    };
    MindFusion.Diagramming.ShowAnchors = {
        Always: 0,
        Never: 1,
        Auto: 2,
        Selected: 4
    };
    MindFusion.Diagramming.GridStyle = {
        Points: 0,
        Lines: 1,
        Crosses: 2
    };
    MindFusion.Diagramming.ColumnStyle = {
        FixedWidth: 0,
        AutoWidth: 1
    };
    MindFusion.Diagramming.LinkShape = {
        Bezier: 0,
        Polyline: 1,
        Cascading: 2,
        Spline: 3
    };
    MindFusion.Diagramming.RelativeToLink = {
        Segment: 0,
        ControlPoint: 1,
        LinkLength: 2
    };
    MindFusion.Diagramming.FitSize = {
        KeepWidth: 0,
        KeepHeight: 1,
        KeepRatio: 2
    };
    MindFusion.Diagramming.EffectPhase = {
        BeforeFill: 0,
        AfterFill: 1,
        AfterOutline: 2
    };
    MindFusion.Diagramming.GlassEffectType = {
        Type1: 0,
        Type2: 1,
        Type3: 2,
        Type4: 3
    };
    MindFusion.Diagramming.HandlesStyle = {
        Invisible: 0,
        SquareHandles: 1,
        DashFrame: 2,
        HatchFrame: 3,
        HatchHandles: 4,
        HatchHandles2: 5,
        HatchHandles3: 6,
        MoveOnly: 7,
        EasyMove: 8,
        SquareHandles2: 9,
        Custom: 10,
        InvisibleMove: 11,
        RoundAndSquare: 12,
        RoundAndSquare2: 13
    };
    MindFusion.Diagramming.LinkCrossings = {
        Straight: 0,
        Arcs: 1,
        Cut: 2
    };
    MindFusion.Diagramming.ModificationStart = {
        SelectedOnly: 0,
        AutoHandles: 1
    };
    MindFusion.Diagramming.AutoResize = {
        None: 0,
        RightAndDown: 1,
        AllDirections: 2
    };
    MindFusion.Diagramming.ModifierKeyAction = {
        None: 0,
        Pan: 1,
        Select: 2,
        OverrideBehavior: 3,
        Magnify: 4
    };
    MindFusion.Diagramming.MouseButtonActions = {
        None: 0,
        Pan: 1,
        Cancel: 2,
        Select: 4,
        Draw: 8,
        Magnify: 16
    };
    MindFusion.Diagramming.LinkTextStyle = {
        Center: 0,
        Rotate: 1,
        OverLongestSegment: 2,
        Follow: 3,
        MiddleSegment: 4,
        MiddleSegmentRotated: 5
    };
    MindFusion.Diagramming.ShadowsStyle = {
        None: 0,
        OneLevel: 1,
        ZOrder: 2
    };
    MindFusion.Diagramming.SimpleShape = {
        Rectangle: 0,
        RoundedRectangle: 1
    };
    MindFusion.Diagramming.Orientation = {
        Auto: 0,
        Horizontal: 1,
        Vertical: 2
    };
    MindFusion.Diagramming.SaveToStringFormat = {
        Json: 0,
        Xml: 1
    };
    MindFusion.Diagramming.ScaleMode = {
        FitAll: 0,
        CombinedScales: 1,
        FixedScale: 2,
    };
    (function(c) {
        var b = MindFusion.Collections.ArrayList;
        var f = MindFusion.Drawing.Font;
        var e = MindFusion.Drawing.FontStyle;
        var d = MindFusion.Drawing.Thickness;
        var a = c.DiagramItem = function(g) {
            mflayer.initializeBase(a, this);
            this.parent = g;
            this.bounds = new MindFusion.Drawing.Rect(0, 0, 20, 20);
            this.text = new MindFusion.Drawing.Text("", this.bounds);
            if (a.useStyles === false) {
                this.brush = {
                    type: "SolidBrush",
                    color: "#FFFFFF"
                };
                this.pen = "#000000";
                this.strokeThickness = 0
            }
            this.textColor = customFontColor;
            this.selected = false;
            this.ignoreLayout = false;
            this.tooltip = "";
            this.hyperLink = "";
            this.textPadding = new d(1, 1, 1, 1);
            this.topLevel = true;
            this.graphicsContainer = new MindFusion.Drawing.Container(0, 0)
        };
        a.prototype = {
            getType: function() {
                return this.constructor.__typeName
            },
            clone: function() {
                var g = new this.constructor(this.parent);
                g.bounds = this.bounds.clone();
                g.textColor = this.textColor;
                g.textStroke = this.textStroke;
                g.textStrokeThickness = this.textStrokeThickness;
                g.setTextPadding(d.copy(this.textPadding));
                g.font = (this.font) ? f.copy(this.font) : undefined;
                g.brush = this.brush;
                g.pen = this.pen;
                g.strokeThickness = this.strokeThickness;
                g.strokeDashStyle = this.strokeDashStyle;
                g.ignoreLayout = this.ignoreLayout;
                g.layoutTraits = this.layoutTraits;
                g.handlesSize = this.handlesSize;
                g.locked = this.locked;
                g.tooltip = this.tooltip;
                g.hyperLink = this.hyperLink;
                g.shadowColor = this.shadowColor;
                g.shadowOffsetX = this.shadowOffsetX;
                g.shadowOffsetY = this.shadowOffsetY;
                g.style = (this.style) ? this.style.clone() : undefined;
                g.setTextAlignment(this.getTextAlignment());
                g.setLineAlignment(this.getLineAlignment());
                g.setZIndex(this.getZIndex());
                g.setTag(this.getTag());
                g.setId(this.getId());
                g.setVisible(this.getVisible());
                g.invalidate(false);
                return g
            },
            toJson: function() {
                var g = {
                    __type: this.getType(),
                    instanceId: this.instanceId,
                    zIndex: this.getZIndex(),
                    layoutTraits: this.layoutTraits,
                    text: this.getText(),
                    textColor: this.textColor,
                    textStroke: this.textStroke,
                    textStrokeThickness: this.textStrokeThickness,
                    textPadding: this.textPadding,
                    font: this.font,
                    ignoreLayout: this.ignoreLayout,
                    brush: this.brush,
                    pen: this.pen,
                    strokeThickness: this.strokeThickness,
                    strokeDashStyle: this.strokeDashStyle,
                    selected: this.selected,
                    visible: this.getVisible(),
                    locked: this.getLocked(),
                    tooltip: this.tooltip,
                    hyperLink: this.hyperLink,
                    shadowColor: this.shadowColor,
                    shadowOffsetX: this.getShadowOffsetX(),
                    shadowOffsetY: this.getShadowOffsetY(),
                    textAlignment: this.getTextAlignment(),
                    lineAlignment: this.getLineAlignment(),
                    style: this.style ? this.style.toJson() : null
                };
                if (typeof this.id !== "undefined") {
                    g.id = this.id
                }
                if (typeof this.tag !== "undefined") {
                    g.tag = this.tag
                }
                return g
            },
            fromJson: function(g) {
                this.setZIndex(g.zIndex);
                this.setTag(g.tag);
                this.setId(g.id);
                this.setText(g.text);
                this.setBrush(g.brush);
                this.setPen(g.pen);
                this.strokeThickness = g.strokeThickness;
                this.strokeDashStyle = g.strokeDashStyle;
                this.layoutTraits = g.layoutTraits;
                this.textColor = g.textColor;
                this.textStroke = g.textStroke;
                this.textStrokeThickness = g.textStrokeThickness;
                if (g.textPadding) {
                    this.setTextPadding(d.copy(g.textPadding))
                }
                if (g.visible !== undefined) {
                    this.setVisible(g.visible)
                }
                if (g.ignoreLayout) {
                    this.ignoreLayout = true
                }
                if (g.font) {
                    this.font = f.copy(g.font)
                }
                if (g.style) {
                    this.style = new c.Style(false);
                    this.style.fromJson(g.style)
                }
                if (g.locked !== undefined) {
                    this.locked = g.locked
                }
                this.tooltip = g.tooltip;
                this.hyperLink = g.hyperLink;
                this.shadowColor = g.shadowColor;
                this.shadowOffsetX = g.shadowOffsetX;
                this.shadowOffsetY = g.shadowOffsetY;
                if (g.textAlignment !== undefined) {
                    this.setTextAlignment(g.textAlignment)
                }
                if (g.lineAlignment !== undefined) {
                    this.setLineAlignment(g.lineAlignment)
                }
            },
            loadFromXml: function(j, h) {
                this.setZIndex(h.readInt("ZIndex", j));
                this.hyperLink = h.readString("HyperLink", j);
                this.locked = h.readBool("Locked", j);
                this.setVisible(h.readBool("Visible", j, true));
                this.brush = h.readBrush("Brush", j);
                this.style = h.readStyle("Style", j);
                var l = h.readPen("Pen", j);
                if (l) {
                    this.pen = l.brush;
                    this.strokeThickness = l.width;
                    this.strokeDashStyle = l.dashStyle
                } else {
                    this.pen = h.readBrush("Stroke", j);
                    this.strokeThickness = h.readFloat("StrokeThickness", j);
                    this.strokeDashStyle = MindFusion.Drawing.DashStyle[h.readString("StrokeDashStyle", j)];
                    if (this.strokeDashStyle === undefined) {
                        this.strokeDashStyle = h.readInt("StrokeDashStyle", j)
                    }
                }
                this.font = h.readFont("Font", j);
                if (!this.font) {
                    var g = h.readString("FontFamily", j);
                    var k = h.readFloat("FontSize", j);
                    if (g != "" && k > 0) {
                        this.font = new f(g, k)
                    }
                }
                this.setText(h.readString("Text", j));
                this.textColor = h.readBrush("TextBrush", j);
                this.setTextPadding(h.readThickness("TextPadding", j));
                this.ignoreLayout = h.readBool("IgnoreLayout", j);
                this.tooltip = h.readString("ToolTip", j);
                this.shadowColor = h.readBrush("ShadowBrush", j, this.shadowColor);
                this.shadowOffsetX = h.readFloat("ShadowOffsetX", j, h.diagram.getShadowOffsetX());
                this.shadowOffsetY = h.readFloat("ShadowOffsetY", j, h.diagram.getShadowOffsetY());
                this.tag = h.readTag(this, "Tag", j);
                this.id = h.readTag(this, "Id", j)
            },
            saveToXml: function(h, g) {
                g.writeInt(this.getZIndex(), "ZIndex", h);
                g.writeString(this.hyperLink, "HyperLink", h);
                g.writeBool(this.getLocked(), "Locked", h);
                g.writeBool(this.getVisible(), "Visible", h);
                if (this.brush) {
                    g.writeBrush(this.brush, "Brush", h)
                }
                if (this.constructor.xmlInfo) {
                    g.writeStyle(this.style, "Style", h, this.constructor.xmlInfo.classId + "Style")
                }
                if (this.pen) {
                    g.writeBrush(this.pen, "Stroke", h)
                }
                if (this.strokeThickness !== undefined) {
                    g.writeFloat(this.strokeThickness, "StrokeThickness", h)
                }
                if (this.strokeDashStyle !== undefined) {
                    g.writeInt(this.strokeDashStyle, "StrokeDashStyle", h)
                }
                if (this.font) {
                    g.writeFont(this.font, "Font", h)
                }
                g.writeString(this.getText(), "Text", h);
                g.writeBrush(this.textColor, "TextBrush", h);
                g.writeThickness(this.getTextPadding(), "TextPadding", h);
                g.writeBool(this.ignoreLayout, "IgnoreLayout", h);
                if (this.tooltip) {
                    g.writeString(this.tooltip, "ToolTip", h)
                }
                g.writeBrush(this.shadowColor, "ShadowBrush", h);
                if (this.shadowOffsetX !== undefined) {
                    g.writeFloat(this.shadowOffsetX, "ShadowOffsetX", h)
                }
                if (this.shadowOffsetY !== undefined) {
                    g.writeFloat(this.shadowOffsetY, "ShadowOffsetY", h)
                }
                g.writeTag(this, this.tag, "Tag", h);
                g.writeTag(this, this.id, "Id", h)
            },
            onLoad: function(g) {},
            getParent: function() {
                return this.parent
            },
            setParent: function(g) {
                this.parent = g
            },
            setDiagramDirty: function() {
                if (this.parent && this.parent.setDirty) {
                    this.parent.setDirty(true)
                }
            },
            setText: function(g) {
                if (g != undefined && g !== this.text.text) {
                    this.text.text = g + "";
                    this.invalidate();
                    this.textCacheInvalid = true
                }
            },
            getText: function() {
                return this.text.text
            },
            setTextColor: function(g) {
                if (this.textColor !== g) {
                    this.textColor = g;
                    this.invalidate()
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextStroke: function(g) {
                if (this.textStroke !== g) {
                    this.textStroke = g;
                    this.invalidate()
                }
            },
            getTextStroke: function() {
                return this.textStroke
            },
            setTextStrokeThickness: function(g) {
                if (this.textStrokeThickness !== g) {
                    this.textStrokeThickness = g;
                    this.invalidate()
                }
            },
            getTextStrokeThickness: function() {
                return this.textStrokeThickness
            },
            setTextPadding: function(g) {
                if (this.textPadding !== g) {
                    this.textPadding = g;
                    this.text.padding = g;
                    this.invalidate()
                }
            },
            getTextPadding: function() {
                return this.textPadding
            },
            setFont: function(g) {
                if (this.font !== g) {
                    this.font = g;
                    this.invalidate();
                    this.textCacheInvalid = true
                }
            },
            getFont: function() {
                return this.font
            },
            setBrush: function(g) {
                if (this.brush !== g) {
                    this.brush = g;
                    this.invalidate()
                }
            },
            getBrush: function() {
                return this.brush
            },
            setPen: function(g) {
                if (this.pen !== g) {
                    this.pen = g;
                    this.invalidate()
                }
            },
            getPen: function() {
                return this.pen
            },
            setStroke: function(g) {
                if (this.pen !== g) {
                    this.pen = g;
                    this.invalidate()
                }
            },
            getStroke: function() {
                return this.pen
            },
            setStrokeThickness: function(g) {
                if (this.strokeThickness !== g) {
                    this.strokeThickness = g;
                    this.invalidate()
                }
            },
            getStrokeThickness: function() {
                return this.strokeThickness
            },
            setStrokeDashStyle: function(g) {
                if (this.strokeDashStyle !== g) {
                    this.strokeDashStyle = g;
                    this.invalidate()
                }
            },
            getStrokeDashStyle: function() {
                return this.strokeDashStyle
            },
            setTag: function(g) {
                if (this.tag !== g) {
                    this.tag = g;
                    this.setDiagramDirty()
                }
            },
            getTag: function() {
                return this.tag
            },
            setWeight: function(g) {
                if (this.weight !== g) {
                    this.weight = g;
                    this.setDiagramDirty()
                }
            },
            getWeight: function() {
                if (this.weight === undefined) {
                    return 1
                }
                return this.weight
            },
            setId: function(g) {
                if (this.id !== g) {
                    this.id = g;
                    this.setDiagramDirty()
                }
            },
            getId: function() {
                return this.id
            },
            setTooltip: function(g) {
                if (this.tooltip !== g) {
                    this.tooltip = g;
                    this.setDiagramDirty()
                }
            },
            getTooltip: function() {
                return this.tooltip
            },
            setIgnoreLayout: function(g) {
                if (this.ignoreLayout !== g) {
                    this.ignoreLayout = g;
                    this.setDiagramDirty()
                }
            },
            getIgnoreLayout: function() {
                return this.ignoreLayout
            },
            getLayoutTraits: function() {
                if (!this.layoutTraits) {
                    this.layoutTraits = {}
                }
                return this.layoutTraits
            },
            isFrozen: function() {
                return this.ignoreLayout || !this.getVisible()
            },
            setZIndex: function(g) {
                if (this.graphicsContainer.zIndex !== g) {
                    this.graphicsContainer.zIndex = g;
                    if (this.parent && this.parent.invalidateZOrder) {
                        this.parent.invalidateZOrder()
                    }
                    this.setDiagramDirty()
                }
            },
            getZIndex: function() {
                return this.graphicsContainer.zIndex
            },
            getRuntimeIndex: function() {
                if (this.parent) {
                    return b.indexOf(this.parent.items, this)
                }
                return null
            },
            setSelectedState: function(g) {
                if (this.selected != g) {
                    this.selected = g;
                    this.invalidate()
                }
            },
            setSelected: function(g) {
                if (this.parent && this.selected != g) {
                    if (g) {
                        this.parent.selection.addItem(this)
                    } else {
                        this.parent.selection.removeItem(this)
                    }
                    this.setDiagramDirty()
                }
            },
            getSelected: function() {
                return this.selected
            },
            setHyperLink: function(g) {
                if (this.hyperLink !== g) {
                    this.hyperLink = g || "";
                    this.setDiagramDirty()
                }
            },
            getHyperLink: function() {
                return this.hyperLink || ""
            },
            getContainer: function() {
                return this.container
            },
            startDrag: function(g) {
                this._mf_render = true
            },
            updateDrag: function(g) {},
            endDrag: function(g) {},
            allowDrag: function(g) {
                return true
            },
            saveLocationState: function() {
                return null
            },
            restoreLocationState: function(g) {
                this.invalidate()
            },
            onRemove: function() {
                if (this.parent) {
                    if (this.container) {
                        this.container.remove(this, true)
                    }
                    this.parent.raiseDeleted(this);
                    this.parent = null
                }
            },
            containsPoint: function(g) {
                return false
            },
            hitTest: function(j, h, k, g) {
                if (this.parent != null && !this.parent.isItemVisible(this)) {
                    return null
                }
                if (g && this.parent != null && !this.parent.isItemInteractive(this)) {
                    return null
                }
                var l = h > 0 ? this.containsPoint(j, h) : this.containsPoint(j);
                return l ? this : null
            },
            notInteractive: function() {
                return !this.getVisible() || this.locked
            },
            addCanvasElements: function() {
                this.graphicsContainer.item = this;
                this._mf_render = true;
                this.parent.addElement(this.graphicsContainer)
            },
            removeCanvasElements: function() {
                this.invalidate();
                if (this.parent) {
                    this.parent.removeElement(this.graphicsContainer)
                }
            },
            onShapeLoaded: function() {},
            updateCanvasElements: function() {},
            getRotatedBounds: function() {
                return this.getBounds()
            },
            getRepaintBounds: function() {
                var j = this.getRotatedBounds();
                var g = this.getEffectiveHandlesSize();
                var h = Math.max(this.getShadowOffsetX(), this.getShadowOffsetY());
                if (this.parent) {
                    if (this.parent.shadowsStyle == c.ShadowsStyle.None) {
                        h = 0
                    } else {
                        if (this.parent.zoomFactor < 100) {
                            h *= 100 / this.parent.zoomFactor
                        }
                    }
                }
                var k = Math.max(g, h);
                j = j.inflate(k);
                return this.adjustRepaintBounds(j)
            },
            adjustRepaintBounds: function(g) {
                return g
            },
            invalidate: function(g) {
                if (!this._mf_render) {
                    return
                }
                this.requestRepaint(this.getRepaintBounds());
                if (this.parent) {
                    if (g === undefined) {
                        g = true
                    }
                    if (g && this.parent.setDirty) {
                        this.parent.setDirty(true)
                    }
                }
            },
            requestRepaint: function(g) {
                this.graphicsContainer.invalidParent = this;
                if (this.parent) {
                    this.parent.invalidate(g)
                }
            },
            setVisible: function(g) {
                if (this.graphicsContainer.invisible == !g) {
                    return
                }
                if (g) {
                    delete this.graphicsContainer.invisible;
                    if (this.onShow) {
                        this.onShow()
                    }
                } else {
                    this.graphicsContainer.invisible = true;
                    if (this.selected) {
                        this.setSelected(false)
                    }
                    if (this.onHide) {
                        this.onHide()
                    }
                }
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            getVisible: function() {
                return this.graphicsContainer.invisible ? false : true
            },
            setLocked: function(g) {
                if (this.locked !== g) {
                    this.locked = g;
                    this.setDiagramDirty()
                }
            },
            getLocked: function() {
                return this.locked ? true : false
            },
            getTopLevel: function() {
                if (this.parent) {
                    var g = this.parent.mouseInputDispatcher;
                    if (g && g.currentController) {
                        if (g.currentController.modifiedItem == this) {
                            return true
                        }
                        if (g.currentController.modifiedItem == this.parent.selection && this.selected) {
                            return true
                        }
                    }
                }
                return this.topLevel
            },
            setTopLevel: function(g) {
                this.topLevel = g
            },
            hitTestManipulators: function(g) {
                return null
            },
            getObjectToEdit: function(g, h) {
                return this
            },
            getDiagramItem: function() {
                return this
            },
            getTextToEdit: function() {
                return this.text.text
            },
            setEditedText: function(g) {
                this.setText(g)
            },
            setShadowColor: function(g) {
                if (this.shadowColor !== g) {
                    this.shadowColor = g;
                    this.invalidate()
                }
            },
            getShadowColor: function() {
                return this.shadowColor
            },
            setShadowOffsetX: function(g) {
                if (this.shadowOffsetX !== g) {
                    this.shadowOffsetX = g;
                    this.invalidate()
                }
            },
            getShadowOffsetX: function() {
                if (this.shadowOffsetX === undefined) {
                    if (this.parent && this.parent.getShadowOffsetX) {
                        return this.parent.getShadowOffsetX()
                    }
                    return 4
                }
                return this.shadowOffsetX
            },
            setShadowOffsetY: function(g) {
                if (this.shadowOffsetY !== g) {
                    this.shadowOffsetY = g;
                    this.invalidate()
                }
            },
            getShadowOffsetY: function() {
                if (this.shadowOffsetY === undefined) {
                    if (this.parent && this.parent.getShadowOffsetY) {
                        return this.parent.getShadowOffsetY()
                    }
                    return 4
                }
                return this.shadowOffsetY
            },
            createShadow: function() {
                var g = this.getEffectiveShadowColor();
                return g ? new MindFusion.Drawing.Shadow(g, this.getShadowOffsetX(), this.getShadowOffsetY()) : undefined
            },
            setStyle: function(g) {
                if (this.style !== g) {
                    this.style = g;
                    this.invalidate()
                }
            },
            getStyle: function() {
                return this.style
            },
            setTextAlignment: function(g) {
                if (this.text.textAlignment != g) {
                    this.text.textAlignment = g;
                    this.invalidate()
                }
            },
            getTextAlignment: function() {
                return this.text.textAlignment
            },
            setLineAlignment: function(g) {
                if (this.text.lineAlignment != g) {
                    this.text.lineAlignment = g;
                    this.invalidate()
                }
            },
            getLineAlignment: function() {
                return this.text.lineAlignment
            },
            getGraphicsContent: function() {
                return this.graphicsContainer.content
            },
            resolveEffectiveStyle: function(g) {
                if (this.style && g.apply(this.style)) {
                    return this.style
                }
                if (this.parent) {
                    var h = this.parent.style;
                    if (h && g.apply(h)) {
                        return h
                    }
                    var k = this.parent.theme;
                    if (k) {
                        var j = this.resolveInheritedStyle(g, k);
                        if (j) {
                            return j
                        }
                    }
                }
                return this.resolveInheritedStyle(g, c.Theme.Default)
            },
            resolveInheritedStyle: function(h, k) {
                var g = k.styles["std:DiagramItem"];
                if (g) {
                    if (h.apply(g)) {
                        return g
                    }
                }
                var j = k.styles["std:Diagram"];
                if (j) {
                    if (h.apply(j)) {
                        return j
                    }
                }
                return null
            },
            getEffectiveBrush: function() {
                if (this.brush) {
                    return this.brush
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasBrush);
                if (g) {
                    return g.getBrush()
                }
                return "white"
            },
            getEffectiveStroke: function() {
                if (this.pen) {
                    return this.pen
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasStroke);
                if (g) {
                    return g.getStroke()
                }
                return "white"
            },
            getEffectiveStrokeThickness: function() {
                if (this.strokeThickness !== undefined) {
                    return this.strokeThickness
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasStrokeThickness);
                if (g) {
                    return g.getStrokeThickness()
                }
                return 0
            },
            getEffectiveStrokeDashStyle: function() {
                if (this.strokeDashStyle !== undefined) {
                    return this.strokeDashStyle
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasStrokeDashStyle);
                if (g) {
                    return g.getStrokeDashStyle()
                }
                return 0
            },
            getEffectiveTextColor: function() {
                if (this.textColor) {
                    return this.textColor
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasTextColor);
                if (g) {
                    return g.getTextColor()
                }
                return "black"
            },
            getEffectiveTextStroke: function() {
                return this.textStroke
            },
            getEffectiveTextStrokeThickness: function() {
                return this.textStrokeThickness || 0
            },
            getEffectiveFont: function() {
                if (this.font) {
                    return this.font
                }
                var j = this.getEffectiveFontStyle();
                var h = (j & e.Bold) != 0;
                var g = (j & e.Italic) != 0;
                var k = (j & e.Underline) != 0;
                return new f(this.getEffectiveFontName(), this.getEffectiveFontSize(), h, g, k)
            },
            getEffectiveFontName: function() {
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasFontName);
                if (g) {
                    return g.getFontName()
                }
                return "sans-serif"
            },
            getEffectiveFontSize: function() {
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasFontSize);
                if (g) {
                    return g.getFontSize()
                }
                return 4
            },
            getEffectiveFontStyle: function() {
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasFontStyle);
                if (g) {
                    return g.getFontStyle()
                }
                return e.Regular
            },
            getEffectiveShadowColor: function() {
                if (this.shadowColor) {
                    return this.shadowColor
                }
                var g = this.resolveEffectiveStyle(c.Style.prototype.hasShadowColor);
                if (g) {
                    return g.getShadowColor()
                }
                return "gray"
            },
            getEffectiveHandlesSize: function() {
                if (this.handlesSize) {
                    return this.handlesSize
                }
                if (this.parent && this.parent.getAdjustmentHandlesSize) {
                    return this.parent.getAdjustmentHandlesSize()
                }
                return 2
            },
            getTextComponent: function() {
                return this.text
            },
            saveState: function() {
                var g = {};
                g.zIndex = this.getZIndex();
                g.tag = this.tag;
                g.text = this.getText();
                g.textColor = this.textColor;
                g.font = this.font;
                g.ignoreLayout = this.ignoreLayout;
                g.brush = this.brush;
                g.pen = this.pen;
                g.strokeThickness = this.strokeThickness;
                g.selected = this.selected;
                g.visible = this.getVisible();
                g.locked = this.getLocked();
                g.tooltip = this.tooltip;
                g.hyperLink = this.hyperLink;
                g.shadowColor = this.shadowColor;
                g.shadowOffsetX = this.getShadowOffsetX();
                g.shadowOffsetY = this.getShadowOffsetY();
                g.style = this.style;
                g.textAlignment = this.getTextAlignment();
                g.lineAlignment = this.getLineAlignment();
                return g
            },
            restoreState: function(g) {
                this.setZIndex(g.zIndex);
                this.setTag(g.tag);
                this.setText(g.text);
                this.setBrush(g.brush);
                this.setPen(g.pen);
                this.strokeThickness = g.strokeThickness;
                this.textColor = g.textColor;
                this.setVisible(g.visible);
                this.ignoreLayout = g.ignoreLayout;
                this.font = g.font;
                this.style = g.style;
                this.locked = g.locked;
                this.tooltip = g.tooltip;
                this.hyperLink = g.hyperLink;
                this.shadowColor = g.shadowColor;
                this.shadowOffsetX = g.shadowOffsetX;
                this.shadowOffsetY = g.shadowOffsetY;
                if (g.textAlignment) {
                    this.setTextAlignment(g.textAlignment)
                }
                if (g.lineAlignment) {
                    this.setLineAlignment(g.lineAlignment)
                }
            },
            millimeter: function() {
                if (this.parent) {
                    return MindFusion.Drawing.GraphicsUnit.getMillimeter(this.parent.measureUnit)
                }
                return 1
            }
        };
        a.useStyles = true;
        MindFusion.registerClass(a, "MindFusion.Diagramming.DiagramItem")
    })(MindFusion.Diagramming);
    (function(c) {
        var g = MindFusion.Drawing.GraphicsUnit;
        var e = MindFusion.Drawing.Point;
        var d = MindFusion.Drawing.Rect;
        var b = MindFusion.Collections.ArrayList;
        var a = c.DiagramNode = function(h) {
            mflayer.initializeBase(a, this, [h]);
            this.rotationAngle = 0;
            this.enabledHandles = c.AdjustmentHandles.All & ~c.AdjustmentHandles.Rotate;
            this.handlesStyle = c.HandlesStyle.SquareHandles;
            this.incomingLinks = [];
            this.outgoingLinks = [];
            this.allowIncomingLinks = true;
            this.allowOutgoingLinks = true;
            this.obstacle = true;
            this.anchorPattern = null;
            this.anchorPointVisuals = new b();
            this.isAnchorPatternVisible = false;
            this.expandable = false;
            this.expanded = true;
            this.showDeleteButton = false;
            this.nodeEffects = [];
            this.text.textAlignment = c.Alignment.Center;
            this.text.lineAlignment = c.Alignment.Center;
            if (h && h.nodesExpandable) {
                this.setExpandable(true)
            }
        };
        a.nodesIntersect = function(j, h) {
            if (!j.considerBounds() || !h.considerBounds()) {
                return false
            }
            var k = j.bounds.intersect(h.bounds);
            if (k.height > 0 && k.width > 0) {
                return true
            }
            return false
        };
        a.prototype = {
            clone: function() {
                var h = mflayer.callBaseMethod(a, this, "clone", []);
                h.rotationAngle = this.rotationAngle;
                h.enabledHandles = this.enabledHandles;
                h.handlesStyle = this.handlesStyle;
                h.allowIncomingLinks = this.allowIncomingLinks;
                h.allowOutgoingLinks = this.allowOutgoingLinks;
                h.obstacle = this.obstacle;
                h.anchorPattern = this.anchorPattern;
                h.setExpandable(this.expandable);
                h.expanded = this.expanded;
                h.allowIncomingLinks = this.allowIncomingLinks;
                h.allowOutgoingLinks = this.allowOutgoingLinks;
                h.obstacle = this.obstacle;
                h.nodeEffects = this.nodeEffects.slice(0);
                h.text = this.text.clone();
                h.setShowDeleteButton(this.showDeleteButton);
                return h
            },
            toJson: function() {
                var k = mflayer.callBaseMethod(a, this, "toJson", []);
                k.bounds = this.bounds;
                if (this.anchorPattern) {
                    k.anchorPattern = this.anchorPattern.toJson()
                }
                k.rotationAngle = this.rotationAngle;
                k.enabledHandles = this.enabledHandles;
                k.handlesStyle = this.handlesStyle;
                k.expanded = this.expanded;
                k.expandable = this.expandable;
                k.allowIncomingLinks = this.allowIncomingLinks;
                k.allowOutgoingLinks = this.allowOutgoingLinks;
                k.obstacle = this.obstacle;
                k.showDeleteButton = this.showDeleteButton;
                if (this.masterNode) {
                    k.master = this.masterNode.instanceId
                }
                if (this.container) {
                    k.container = this.container.instanceId
                }
                var n = [];
                for (var j = 0, h = this.nodeEffects.length; j < h; j++) {
                    if (this.nodeEffects[j] == null) {
                        n.push(null)
                    } else {
                        n.push(this.nodeEffects[j].toJson())
                    }
                }
                k.effects = n;
                return k
            },
            fromJson: function(n) {
                mflayer.callBaseMethod(a, this, "fromJson", [n]);
                this.setBounds(new d(n.bounds.x, n.bounds.y, n.bounds.width, n.bounds.height));
                if (n.anchorPattern) {
                    var q = n.anchorPattern.id;
                    var k;
                    if (q) {
                        k = c.AnchorPattern.fromId(q)
                    } else {
                        k = new c.AnchorPattern();
                        k.fromJson(n.anchorPattern)
                    }
                    k.serverRegistered = true;
                    this.setAnchorPattern(k)
                }
                this.setRotationAngle(n.rotationAngle);
                this.setEnabledHandles(n.enabledHandles);
                if (n.handlesStyle !== undefined) {
                    this.handlesStyle = n.handlesStyle
                }
                if (n.expanded !== undefined) {
                    this.expanded = n.expanded
                }
                if (n.expandable !== undefined) {
                    this.setExpandable(n.expandable)
                }
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                if (n.showDeleteButton !== undefined) {
                    this.setShowDeleteButton(n.showDeleteButton)
                }
                if (n.allowIncomingLinks !== undefined) {
                    this.setAllowIncomingLinks(n.allowIncomingLinks)
                }
                if (n.allowOutgoingLinks !== undefined) {
                    this.setAllowOutgoingLinks(n.allowOutgoingLinks)
                }
                if (n.obstacle !== undefined) {
                    this.setObstacle(n.obstacle)
                }
                if (n.master !== undefined) {
                    this.masterId = n.master
                }
                if (n.container !== undefined) {
                    this.containerId = n.container
                }
                this.nodeEffects = [];
                if (n.effects) {
                    for (var j = 0, h = n.effects.length; j < h; j++) {
                        if (n.effects[j] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var p = mflayer.parseType(n.effects[j].typeName);
                        if (p) {
                            var o = new p(this);
                            o.fromJson(n.effects[j]);
                            this.nodeEffects.push(o)
                        }
                    }
                }
            },
            loadFromXml: function(k, j) {
                mflayer.callBaseMethod(a, this, "loadFromXml", [k, j]);
                this.setBounds(j.readRectangleF("Bounds", k));
                this.setRotationAngle(j.readFloat("RotationAngle", k));
                this.anchorPattern = j.readAnchorPattern("AnchorPattern", k);
                this.obstacle = j.readBool("Obstacle", k, true);
                this.allowIncomingLinks = j.readBool("AllowIncomingLinks", k, true);
                this.allowOutgoingLinks = j.readBool("AllowOutgoingLinks", k, true);
                this.setShowDeleteButton(j.readBool("ShowDeleteButton", k, false));
                this.expanded = j.readBool("Expanded", k, true);
                this.setExpandable(j.readBool("Expandable", k));
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                this.enabledHandles = j.readInt("EnabledHandles", k, this.enabledHandles);
                this.handlesStyle = j.readInt("HandlesStyle", k, this.handlesStyle);
                var l = j.readGroup("SubordinateGroup", k);
                if (l) {
                    for (var h = 0; h < l.attachedNodes.length; h++) {
                        l.attachedNodes[h].attachTo(this)
                    }
                    for (var h = 0; h < l.children.length; h++) {
                        this.add(l.children[h])
                    }
                }
                this.loadEffects("Effects", k, j)
            },
            saveToXml: function(j, h) {
                mflayer.callBaseMethod(a, this, "saveToXml", [j, h]);
                h.writeRectangleF(this.getBounds(), "Bounds", j);
                h.writeFloat(this.getRotationAngle(), "RotationAngle", j);
                h.writeAnchorPattern(this.anchorPattern, "AnchorPattern", j);
                h.writeBool(this.obstacle, "Obstacle", j);
                h.writeBool(this.allowIncomingLinks, "AllowIncomingLinks", j);
                h.writeBool(this.allowOutgoingLinks, "AllowOutgoingLinks", j);
                h.writeBool(this.getShowDeleteButton(), "ShowDeleteButton", j);
                h.writeBool(this.expanded, "Expanded", j);
                h.writeBool(this.getExpandable(), "Expandable", j);
                h.writeInt(this.enabledHandles, "EnabledHandles", j);
                h.writeInt(this.handlesStyle, "HandlesStyle", j);
                var k = {
                    mainItem: this
                };
                if (this.attachedNodes && this.attachedNodes.length > 0) {
                    k.attachedNodes = this.getAttachedNodes()
                }
                if (this.children && this.children.length > 0) {
                    k.children = this.children
                }
                if (k.attachedNodes || k.children) {
                    h.writeGroup(k, "SubordinateGroup", j)
                }
                this.saveEffects("Effects", j, h)
            },
            loadEffects: function(h, j, o) {
                this.nodeEffects = [];
                var n = o.selectSingleNode("Effects", j);
                if (!n) {
                    return
                }
                var p = n.getElementsByTagName("Effect");
                for (var l = 0; l < p.length; l++) {
                    var k = p[l];
                    this.nodeEffects.push(o.readEffect(k))
                }
            },
            saveEffects: function(h, k, n) {
                var j = n.addChildElement(h, k);
                for (var l = 0; l < this.nodeEffects.length; l++) {
                    n.writeEffect(this.nodeEffects[l], Effect, k)
                }
            },
            onLoad: function(j) {
                mflayer.callBaseMethod(a, this, "onLoad", [j]);
                if (this.masterId !== undefined) {
                    this.attachTo(j[this.masterId]);
                    delete this.masterId
                }
                if (this.containerId !== undefined) {
                    var h = j[this.containerId];
                    h.children.push(this);
                    this.container = h;
                    delete this.containerId
                }
            },
            getIncomingLinks: function() {
                return this.incomingLinks
            },
            getOutgoingLinks: function() {
                return this.outgoingLinks
            },
            setAllowIncomingLinks: function(h) {
                if (this.allowIncomingLinks !== h) {
                    this.allowIncomingLinks = h;
                    this.setDiagramDirty()
                }
            },
            getAllowIncomingLinks: function() {
                return this.allowIncomingLinks
            },
            setAllowOutgoingLinks: function(h) {
                if (this.allowOutgoingLinks !== h) {
                    this.allowOutgoingLinks = h;
                    this.setDiagramDirty()
                }
            },
            getAllowOutgoingLinks: function() {
                return this.allowOutgoingLinks
            },
            acceptLinks: function(h) {
                if (h && !this.allowOutgoingLinks) {
                    return false
                }
                if (!h && !this.allowIncomingLinks) {
                    return false
                }
                return true
            },
            setRotationAngle: function(h, j) {
                if (this.rotationAngle != h) {
                    this.invalidate();
                    this.rotationAngle = h;
                    if (this.parent) {
                        if (j) {
                            this.updateLinks()
                        }
                        if (this.anchorPattern) {
                            this.updateAnchorPositions2()
                        }
                    }
                    if (this.getExpandable()) {
                        this.expandButton.updateLocation()
                    }
                    this.invalidate()
                }
            },
            getRotationAngle: function() {
                return this.rotationAngle
            },
            raiseClicked: function(k, h) {
                var j = new c.NodeEventArgs({
                    node: this,
                    mousePosition: k,
                    mouseButton: h
                });
                this.parent.raiseEvent(c.Events.nodeClicked, j);
                return j.getHandled()
            },
            raiseDoubleClicked: function(k, h) {
                var j = new c.NodeEventArgs({
                    node: this,
                    mousePosition: k,
                    mouseButton: h
                });
                this.parent.raiseEvent(c.Events.nodeDoubleClicked, j);
                return j.getHandled()
            },
            createConnectionPoint: function(k, h, j) {
                var l = new c.ConnectionPoint(this, k, j);
                l.anchorPointDetails.point = h;
                return l
            },
            addIncomingLink: function(h) {
                if (!b.contains(this.incomingLinks, h)) {
                    this.incomingLinks.push(h)
                }
            },
            addOutgoingLink: function(h) {
                if (!b.contains(this.outgoingLinks, h)) {
                    this.outgoingLinks.push(h)
                }
            },
            removeIncomingLink: function(h) {
                b.remove(this.incomingLinks, h)
            },
            removeOutgoingLink: function(h) {
                b.remove(this.outgoingLinks, h)
            },
            getAllIncomingLinks: function(h) {
                for (var j = 0; j < this.incomingLinks.length; j++) {
                    if (h.indexOf(this.incomingLinks[j]) === -1) {
                        h.push(this.incomingLinks[j])
                    }
                }
            },
            getAllOutgoingLinks: function(h) {
                for (var j = 0; j < this.outgoingLinks.length; j++) {
                    if (h.indexOf(this.outgoingLinks[j]) === -1) {
                        h.push(this.outgoingLinks[j])
                    }
                }
            },
            getAllLinks: function() {
                var h = [];
                this.getAllIncomingLinks(h);
                this.getAllOutgoingLinks(h);
                return h
            },
            deleteLinks: function() {
                if (this.parent) {
                    var h = [];
                    this.getAllIncomingLinks(h);
                    this.getAllOutgoingLinks(h);
                    for (var j = 0; j < h.length; j++) {
                        this.parent.removeItem(h[j])
                    }
                }
            },
            updateDrag: function(j) {
                var h = j.originalStates.get(this);
                if (h == null) {
                    return
                }
                var l = h.bounds;
                var k = this.updateRect(l, this.bounds, j);
                this.setBounds(k, false);
                this.updateAnchorVisibility4()
            },
            endDrag: function(j) {
                var h = j.originalStates.get(this);
                if (h == null) {
                    return
                }
                var k = h.bounds;
                if (this.obstacle) {
                    this.parent.routeLinksAt([k, this.bounds])
                }
                if (this.container) {
                    this.container.onChildModified(this, j.adjustmentHandle.index)
                }
            },
            allowDrag: function(h) {
                if (this.parent) {
                    return this.parent.onItemDragging(this, h.currentPoint)
                }
                return true
            },
            onDragOver: function(h) {
                return false
            },
            onDragOut: function(h) {},
            saveLocationState: function() {
                return {
                    bounds: this.bounds,
                    rotationAngle: this.rotationAngle
                }
            },
            restoreLocationState: function(h) {
                this.invalidate();
                var j = h.originalStates.get(this);
                if (j != null) {
                    this.setBounds(j.bounds)
                }
            },
            updateLinks: function() {
                var j = this.getAllLinks();
                for (var k = 0, h = j.length; k < h; k++) {
                    var n = j[k];
                    n.updatePosFromOrgAndDest()
                }
            },
            setBounds: function(h, j) {
                if (j) {
                    this.setBoundsWithRules(h)
                } else {
                    this.setBoundsImpl(h)
                }
            },
            setBoundsWithRules: function(h, k) {
                var j = new c.DiagramMediator(this);
                if (k) {
                    j.rules = k
                }
                this.setBoundsImpl(h);
                j.updateDependencies()
            },
            setBoundsWithRules2: function(j, k, h) {
                if (k && h) {
                    this.setBounds(j, true)
                } else {
                    if (k) {
                        this.setBoundsWithRules(j, c.DiagramMediator.LinkRules)
                    } else {
                        if (h) {
                            this.setBoundsWithRules(j, c.DiagramMediator.GroupRules)
                        } else {
                            this.setBounds(j, false)
                        }
                    }
                }
            },
            setBoundsImpl: function(h) {
                this.invalidate();
                var j = this.bounds;
                this.bounds = h;
                this.updateAnchorPositions2();
                this.updateManipulators();
                this.invalidate();
                this.onUpdateBounds();
                if (j.width != this.bounds.width) {
                    this.textCacheInvalid = true
                }
            },
            getBounds: function() {
                return this.bounds
            },
            onUpdateBounds: function() {
                if (this.parent && this.parent.invalidateLabelLayout) {
                    this.parent.invalidateLabelLayout(this.getRepaintBounds())
                }
            },
            setCenterAndSize: function(r, n, k, q, l) {
                var j = r.width;
                var o = r.height;
                var p = new d(r.x - j / 2 + n, r.y - o / 2 + k, j, o);
                this.setBoundsWithRules2(p, q, l)
            },
            move: function(n, k, q, l) {
                var j = this.bounds.width;
                var o = this.bounds.height;
                var p = new d(n, k, j, o);
                this.setBoundsWithRules2(p, q, l)
            },
            updateRect: function(l, q, r) {
                var t = r.currentPoint.clone();
                var k = r.startPoint.clone();
                if (r.adjustmentHandle.index === 8) {
                    return this.updateRectMove(l, t, r)
                }
                if (r.action == c.Action.Modify) {
                    var p = r.adjustmentHandle.item;
                    if (p.rotationAngle) {
                        var j = r.originalStates;
                        if (j != null) {
                            var z = j.get(p).bounds;
                            t = c.Utils.rotatePointAt(t, z.center(), -p.rotationAngle);
                            k = c.Utils.rotatePointAt(k, z.center(), -p.rotationAngle)
                        }
                    }
                    var w = c.Utils.subtract(t, k);
                    var n = g.getMillimeter(this.parent.measureUnit);
                    var o = c.HandleUtils.getHandlePositions(l, n);
                    t = o[r.adjustmentHandle.index];
                    t.addVector(w)
                }
                if (this.parent.alignToGrid && !this.rotationAngle) {
                    t = this.parent.alignResize(this, t, r.adjustmentHandle)
                }
                var h = l;
                var v = h.center();
                switch (r.adjustmentHandle.index) {
                    case 0:
                        h = this.makeRect(t.x, t.y, h.right(), h.bottom());
                        break;
                    case 1:
                        h = this.makeRect(h.x, t.y, t.x, h.bottom());
                        break;
                    case 2:
                        h = this.makeRect(h.x, h.y, t.x, t.y);
                        break;
                    case 3:
                        h = this.makeRect(t.x, h.y, h.right(), t.y);
                        break;
                    case 4:
                        h = this.makeRect(h.x, t.y, h.right(), h.bottom());
                        break;
                    case 5:
                        h = this.makeRect(h.x, h.y, t.x, h.bottom());
                        break;
                    case 6:
                        h = this.makeRect(h.x, h.y, h.right(), t.y);
                        break;
                    case 7:
                        h = this.makeRect(t.x, h.y, h.right(), h.bottom());
                        break
                }
                if (h.width === 0) {
                    h.width = this.parent.alignToGrid ? this.parent.gridSizeX : g.getPixel(this.parent.measureUnit)
                }
                if (h.height === 0) {
                    h.height = this.parent.alignToGrid ? this.parent.gridSizeY : g.getPixel(this.parent.measureUnit)
                }
                if (this.rotationAngle !== 0) {
                    var u = new e(h.x, h.y);
                    var s = new e(h.right(), h.bottom());
                    u = c.Utils.rotatePointAt(u, v, this.rotationAngle);
                    s = c.Utils.rotatePointAt(s, v, this.rotationAngle);
                    v = new e((u.x + s.x) / 2, (u.y + s.y) / 2);
                    u = c.Utils.rotatePointAt(u, v, -this.rotationAngle);
                    s = c.Utils.rotatePointAt(s, v, -this.rotationAngle);
                    h = d.fromPoints(u, s)
                }
                return h
            },
            updateRectMove: function(p, s, q) {
                if (this.parent.alignToGrid) {
                    var h = q.originalStates;
                    if (h == null) {
                        return p
                    }
                    var v = h.get(this).bounds;
                    var j = c.Utils.offset(v, c.Utils.subtract(s, q.startPoint));
                    var k = new e(0, 0);
                    if (this.rotationAngle !== 0) {
                        var r = this.getRotatedBounds1(j, c.Utils.getCenter(j), this.rotationAngle);
                        k = c.Utils.subtract(r.topLeft(), j.topLeft());
                        j = r
                    }
                    var o = this.parent.alignMove(this, j);
                    o.x -= k.x;
                    o.y -= k.y;
                    var u = o
                } else {
                    var t = c.Utils.subtract(s, q.startPoint);
                    var u = p.topLeft().addVector(t)
                }
                var n = this.checkKeepInsideParent();
                var l = new d(u.x, u.y, p.width, p.height);
                return (n) ? l : this.bounds
            },
            checkKeepInsideParent: function() {
                return true
            },
            getHandlePosition: function(k, j) {
                if (j == null) {
                    j = this.bounds
                }
                var h = this.nonRotatedHandlePosition(k, j);
                if (this.rotationAngle !== 0) {
                    h = c.Utils.rotatePointAt(h, j.center(), this.rotationAngle)
                }
                return h
            },
            handleAtPoint: function(h) {
                if (!this.parent) {
                    return null
                }
                if (this.handlesStyle == c.HandlesStyle.Custom) {
                    var j = this.parent.raiseHitTestAdjustmentHandles(this, h);
                    return j !== undefined ? {
                        item: this,
                        index: j
                    } : null
                }
                return c.HandleUtils.pointInHandle(h, this)
            },
            nonRotatedHandlePosition: function(n, l) {
                if (l == null) {
                    l = this.bounds
                }
                var j = l.topLeft();
                var k = l.bottomRight();
                var h = l.center();
                switch (n) {
                    case 0:
                        return j;
                    case 1:
                        return new e(k.x, j.y);
                    case 2:
                        return k;
                    case 3:
                        return new e(j.x, k.y);
                    case 4:
                        return new e(h.x, j.y);
                    case 5:
                        return new e(k.x, h.y);
                    case 6:
                        return new e(h.x, k.y);
                    case 7:
                        return new e(j.x, h.y);
                    case 8:
                        return h;
                    case 9:
                        return new e(h.x, j.y - g.getPixel(this.parent.measureUnit) * 6)
                }
                return h
            },
            containsPoint: function(h) {
                return this.bounds.containsPoint(h)
            },
            getCenter: function() {
                return new e((this.bounds.x + (this.bounds.x + this.bounds.width)) / 2, (this.bounds.y + (this.bounds.y + this.bounds.height)) / 2)
            },
            getRotatedBounds: function() {
                return this.getRotatedBounds1(this.bounds)
            },
            getRotatedBounds1: function(j) {
                var n = [];
                n.push(j.topLeft());
                n.push(j.topRight());
                n.push(j.bottomRight());
                n.push(j.bottomLeft());
                c.Utils.rotatePointsAt(n, c.Utils.getCenter(j), this.rotationAngle);
                var h = Math.min(n[0].x, Math.min(n[1].x, Math.min(n[2].x, n[3].x)));
                var o = Math.min(n[0].y, Math.min(n[1].y, Math.min(n[2].y, n[3].y)));
                var l = Math.max(n[0].x, Math.max(n[1].x, Math.max(n[2].x, n[3].x)));
                var k = Math.max(n[0].y, Math.max(n[1].y, Math.max(n[2].y, n[3].y)));
                return d.fromLTRB(h, o, l, k)
            },
            getIntersection: function(k, j) {
                if (k.equals(j)) {
                    return k.clone()
                }
                var h = this.getCenter();
                if (this.bounds.width !== 0 && this.bounds.height !== 0) {
                    if (this.bounds.containsPoint(k) && this.bounds.containsPoint(j)) {
                        return h
                    }
                    c.Utils.getPolygonIntersection(this.getOutline(), k, j, h)
                }
                return h
            },
            getTopIntr: function(k) {
                var n = this.getRotatedBounds();
                var j = new e(n.left(), (n.top() + n.bottom()) / 2);
                j.x += k * n.width;
                var l = new e(j.x, j.y - 3 * Math.abs(this.bounds.height));
                var h = this.getIntersection(l, j);
                if (!n.contains(h)) {
                    h = new e(n.left() + n.width * k, n.top())
                }
                return h
            },
            intersects: function(j) {
                var h = this.getRotatedBounds();
                return h.intersectsWith(j)
            },
            makeRect: function(j, l, h, k) {
                return new d.fromLTRB(j, l, h, k)
            },
            considerBounds: function() {
                return true
            },
            sortHandles: function(j, h) {
                return j.d - h.d
            },
            getAnchor: function(h, k, j) {
                var l = this.getNearestAnchor(h, k, j);
                if (l.index === -1) {
                    return null
                }
                return l
            },
            getAnchorFromIndex: function(l, j) {
                if (this.anchorPattern == null) {
                    return
                }
                var p = this.anchorPattern.getPoints();
                if (l < 0 || l >= p.length) {
                    return
                }
                var n = p[l];
                var o = MindFusion.Diagramming.Utils.rectPtFromPercent(new e(n.x, n.y), this.bounds);
                var h = [o];
                if (this.rotationAngle !== 0) {
                    var k = this.rotateRect(this.bounds);
                    k.transformPoints(h)
                }
                return {
                    index: l,
                    point: h[0],
                    location: c.Utils.getRectPtPercent(h[0], this.bounds)
                }
            },
            getNearestAnchor: function(s, q, l) {
                var r = this.getNearestBorderPoint(s);
                if (this.anchorPattern == null) {
                    return {
                        index: 0,
                        point: r,
                        location: r
                    }
                }
                var t = [];
                var o = [];
                var v = [];
                var u = this.anchorPattern.getPoints();
                for (var n = 0; n < u.length; n++) {
                    var h = u[n];
                    if (l && !h.getAllowIncoming()) {
                        continue
                    }
                    if (!l && !h.getAllowOutgoing()) {
                        continue
                    }
                    var w = MindFusion.Diagramming.Utils.rectPtFromPercent(new e(h.x, h.y), this.bounds);
                    o.push(w);
                    v.push(n)
                }
                if (this.rotationAngle !== 0) {
                    var k = this.rotateRect(this.bounds);
                    k.transformPoints(o)
                }
                for (var n = 0; n < o.length; n++) {
                    var j = o[n];
                    var p = v[n];
                    t.push({
                        p: j,
                        d: s.distance(j),
                        i: p
                    })
                }
                t.sort(this.sortHandles);
                if (t.length > 0) {
                    return {
                        index: t[0].i,
                        point: t[0].p,
                        location: c.Utils.getRectPtPercent(t[0].p, this.bounds)
                    }
                } else {
                    return {
                        index: 0,
                        point: r,
                        location: r
                    }
                }
            },
            removeCanvasElements: function() {
                this.removeAnchorPointVisuals(this.anchorPointVisuals);
                mflayer.callBaseMethod(a, this, "removeCanvasElements", [])
            },
            getHandlePositions: function() {
                var o = this.bounds;
                var k = o.topLeft();
                var n = o.bottomRight();
                var h = o.center();
                var j = [];
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeTopLeft) !== 0) {
                    j.push(k)
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeTopRight) !== 0) {
                    j.push(o.topRight())
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeBottomRight) !== 0) {
                    j.push(n)
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeBottomLeft) !== 0) {
                    j.push(o.bottomLeft())
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeTopCenter) !== 0) {
                    j.push(new e(h.x, k.y))
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeMiddleRight) !== 0) {
                    j.push(new e(n.x, h.y))
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeBottomCenter) !== 0) {
                    j.push(new e(h.x, n.y))
                }
                if ((this.enabledHandles & c.AdjustmentHandles.ResizeMiddleLeft) !== 0) {
                    j.push(new e(k.x, h.y))
                }
                if ((this.enabledHandles & c.AdjustmentHandles.Move) !== 0) {
                    j.push(h)
                }
                if ((this.enabledHandles & c.AdjustmentHandles.Rotate) !== 0) {
                    j.push(new e(h.x, k.y - g.getMillimeter(this.parent.measureUnit) * 6))
                }
                if (this.rotationAngle !== 0) {
                    var l = this.rotateRect(this.bounds);
                    l.transformPoints(j)
                }
                return j
            },
            rotateRect: function(j) {
                var h = new MindFusion.Drawing.Matrix();
                h.rotateAt(this.rotationAngle, j.center().x, j.center().y);
                return h
            },
            removeRotation: function(h) {
                if (this.rotationAngle != 0) {
                    var j = this.getBounds().center();
                    return c.Utils.rotatePointAt(h, j, -this.rotationAngle)
                }
                return h
            },
            adjustRepaintBounds: function(n) {
                if (this.textCacheInvalid) {
                    this.textCacheInvalid = false;
                    this._mf_lineWidth = 0;
                    if (this.parent && this.textOverflows && this.text && !this.text.enableStyledText) {
                        this._mf_lineWidth = this.parent.measureTextLines(this.text, this.bounds);
                        this._mf_lineWidth += this.text.font.size
                    }
                }
                if ((this.getEnabledHandles() & c.AdjustmentHandles.Rotate) != 0) {
                    var l = this.bounds;
                    var k = new e(l.centerX(), l.top() - 7 * this.millimeter());
                    if (this.rotationAngle !== 0) {
                        k = c.Utils.rotatePointAt(k, l.center(), this.rotationAngle)
                    }
                    var h = 1.4 * this.getEffectiveHandlesSize() / 2;
                    var o = d.fromCenterAndSize(k, {
                        width: h,
                        height: h
                    });
                    n = n.union(o)
                }
                if (this.expandButton) {
                    n = n.union(this.expandButton.getRect());
                    n.width += this.millimeter()
                }
                if (this._mf_lineWidth && n.width < this._mf_lineWidth) {
                    var j = this._mf_lineWidth - n.width;
                    n.x -= j / 2;
                    n.width += j
                }
                return n
            },
            drawHandles: function(h) {
                h.save();
                var j = this.bounds;
                h.translate(j.x + j.width / 2, j.y + j.height / 2);
                h.rotate(c.Utils.radians(this.rotationAngle));
                h.translate(-j.x - j.width / 2, -j.y - j.height / 2);
                if (this.handlesStyle == c.HandlesStyle.Custom) {
                    this.parent.raiseDrawAdjustmentHandles(this, h)
                } else {
                    c.HandleUtils.drawAdjustmentHandles(h, this)
                }
                h.restore()
            },
            setEnabledHandles: function(h) {
                if (this.enabledHandles != h) {
                    this.enabledHandles = h;
                    this.invalidate()
                }
            },
            getEnabledHandles: function() {
                return this.enabledHandles
            },
            setHandlesStyle: function(h) {
                if (this.handlesStyle != h) {
                    this.handlesStyle = h;
                    this.invalidate()
                }
            },
            getHandlesStyle: function() {
                return this.handlesStyle
            },
            setObstacle: function(h) {
                if (this.obstacle !== h) {
                    this.obstacle = h;
                    this.setDiagramDirty()
                }
            },
            getObstacle: function() {
                return this.obstacle
            },
            setExpandable: function(h) {
                if (this.expandable != h) {
                    this.expandable = h;
                    if (h) {
                        this.expandButton = new c.ExpandButton(this);
                        this.addManipulator(this.expandButton)
                    } else {
                        this.removeManipulator(this.expandButton);
                        delete this.expandButton
                    }
                }
            },
            getExpandable: function() {
                return this.expandable
            },
            setExpanded: function(h) {
                if (this.expanded != h) {
                    if (h) {
                        this.expand()
                    } else {
                        this.collapse()
                    }
                }
            },
            getExpanded: function() {
                return this.expanded
            },
            setShowDeleteButton: function(h) {
                if (this.showDeleteButton != h) {
                    this.showDeleteButton = h;
                    if (h) {
                        this.deleteButton = new c.DeleteButton(this);
                        this.addManipulator(this.deleteButton)
                    } else {
                        this.removeManipulator(this.deleteButton);
                        delete this.deleteButton
                    }
                }
            },
            getShowDeleteButton: function() {
                return this.showDeleteButton
            },
            addManipulator: function(h) {
                if (!this.manipulators) {
                    this.manipulators = new b()
                }
                this.manipulators.push(h);
                this.graphicsContainer.content.push(h);
                this.invalidate(false)
            },
            removeManipulator: function(h) {
                if (!this.manipulators) {
                    return
                }
                this.manipulators.remove(h);
                b.remove(this.graphicsContainer.content, h);
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            updateManipulators: function() {
                if (!this.manipulators) {
                    return
                }
                this.manipulators.forEach(function(h) {
                    h.updateLocation()
                })
            },
            hitTestManipulators: function(k) {
                if (!this.manipulators) {
                    return null
                }
                for (var j = 0; j < this.manipulators.length; j++) {
                    var h = this.manipulators[j];
                    if (h.hitTest(k)) {
                        return h
                    }
                }
                return null
            },
            addManipulatorVisuals: function(h) {
                if (this.manipulators) {
                    this.manipulators.forEach(function(j) {
                        h.push(j)
                    })
                }
            },
            collapse: function(j) {
                if (j) {
                    if (j.contains(this)) {
                        return
                    }
                    j.add(this);
                    this.setVisible(false);
                    if (this.selected && this.parent) {
                        this.parent.selection.removeItem(this)
                    }
                    if (!this.expanded) {
                        return
                    }
                } else {
                    j = this.collapsedSet = new MindFusion.Collections.Set();
                    j.add(this);
                    this.expanded = false;
                    if (this.expandButton) {
                        this.expandButton.updateContent()
                    }
                    if (this.parent) {
                        this.parent.invalidate()
                    }
                }
                var h = [];
                if (this.parent.expandOnIncoming) {
                    this.getAllIncomingLinks(h)
                } else {
                    this.getAllOutgoingLinks(h)
                }
                b.forEach(h, function(k) {
                    k.collapse(j)
                })
            },
            expand: function() {
                this.expanded = true;
                if (this.expandButton) {
                    this.expandButton.updateContent()
                }
                if (this.parent) {
                    this.parent.invalidate()
                }
                if (this.collapsedSet) {
                    this.collapsedSet.forEach(function(j) {
                        j.setVisible(true)
                    });
                    delete this.collapsedSet
                } else {
                    var h = [];
                    if (parent.expandOnIncoming) {
                        this.getAllIncomingLinks(h);
                        b.forEach(h, function(k) {
                            k.setVisible(true);
                            var j = k.getOrigin();
                            j.setVisible(true);
                            if (j.expandButton) {
                                j.expanded = false;
                                j.expandButton.updateContent()
                            }
                        })
                    } else {
                        this.getAllOutgoingLinks(h);
                        b.forEach(h, function(k) {
                            k.setVisible(true);
                            var j = k.getDestination();
                            j.setVisible(true);
                            if (j.expandButton) {
                                j.expanded = false;
                                j.expandButton.updateContent()
                            }
                        })
                    }
                }
            },
            setProperty: function(j, h, k) {
                switch (j) {
                    default:
                        mflayer.callBaseMethod(a, this, "setProperty", [j, h, k]);
                        break
                }
            },
            getOutline: function() {
                return this.bounds.getCornerPoints()
            },
            getNearestBorderPoint: function(h) {
                var j = this.getOutline();
                if (j.length == 0) {
                    return this.bounds.center()
                }
                j.push(j[0].clone());
                var k = {
                    value: 0
                };
                c.Utils.distToPolyline(h, j, j.length, k);
                return c.Utils.getClosestSegmentPoint(h, j[k.value], j[k.value + 1])
            },
            getAnchorPattern: function() {
                return this.anchorPattern
            },
            setAnchorPattern: function(h) {
                if (this.anchorPattern != null) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals)
                }
                this.anchorPattern = h;
                this.updateAnchorVisibility4();
                this.invalidate()
            },
            addAnchorPointVisuals: function(o, n, j) {
                if (o == null) {
                    return
                }
                this.isAnchorPatternVisible = true;
                for (var k = 0; k < o.getPoints().length; k++) {
                    var l = o.getPoints()[k];
                    var h = this.createAnchorPointVisual(l);
                    if (!h) {
                        continue
                    }
                    this.parent.addElement(h);
                    n.push(h)
                }
            },
            removeAnchorPointVisuals: function(j) {
                if (j == null) {
                    return
                }
                this.isAnchorPatternVisible = false;
                this.invalidate();
                var h = j.pop();
                while (h) {
                    this.parent.removeElement(h);
                    h = j.pop()
                }
            },
            createAnchorPointVisual: function(s) {
                var h = this.bounds;
                var j = 1;
                if (s) {
                    j = s.getSize()
                }
                var z = MindFusion.Diagramming.Utils.rectPtFromPercent(new e(s.getX(), s.getY()), h);
                var o;
                if (this.rotationAngle !== 0) {
                    var k = c.Utils.rotatePointAt(z, h.center(), this.rotationAngle);
                    o = MindFusion.Diagramming.Utils.newRect(k, j)
                } else {
                    o = MindFusion.Diagramming.Utils.newRect(z, j)
                }
                var n = o.x;
                var u = o.y;
                var w = s.getSize();
                var q = w / 2;
                var r = MindFusion.Diagramming.Utils.stringFormat;
                var v;
                switch (s.getMarkStyle()) {
                    case MindFusion.Diagramming.MarkStyle.Cross:
                        var p = "M{0},{1} L{2},{1} M{3},{4} L{3},{5}";
                        p = r(p, n, (u + q), (n + w), (n + q), u, (u + w));
                        v = new MindFusion.Drawing.Path(p);
                        break;
                    case MindFusion.Diagramming.MarkStyle.X:
                        var p = "M{0},{1} L{2},{3} M{0},{3} L{2},{1}";
                        p = r(p, n, u, n + w, u + w);
                        v = new MindFusion.Drawing.Path(p);
                        break;
                    case MindFusion.Diagramming.MarkStyle.Circle:
                        v = new MindFusion.Drawing.Arc(n + q, u + q, q, 0, 360, 0);
                        break;
                    case MindFusion.Diagramming.MarkStyle.Rectangle:
                        v = new d(n, u, w, w);
                        break;
                    case MindFusion.Diagramming.MarkStyle.None:
                        return
                }
                v.pen = s.getColor();
                v.brush = "transparent";
                return v
            },
            updateAnchorVisibility4: function() {
                if (this.parent && this.parent.getAutoAnchorsNode) {
                    this.updateAnchorVisibility(this.parent.getAutoAnchorsNode())
                }
            },
            updateAnchorVisibility2: function(h) {
                this.updateAnchorVisibility3(this.anchorPattern, this.anchorPointVisuals, h)
            },
            updateAnchorVisibility3: function(j, l, h) {
                if (this.anchorPattern == null) {
                    return
                }
                var k = j.getPoints();
                if (this.isAnchorPatternVisible && !h) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals)
                }
                if (!this.isAnchorPatternVisible && h) {
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
                if (this.isAnchorPatternVisible && h) {
                    this.removeAnchorPointVisuals(this.anchorPointVisuals);
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
            },
            updateAnchorVisibility: function(h) {
                this.updateAnchorVisibility2(this.calcAnchorVisibility(h))
            },
            calcAnchorVisibility: function(h) {
                if (this.parent == null || !this.getVisible()) {
                    return false
                }
                var k = this.parent.getShowAnchors();
                var j = h == this || k == MindFusion.Diagramming.ShowAnchors.Always || this.getSelected() && k == MindFusion.Diagramming.ShowAnchors.Selected;
                return j
            },
            updateAnchorPositions2: function() {
                if (this.anchorPattern == null) {
                    return
                }
                this.removeAnchorPointVisuals(this.anchorPointVisuals);
                if (!this.parent || !this.parent.getAutoAnchorsNode) {
                    return
                }
                if (this.calcAnchorVisibility(this.parent.getAutoAnchorsNode())) {
                    this.addAnchorPointVisuals(this.anchorPattern, this.anchorPointVisuals, true)
                }
            },
            getAnchorPointPos: function(h) {
                var j = 1;
                if (pointVisual) {
                    j = pointVisual.getBounds().width
                }
                return MindFusion.Diagramming.Utils.rectPtFromPercent(new e(apt.x, apt.y), this.getBounds())
            },
            getAnchorRect: function() {
                return this.bounds.getSizeRect()
            },
            attachTo: function(h) {
                h.attach(this)
            },
            detach: function() {
                if (this.masterNode) {
                    this.masterNode.detachSub(this);
                    this.setDiagramDirty()
                }
            },
            attach: function(h) {
                if (!this.attachedNodes) {
                    this.attachedNodes = new b()
                }
                this.attachedNodes.push(h);
                h.attachment = {
                    offsetX: h.bounds.x - this.bounds.x,
                    offsetY: h.bounds.y - this.bounds.y
                };
                h.masterNode = this;
                this.setDiagramDirty()
            },
            detachSub: function(h) {
                if (!this.attachedNodes) {
                    return
                }
                if (h.masterNode == this) {
                    this.attachedNodes.remove(h);
                    delete h.attachment;
                    delete h.masterNode
                }
            },
            getMasterNode: function() {
                return this.masterNode
            },
            getAttachedNodes: function() {
                if (!this.attachedNodes) {
                    return []
                }
                var h = [];
                this.attachedNodes.forEach(function(j) {
                    h.push(j)
                });
                return h
            },
            getTopLevel: function() {
                if (!MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    return true
                }
                var h = this.getAbsoluteMaster();
                if (h) {
                    return mflayer.callBaseMethod(a, h, "getTopLevel", [])
                }
                return mflayer.callBaseMethod(a, this, "getTopLevel", [])
            },
            getAbsoluteMaster: function() {
                var j = f++;
                var h = this.masterNode;
                while (h != null && h.masterNode != null) {
                    if (h == this) {
                        break
                    }
                    if (h.__currentSearch == j) {
                        break
                    }
                    h.__currentSearch = j;
                    h = h.masterNode
                }
                return h
            },
            getEditRect: function(h) {
                return this.getRotatedBounds()
            },
            createEditArgs: function(h, j) {
                return new c.NodeEventArgs({
                    node: this,
                    oldText: h,
                    newText: j
                })
            },
            onDropOver: function(h) {
                return false
            },
            onHide: function() {
                this.removeAnchorPointVisuals(this.anchorPointVisuals)
            },
            onShow: function() {
                if (this.anchorPattern) {
                    this.updateAnchorVisibility4()
                }
            },
            getLayoutMaster: function(h) {
                if (this.container) {
                    return this.container
                }
                if (h && this.masterNode) {
                    return this.masterNode
                }
                return null
            },
            resolveInheritedStyle: function(j, k) {
                var h = k.styles["std:DiagramNode"];
                if (h) {
                    if (j.apply(h)) {
                        return h
                    }
                }
                return mflayer.callBaseMethod(a, this, "resolveInheritedStyle", [j, k])
            },
            getEffects: function() {
                if (this.nodeEffects === undefined) {
                    this.nodeEffects = []
                }
                return this.nodeEffects
            },
            getEffectiveEffects: function() {
                if (this.nodeEffects && this.nodeEffects.length) {
                    return this.nodeEffects
                }
                var h = this.resolveEffectiveStyle(c.Style.prototype.hasNodeEffects);
                if (h) {
                    return h.getNodeEffects()
                }
                return []
            },
            applyEffects: function(n, p) {
                if (!this.parent) {
                    return
                }
                p.isEllipse = this.shape && this.shape.isElliptic && this.shape.isElliptic();
                p.unitsPerPixel = g.getPixel(this.parent.measureUnit);
                var j = this.getEffectiveEffects();
                var q = j.length > 0 && j[0] == null;
                if (!q) {
                    if (this.parent.getEffectiveNodeEffects) {
                        var o = this.parent.getEffectiveNodeEffects();
                        for (var k = 0, h = o.length; k < h; k++) {
                            if (o[k] != null) {
                                o[k].apply(this, n, p)
                            }
                        }
                    }
                }
                for (var k = 0, h = j.length; k < h; k++) {
                    if (j[k] != null) {
                        j[k].apply(this, n, p)
                    }
                }
            },
            updateAnimation: function(k, j) {
                var h = this.bounds;
                var l = k.getFromValue() + (k.getToValue() - k.getFromValue()) * j;
                this.setBounds(new d(h.x, l, h.width, h.height), true)
            },
            saveState: function() {
                var h = mflayer.callBaseMethod(a, this, "saveState", []);
                h.bounds = this.bounds.clone();
                h.anchorPattern = this.anchorPattern;
                h.rotationAngle = this.rotationAngle;
                h.enabledHandles = this.enabledHandles;
                h.handlesStyle = this.handlesStyle;
                h.expanded = this.expanded;
                h.expandable = this.expandable;
                h.allowIncomingLinks = this.allowIncomingLinks;
                h.allowOutgoingLinks = this.allowOutgoingLinks;
                h.obstacle = this.obstacle;
                h.master = this.masterNode;
                h.container = this.container;
                h.nodeEffects = this.nodeEffects;
                return h
            },
            restoreState: function(h) {
                mflayer.callBaseMethod(a, this, "restoreState", [h]);
                this.setBounds(h.bounds);
                this.setAnchorPattern(h.anchorPattern);
                this.setRotationAngle(h.rotationAngle);
                this.setEnabledHandles(h.enabledHandles);
                this.handlesStyle = h.handlesStyle;
                this.setExpanded(h.expanded);
                this.setExpandable(h.expandable);
                this.setAllowIncomingLinks(h.allowIncomingLinks);
                this.setAllowOutgoingLinks(h.allowOutgoingLinks);
                this.setObstacle(h.obstacle);
                this.masterId = h.master;
                this.containerId = h.container;
                this.nodeEffects = h.nodeEffects
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.DiagramNode", c.DiagramItem);
        var f = 0
    })(MindFusion.Diagramming);
    (function(c) {
        var b = MindFusion.Drawing.Container;
        var a = MindFusion.Drawing.Size;
        var d = MindFusion.Drawing.Rect;
        var f = MindFusion.Drawing.LayoutAlignment;
        var e = MindFusion.Drawing.Thickness;
        var h = MindFusion.Drawing.Visibility;
        var g = c.Panel = function() {
            mflayer.initializeBase(g, this);
            this.content = this.children = []
        };
        g.prototype = {
            getComponents: function() {
                return this.children
            },
            measure: function(k, j) {
                this.measureMax = k;
                for (var n = 0; n < this.children.length; n++) {
                    var l = this.children[n];
                    l.parent = this
                }
            },
            measureChild: function(l, k, j) {
                if (l.measure) {
                    l.measure(k, j);
                    return new a(this.desiredWidthMargins(l), this.desiredHeightMargins(l))
                }
                return new a(null, null)
            },
            arrangeChild: function(o, j, n, k, l) {
                if (o.arrange) {
                    o.arrange(j, n, k, l)
                } else {
                    if (o.setBounds) {
                        o.setBounds(new d(j, n, k, l))
                    }
                }
            },
            childMeasuredWidth: function(j) {
                return j.effectiveMeasuredWidth ? j.effectiveMeasuredWidth() : null
            },
            childMeasuredHeight: function(j) {
                return j.effectiveMeasuredHeight ? j.effectiveMeasuredHeight() : null
            },
            desiredWidthMargins: function(l) {
                var j = this.childMeasuredWidth(l);
                var k = 0;
                if (l.margin) {
                    k = l.margin.width()
                }
                return j == null ? null : j + k
            },
            desiredHeightMargins: function(l) {
                var k = this.childMeasuredHeight(l);
                var j = 0;
                if (l.margin) {
                    j = l.margin.height()
                }
                return k == null ? null : k + j
            },
            canWrap: function(j) {
                return j.constructor == MindFusion.Drawing.Text
            },
            arrangeInRect: function(k, t, s, v, n) {
                var q = k.margin ? k.margin : new e(0, 0, 0, 0);
                var B = k.horizontalAlignment || f.Near;
                var p = k.verticalAlignment || f.Near;
                var j = v - q.width();
                var A = this.childMeasuredWidth(k);
                var u = A != null && A > j && this.canWrap(k);
                if (A != null && A < j && B != f.Stretch) {
                    j = A
                }
                var z = n - q.height();
                var o = this.childMeasuredHeight(k);
                if (o != null && o < z && !u && p != f.Stretch) {
                    z = o
                }
                var l = t;
                var r = s;
                switch (B) {
                    case f.Near:
                        l += q.left;
                        break;
                    case f.Center:
                        l += v / 2 - j / 2;
                        break;
                    case f.Far:
                        l += v - j - q.right;
                        break;
                    case f.Stretch:
                        l += q.left;
                        break
                }
                switch (p) {
                    case f.Near:
                        r += q.top;
                        break;
                    case f.Center:
                        r += n / 2 - z / 2;
                        break;
                    case f.Far:
                        r += n - z - q.bottom;
                        break;
                    case f.Stretch:
                        r += q.top;
                        break
                }
                this.arrangeChild(k, l, r, j, z)
            },
            hitTest: function(l) {
                var k = mflayer.callBaseMethod(g, this, "hitTest", [l]);
                if (k) {
                    var o = l.newWithOffset(-this.x, -this.y);
                    for (var q = this.children.length - 1; q >= 0; q--) {
                        var p = this.children[q];
                        var n = p.visibility;
                        if (typeof n == "undefined") {
                            n = h.Visible
                        }
                        if (n == h.Visible) {
                            if (p.hitTest) {
                                var j = p.hitTest(o);
                                if (j) {
                                    return j
                                }
                            }
                            if (p.getBounds) {
                                if (p.getBounds().containsPoint(o)) {
                                    return p
                                }
                            }
                        }
                    }
                }
                return k
            }
        };
        MindFusion.registerClass(g, "MindFusion.Diagramming.Panel", b)
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Drawing.Visibility;
        var b = a.SimplePanel = function() {
            mflayer.initializeBase(b, this)
        };
        b.prototype = {
            measure: function(l, n) {
                mflayer.callBaseMethod(b, this, "measure", [l, n]);
                var d = 0;
                var o = 0;
                for (var g = 0; g < this.children.length; g++) {
                    var e = this.children[g];
                    if (e.visibility == c.Collapsed) {
                        continue
                    }
                    var k = this.measureChild(e, l, n);
                    var j = k.width == null ? 0 : k.width;
                    var f = k.height == null ? 0 : k.height;
                    d = Math.max(j, d);
                    o = Math.max(f, o)
                }
                this.desiredWidth = d;
                this.desiredHeight = o
            },
            arrange: function(d, k, e, f) {
                mflayer.callBaseMethod(b, this, "arrange", [d, k, e, f]);
                for (var j = 0; j < this.children.length; j++) {
                    var g = this.children[j];
                    if (g.visibility == c.Collapsed) {
                        continue
                    }
                    this.arrangeInRect(g, 0, 0, e, f)
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.SimplePanel", a.Panel)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.Border = function() {
            mflayer.initializeBase(a, this)
        };
        a.prototype = {
            draw: function(d, c) {
                if (c) {
                    return
                }
                var e = this.getBounds();
                d.save();
                d.beginPath();
                d.rect(e.x, e.y, e.width, e.height);
                d.save();
                if (this.brush) {
                    d.fillStyle = MindFusion.Diagramming.Utils.getBrush(d, this.brush, e);
                    d.fill()
                }
                d.restore();
                if (this.pen) {
                    d.strokeStyle = this.pen;
                    d.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / d._mf_scale;
                    d.stroke()
                }
                d.restore();
                mflayer.callBaseMethod(a, this, "draw", [d, c])
            },
            getBounds: function() {
                return new MindFusion.Drawing.Rect(this.x, this.y, this.actualWidth, this.actualHeight)
            },
            pen: "black",
            strokeThickness: 0,
            brush: "transparent"
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Border", b.SimplePanel)
    })(MindFusion.Diagramming);
    (function(a) {
        var d = MindFusion.Drawing.LayoutAlignment;
        var c = MindFusion.Drawing.Thickness;
        var b = a.ComponentLoader = function(e) {
            this.nameMap = {};
            this.propertyMap = {};
            this.imageLoadHandler = e
        };
        b.prototype = {
            processedProps: ["component", "name", "children", "rowDefinitions", "columnDefinitions", "autoProperty", "location"],
            componentFromJson: function(e, J) {
                var n = e.component;
                var A;
                if (n == "Shape") {
                    A = Shape.component(e.id, e.isOutline, J);
                    if (e.pen) {
                        A.setPen(e.pen)
                    }
                    if (e.brush) {
                        A.setBrush(e.brush)
                    }
                } else {
                    A = this.createComponent(n)
                }
                var Q = e.name;
                if (Q) {
                    this.nameMap[Q] = A
                }
                if (n == "Image" && e.location) {
                    var s = this.imageLoadHandler;
                    if (s) {
                        mflayer.addHandlers(A.image, {
                            load: function() {
                                A.loaded = true;
                                s()
                            }
                        })
                    } else {
                        A.loaded = true
                    }
                    A.image.src = e.location
                }
                var L = e.autoProperty;
                if (L && Q) {
                    var q = "get" + Q;
                    var N = "set" + Q;
                    this.propertyMap[q] = function() {
                        return this.namedComponents[Q].getDefaultProperty()
                    };
                    this.propertyMap[N] = function(l) {
                        this.namedComponents[Q].setDefaultProperty(l != null ? l : this.namedComponents[Q].getDefaultValue());
                        this.invalidate()
                    }
                }
                for (var f in e) {
                    if (this.processedProps.indexOf(f) > -1) {
                        continue
                    }
                    if (e.hasOwnProperty(f)) {
                        if (f == "orientation" && typeof e[f] == "string") {
                            switch (e[f]) {
                                case "Horizontal":
                                    A[f] = a.Orientation.Horizontal;
                                    break;
                                case "Vertical":
                                    A[f] = a.Orientation.Vertical;
                                    break
                            }
                        } else {
                            if (f == "imageAlign" && typeof e[f] == "string") {
                                A[f] = MindFusion.Drawing.ImageAlign[e[f]]
                            } else {
                                if (f == "visibility" && typeof e[f] == "string") {
                                    A[f] = MindFusion.Drawing.Visibility[e[f]]
                                } else {
                                    if ((f == "horizontalAlignment" || f == "verticalAlignment") && typeof e[f] == "string") {
                                        A[f] = MindFusion.Drawing.LayoutAlignment[e[f]]
                                    } else {
                                        if ((f == "margin" || f == "padding") && typeof e[f] == "string") {
                                            var I = e[f].split(",");
                                            if (I.length == 1) {
                                                var M = parseFloat(I[0]);
                                                A[f] = new c(M, M, M, M)
                                            } else {
                                                if (I.length == 4) {
                                                    var K = parseFloat(I[0]);
                                                    var C = parseFloat(I[1]);
                                                    var E = parseFloat(I[2]);
                                                    var P = parseFloat(I[3]);
                                                    A[f] = new c(K, C, E, P)
                                                }
                                            }
                                        } else {
                                            if (f == "font" && typeof e[f] == "string") {
                                                var I = e[f].split(" ");
                                                var D = I[0];
                                                var F = 4;
                                                var H = false;
                                                var j = false;
                                                for (var G = 1; G < I.length; G++) {
                                                    if (I[G] == "bold") {
                                                        H = true
                                                    } else {
                                                        if (I[G] == "italic") {
                                                            j = true
                                                        } else {
                                                            F = parseFloat(I[G])
                                                        }
                                                    }
                                                }
                                                A[f] = new MindFusion.Drawing.Font(D, F, H, j)
                                            } else {
                                                A[f] = e[f]
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (e.rowDefinitions) {
                    var w = [];
                    for (var E = 0; E < e.rowDefinitions.length; E++) {
                        var B = e.rowDefinitions[E];
                        var o = new a.GridRow();
                        if (B == "*") {
                            o.lengthType = a.LengthType.Relative
                        } else {
                            if (B != "Auto") {
                                o.height = parseFloat(B)
                            }
                        }
                        w.push(o)
                    }
                    A.rows = w
                }
                if (e.columnDefinitions) {
                    var z = [];
                    for (var O = 0; O < e.columnDefinitions.length; O++) {
                        var k = e.columnDefinitions[O];
                        var h = new a.GridColumn();
                        if (k == "*") {
                            h.lengthType = a.LengthType.Relative
                        } else {
                            if (k != "Auto") {
                                h.width = parseFloat(k)
                            }
                        }
                        z.push(h)
                    }
                    A.columns = z
                }
                if (e.children) {
                    for (var g = 0; g < e.children.length; g++) {
                        var u = e.children[g];
                        var v = this.componentFromJson(u, J);
                        A.children.push(v)
                    }
                }
                this.setDefaults(A);
                return A
            },
            setDefaults: function(e) {
                if (e.constructor == MindFusion.Drawing.Text) {
                    e.fitInBounds = true;
                    e.ignoreTransform = true
                }
            },
            createComponent: function(e) {
                if (e.indexOf("Panel") !== -1 || e.indexOf("Border") !== -1) {
                    return new a[e]()
                }
                if (e.indexOf(".") == -1) {
                    return new MindFusion.Drawing[e]()
                }
                return new this.ctorFromName(e)
            },
            ctorFromName: function(e) {
                var h = e.split(".");
                var g = (window || this);
                for (var f = 0; f < h.length; f++) {
                    g = g[h[f]]
                }
                if (typeof g !== "function") {
                    throw new Error("Class not found.")
                }
                return g
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ComponentLoader")
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.GridColumn = function() {
            this.x = 0;
            this.width = null;
            this.measuredWidth = null;
            this.lengthType = a.LengthType.Auto
        };
        b.prototype = {
            setLengthType: function(c) {
                this.lengthType = c
            },
            getLengthType: function() {
                return this.lengthType
            },
            setWidth: function(c) {
                this.width = c
            },
            getWidth: function() {
                return this.width
            },
            fixedSize: function() {
                return this.width
            },
            measuredSize: function() {
                return this.width != null ? this.width : this.measuredWidth
            },
            setPos: function(d, c) {
                this.x = d;
                this.layoutWidth = c
            },
            relativeSize: function() {
                if (this.width != null) {
                    return false
                }
                return this.measuredWidth == null || this.lengthType == a.LengthType.Relative
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.GridColumn")
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Drawing.Visibility;
        var b = a.GridPanel = function() {
            mflayer.initializeBase(b, this);
            this.rows = [new a.GridRow()];
            this.columns = [new a.GridColumn()]
        };
        b.prototype = {
            getRows: function() {
                return this.rows
            },
            getColumns: function() {
                return this.columns
            },
            measure: function(k, l) {
                mflayer.callBaseMethod(b, this, "measure", [k, l]);
                for (var d = 0; d < this.rows.length; d++) {
                    var o = this.rows[d];
                    o.measuredHeight = null
                }
                for (var g = 0; g < this.columns.length; g++) {
                    var f = this.columns[g];
                    f.measuredWidth = null
                }
                for (var g = 0; g < this.children.length; g++) {
                    var e = this.children[g];
                    if (e.visibility == c.Collapsed) {
                        continue
                    }
                    var j = this.measureChild(e, k, l);
                    var h = e.gridRow;
                    if (!h) {
                        h = 0
                    }
                    if (h < this.rows.length) {
                        var o = this.rows[h];
                        o.measuredHeight = this.max(o.measuredHeight, j.height)
                    }
                    var n = e.gridColumn;
                    if (!n) {
                        n = 0
                    }
                    if (n < this.columns.length) {
                        var f = this.columns[n];
                        f.measuredWidth = this.max(f.measuredWidth, j.width)
                    }
                }
                this.desiredHeight = null;
                for (var d = 0; d < this.rows.length; d++) {
                    var o = this.rows[d];
                    this.desiredHeight = this.add(this.desiredHeight, o.measuredSize())
                }
                this.desiredWidth = null;
                for (var g = 0; g < this.columns.length; g++) {
                    var f = this.columns[g];
                    this.desiredWidth = this.add(this.desiredWidth, f.measuredSize())
                }
                this.desiredWidth = this.desiredHeight = null
            },
            assignCoords: function(d, k) {
                var q = 0;
                var r = 0;
                for (var o = 0; o < d.length; o++) {
                    var p = d[o];
                    var e = p.fixedSize();
                    if (e) {
                        r += e
                    } else {
                        if (!p.relativeSize()) {
                            q += p.measuredSize()
                        }
                    }
                }
                var n = q > k - r;
                var j = 0;
                var h = 0;
                for (var o = 0; o < d.length; o++) {
                    var p = d[o];
                    var t = p.measuredSize();
                    if (p.fixedSize() || !p.relativeSize() && !n) {
                        j += t
                    } else {
                        h++
                    }
                }
                var l = 0;
                if (h > 0) {
                    l = (k - j) / h
                }
                if (l < 0) {
                    l = 0
                }
                var s = 0;
                for (var o = 0; o < d.length; o++) {
                    var p = d[o];
                    var g = p.measuredSize();
                    var f = l;
                    if (p.fixedSize() || !p.relativeSize() && !n) {
                        f = g
                    }
                    p.setPos(s, f);
                    s = this.add(s, f)
                }
                return l
            },
            arrange: function(u, t, v, D) {
                mflayer.callBaseMethod(b, this, "arrange", [u, t, v, D]);
                var C = this.assignCoords(this.rows, D);
                var A = this.assignCoords(this.columns, v);
                for (var E = 0; E < this.children.length; E++) {
                    var p = this.children[E];
                    if (p.visibility == c.Collapsed) {
                        continue
                    }
                    var q = null;
                    var g = p.gridRow;
                    if (!g) {
                        g = 0
                    }
                    if (g < this.rows.length) {
                        q = this.rows[g]
                    }
                    var o = null;
                    var d = p.gridColumn;
                    if (!d) {
                        d = 0
                    }
                    if (d < this.columns.length) {
                        o = this.columns[d]
                    }
                    if (o != null && q != null) {
                        var j = q.layoutHeight;
                        var n = p.rowSpan;
                        if (!n) {
                            n = 1
                        }
                        for (var z = 1; z < n; z++) {
                            var k = this.rows[g + z];
                            if (!k) {
                                continue
                            }
                            j += k.layoutHeight
                        }
                        var e = o.layoutWidth;
                        var s = p.columnSpan;
                        if (!s) {
                            s = 1
                        }
                        for (var B = 1; B < s; B++) {
                            var f = this.columns[d + B];
                            if (!f) {
                                continue
                            }
                            e += f.layoutWidth
                        }
                        this.arrangeInRect(p, o.x, q.y, e, j)
                    }
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.GridPanel", a.Panel)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.GridRow = function() {
            this.y = 0;
            this.height = null;
            this.measuredHeight = null;
            this.lengthType = a.LengthType.Auto
        };
        b.prototype = {
            setLengthType: function(c) {
                this.lengthType = c
            },
            getLengthType: function() {
                return this.lengthType
            },
            setHeight: function(c) {
                this.height = c
            },
            getHeight: function() {
                return this.height
            },
            fixedSize: function() {
                return this.height
            },
            measuredSize: function() {
                return this.height != null ? this.height : this.measuredHeight
            },
            setPos: function(d, c) {
                this.y = d;
                this.layoutHeight = c
            },
            relativeSize: function() {
                if (this.height != null) {
                    return false
                }
                return this.measuredHeight == null || this.lengthType == a.LengthType.Relative
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.GridRow")
    })(MindFusion.Diagramming);
    (function(b) {
        var d = MindFusion.Drawing.Visibility;
        var c = MindFusion.Drawing.LayoutAlignment;
        var a = b.StackPanel = function() {
            mflayer.initializeBase(a, this);
            this.orientation = b.Orientation.Horizontal
        };
        a.prototype = {
            measure: function(n, o) {
                mflayer.callBaseMethod(a, this, "measure", [n, o]);
                var j = null;
                var k = null;
                for (var g = 0; g < this.children.length; g++) {
                    var e = this.children[g];
                    if (e.visibility == d.Collapsed) {
                        continue
                    }
                    var l = this.measureChild(e, n, o);
                    var h = this.primaryMeasure(e);
                    j = this.add(j, h);
                    var f = this.secondaryMeasure(e);
                    k = this.max(k, f)
                }
                this.setMeasures(j, k)
            },
            arrange: function(t, r, u, n) {
                mflayer.callBaseMethod(a, this, "arrange", [t, r, u, n]);
                var f = 0;
                var k = 0;
                for (var q = 0; q < this.children.length; q++) {
                    var g = this.children[q];
                    if (g.visibility == d.Collapsed) {
                        continue
                    }
                    if (u < this.measureMax) {
                        this.measureChild(g, u, null)
                    }
                    var p = this.primaryMeasure(g);
                    if (p !== null) {
                        f += p
                    } else {
                        k++
                    }
                }
                var v = this.primarySize(this);
                var j = 0;
                if (k > 0) {
                    j = (v - f) / k
                }
                if (j < 0) {
                    j = 0
                }
                var l = 0;
                var e = this.secondarySize(this);
                for (var q = 0; q < this.children.length; q++) {
                    var g = this.children[q];
                    if (g.visibility == d.Collapsed) {
                        continue
                    }
                    var p = this.primaryMeasure(g);
                    var o = p !== null ? p : j;
                    this.arrangeChildOrient(g, l, o, 0, e);
                    l += o
                }
            },
            getOrientation: function() {
                return this.orientation
            },
            setOrientation: function(e) {
                if (this.orientation != e) {
                    this.orientation = e;
                    this.invalidateLayout()
                }
            },
            primaryMeasure: function(e) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        return this.desiredWidthMargins(e);
                    case b.Orientation.Vertical:
                        return this.desiredHeightMargins(e)
                }
                return 0
            },
            secondaryMeasure: function(e) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        return this.desiredHeightMargins(e);
                    case b.Orientation.Vertical:
                        return this.desiredWidthMargins(e)
                }
                return 0
            },
            primarySize: function(e) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        return e.actualWidth;
                    case b.Orientation.Vertical:
                        return e.actualHeight
                }
                return 0
            },
            secondarySize: function(e) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        return e.actualHeight;
                    case b.Orientation.Vertical:
                        return e.actualWidth
                }
                return 0
            },
            arrangeChildOrient: function(j, h, e, g, f) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        this.arrangeInRect(j, h, g, e, f);
                        break;
                    case b.Orientation.Vertical:
                        this.arrangeInRect(j, g, h, f, e);
                        break
                }
            },
            setMeasures: function(f, e) {
                switch (this.orientation) {
                    case b.Orientation.Horizontal:
                        this.desiredWidth = f;
                        this.desiredHeight = e;
                        break;
                    case b.Orientation.Vertical:
                        this.desiredHeight = f;
                        this.desiredWidth = e;
                        break
                }
                if (this.horizontalAlignment == c.Stretch) {
                    this.desiredWidth = null
                }
                if (this.verticalAlignment == c.Stretch) {
                    this.desiredHeight = null
                }
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.StackPanel", b.Panel)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var d = b.SinglePointerController = function(h, j) {
            mflayer.initializeBase(d, this);
            this.modifiedItem = h;
            this.adjustmentHandle = j;
            this.controlPointStart = j == null ? new MindFusion.Drawing.Point(0, 0) : h.getHandlePosition(j.index);
            this.action = b.Action.Modify;
            this.originalStates = new MindFusion.Collections.Dictionary();
            if (h) {
                this.originalStates.set(h, h.saveLocationState())
            }
        };
        d.prototype = {
            start: function(h) {
                this.startPoint = h.clone();
                if (this.action == b.Action.Modify && this.originalStates.getCount() > 0) {
                    var k = this.originalStates.keys();
                    var j = k[0].getParent();
                    j.startCompositeOperation();
                    j.onStartInteraction(k);
                    this.modifiedDiagram = j
                }
            },
            move: function(h) {
                this.currentPoint = h.clone()
            },
            validate: function(h) {
                return true
            },
            commit: function(h) {
                if (this.modifiedDiagram) {
                    var j = this.modifiedDiagram;
                    if (j.autoResize != b.AutoResize.None) {
                        j.resizeToFitItem(this.modifiedItem)
                    }
                    j.commitCompositeOperation()
                }
            },
            cancel: function(h) {
                this.originalStates.forEach(function(j, k) {
                    j.restoreLocationState(this)
                }, this);
                if (this.modifiedDiagram) {
                    this.modifiedDiagram.cancelCompositeOperation()
                }
            },
            cancelNow: function() {
                this.cancelDrag = true
            },
            shouldCancelDrag: function() {
                return this.cancelDrag
            },
            drawInteraction: function(h) {},
            delta: function() {
                return b.Utils.subtract(this.currentPoint, this.controlPointStart)
            },
            supportsAutoScroll: function() {
                return true
            },
            supportsCursors: function() {
                return true
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.SinglePointerController")
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.CreateLinkController = function(h, j) {
            mflayer.initializeBase(e, this, [j, {
                item: j,
                index: j.points.length - 1
            }]);
            this.diagram = h;
            this.link = j;
            this.action = b.Action.Create
        };
        e.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(e, this, "start", [h]);
                this.diagram.raiseInitialize(this.link);
                this.link.startDrag(this)
            },
            move: function(h) {
                mflayer.callBaseMethod(e, this, "move", [h]);
                this.link.updateDrag(this);
                this.lastPosition = h.clone()
            },
            validate: function(h) {
                var j = this.link;
                return j.parent.raiseCreating(j, this) && j.allowDrag(this)
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                var j = this.link;
                j.endDrag(this);
                this.diagram.addItem(j);
                this.diagram.raiseCreated(j);
                mflayer.callBaseMethod(e, this, "commit", [h])
            },
            drawInteraction: function(h) {
                this.link.graphicsContainer.draw(h, true, false)
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.CreateLinkController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.CreateNodeController = function(h, j) {
            mflayer.initializeBase(e, this, [j, {
                item: j,
                index: 2
            }]);
            this.diagram = h;
            this.node = j;
            this.action = b.Action.Create
        };
        e.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(e, this, "start", [h]);
                this.diagram.raiseInitialize(this.node);
                this.node.startDrag(this)
            },
            move: function(h) {
                mflayer.callBaseMethod(e, this, "move", [h]);
                this.node.updateDrag(this);
                this.lastPosition = h.clone()
            },
            validate: function(h) {
                var j = this.node;
                return j.parent.raiseCreating(j, this) && j.allowDrag(this)
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                var k = this.node;
                k.endDrag(this);
                k = this.replaceNewItem(k);
                var j = this.diagram;
                j.addItem(k);
                j.raiseCreated(k);
                j.onItemDropped(k, h);
                mflayer.callBaseMethod(e, this, "commit", [h])
            },
            drawInteraction: function(h) {
                this.node.graphicsContainer.draw(h, true, false)
            },
            rectFromPoints: function(j, h, l) {
                var k = c.fromPoints(j, h);
                if (k.width < l) {
                    k.width = l
                }
                if (k.height < l) {
                    k.height = l
                }
                return k
            },
            replaceNewItem: function(h) {
                if (this.convertToShape && h.standardShapeReplacement) {
                    return h.standardShapeReplacement(this.diagram.freeFormTargets, this.diagram.defaultShape)
                }
                return h
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.CreateNodeController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.CreateSelectionController = function(h) {
            mflayer.initializeBase(e, this, [h]);
            this.selection = h;
            this.action = b.Action.Create
        };
        e.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(e, this, "start", [h]);
                this.selection.startDrag(this);
                this.selectionRect = new c(h.x, h.y, 1, 1);
                this.selectionRect.pen = "gray";
                this.selectionRect.brush = "rgba(200,200,200,0.5)"
            },
            move: function(j) {
                mflayer.callBaseMethod(e, this, "move", [j]);
                this.selection.updateDrag(this);
                this.lastPosition = j.clone();
                var k = this.selection.parent;
                var h = f.getPixel(k.measureUnit);
                k.invalidate(this.selectionRect.adjusted(-h, -h, h, h));
                b.Utils.setRect(this.selectionRect, c.fromPoints(this.startPoint, j));
                k.invalidate(this.selectionRect.adjusted(-h, -h, h, h))
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                this.selection.endDrag(this);
                mflayer.callBaseMethod(e, this, "commit", [h])
            },
            drawInteraction: function(h) {
                this.selectionRect.draw(h, false)
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.CreateSelectionController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.Keyboard = {
            state: {}
        };
        var c = b.Touch = {
            lastTouch: null
        };
        var d = b.Mouse = {
            LeftButton: 0,
            RightButton: 2,
            NoButton: -1
        }
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var h = MindFusion.Drawing.Point;
        var a = MindFusion.Drawing.GraphicsUnit;
        var f = MindFusion.Drawing.Vector;
        var l = {
            dependencies: function(n) {
                if (mflayer.isInstanceOfType(b.ContainerNode, n)) {
                    return n.children
                }
                return []
            },
            dependentUpon: function(n) {
                return [n.container]
            },
            recognize: function(n) {
                return mflayer.isInstanceOfType(b.DiagramNode, n) && n.container != null
            },
            updateFromMasters: function(p, q) {
                var o = p.container;
                var s = o.getBounds();
                var r = q.get(o).bounds;
                var v = s.topLeft();
                var u = r.topLeft();
                var n = b.Utils.subtract(v, u);
                var t = q.get(p).bounds;
                p.setBounds(b.Utils.offset(t, n))
            }
        };
        var k = {
            dependencies: function(n) {
                var o = [];
                if (n.attachedNodes) {
                    n.attachedNodes.forEach(function(p) {
                        if (!p.attachment) {
                            p.attachment = {}
                        }
                        p.attachment.offsetX = p.bounds.x - n.bounds.x;
                        p.attachment.offsetY = p.bounds.y - n.bounds.y;
                        o.push(p)
                    })
                }
                return o
            },
            dependentUpon: function(n) {
                return [n.masterNode]
            },
            recognize: function(n) {
                return n.masterNode != null
            },
            updateFromMasters: function(n, r) {
                var p = n.masterNode;
                var q = n.attachment;
                if (p) {
                    var o = n.bounds.clone();
                    o.x = p.bounds.x + q.offsetX;
                    o.y = p.bounds.y + q.offsetY;
                    n.setBounds(o)
                }
            }
        };
        var e = {
            dependencies: function(n) {
                if (mflayer.isInstanceOfType(b.DiagramNode, n)) {
                    return n.getAllLinks()
                }
                return []
            },
            dependentUpon: function(n) {
                return [n.getOrigin(), n.getDestination()]
            },
            recognize: function(n) {
                return mflayer.isInstanceOfType(b.DiagramLink, n)
            },
            updateFromMasters: function(n, o) {
                n.updatePosFromOrgAndDest()
            }
        };
        var j = {
            dependencies: function(n) {
                if (mflayer.isInstanceOfType(b.Selection, n)) {
                    return n.nodes
                }
                return []
            },
            dependentUpon: function(n) {
                return [n.parent.selection]
            },
            recognize: function(n) {
                return n.selected && mflayer.isInstanceOfType(b.DiagramNode, n)
            },
            updateFromMasters: function(q, r, u) {
                var v = q.parent.selection;
                var o = r.get(v);
                if (o) {
                    if (!q.parent.allowMultipleResize) {
                        var s = v.bounds.topLeft();
                        if (q.parent.alignToGrid) {
                            s = q.parent.alignPointToGrid(s)
                        }
                        var w = b.Utils.subtract(s, o.bounds.topLeft());
                        var n = r.get(q).bounds.clone();
                        n.x += w.x;
                        n.y += w.y;
                        q.setBounds(n)
                    } else {
                        if (u.adjustmentHandle.index == 9) {
                            var p = u.adjustmentHandle.item;
                            var t = r.get(q).rotationAngle;
                            q.setRotationAngle(t + u.angleDelta)
                        } else {
                            q.updateDrag(u)
                        }
                    }
                }
            }
        };
        var d = b.DiagramMediator = function(p) {
            mflayer.initializeBase(d, this);
            this.masterItem = p;
            var n = this.items = [p];
            this.collectDependencies();
            this.originalStates = new MindFusion.Collections.Dictionary();
            for (var o = 0; o < n.length; o++) {
                var q = n[o];
                this.originalStates.set(q, q.saveLocationState())
            }
        };
        d.AllRules = [j, l, k, e];
        d.LinkRules = [e];
        d.GroupRules = [l, k];
        d.prototype = {
            rules: d.AllRules,
            updateDependencies: function() {
                var s = this.items;
                var v = this.rules;
                var o = 0;
                var u = s[s.length - 1];
                var q = s.slice(1);
                while (q.length > 0) {
                    var z = q.shift();
                    var A = true;
                    for (var n = 0; n < v.length && A; n++) {
                        var t = v[n];
                        if (!t.recognize(z)) {
                            continue
                        }
                        var w = t.dependentUpon(z);
                        if (o <= n) {
                            for (var p = 0; p < w.length; p++) {
                                if (q.indexOf(w[p]) >= 0) {
                                    A = false;
                                    break
                                }
                            }
                        }
                    }
                    if (A) {
                        for (var n = 0; n < v.length; n++) {
                            var t = v[n];
                            if (this.canApplyRule(t, z, q)) {
                                t.updateFromMasters(z, this.originalStates, this.ist)
                            }
                        }
                    } else {
                        q.push(z)
                    }
                    if (z == u) {
                        o++;
                        u = q[q.length - 1]
                    }
                }
                if (this.ist && typeof this.ist.angleDelta != "undefined") {
                    return
                }
                this.translateLinkPoints()
            },
            canApplyRule: function(r, q, o) {
                if (!r.recognize(q)) {
                    return false
                }
                var s = r.dependentUpon(q);
                for (var n = 0; n < s.length; n++) {
                    var p = s[n];
                    if (this.items.indexOf(p) >= 0 && o.indexOf(p) == -1) {
                        return true
                    }
                }
                return false
            },
            collectDependencies: function() {
                var t = this.items;
                var v = this.rules;
                for (var p = 0; p < t.length; p++) {
                    var w = t[p];
                    for (var n = 0; n < v.length; n++) {
                        var u = v[n];
                        var s = u.dependencies(w);
                        for (var q = 0; q < s.length; q++) {
                            var o = s[q];
                            if (t.indexOf(o) === -1) {
                                t.push(o)
                            }
                        }
                    }
                }
            },
            translateLinkPoints: function() {
                for (var p = 0; p < this.items.length; p++) {
                    if (!mflayer.isInstanceOfType(b.DiagramLink, this.items[p])) {
                        continue
                    }
                    var q = this.items[p];
                    var o = q.getOrigin();
                    var n = q.getDestination();
                    var s = o != null && n != null && this.items.indexOf(o) > -1 && this.items.indexOf(n) > -1;
                    if (s) {
                        var r = this.sameOffset(o, n);
                        if (r) {
                            b.Utils.offsetPointCollection(q.points, this.originalStates.get(q).controlPoints, r);
                            q.updateFromPoints(false)
                        }
                    }
                }
            },
            sameOffset: function(v, u) {
                var t = a.getMillimeter(v.parent.measureUnit) / 10000;
                var p = v.bounds;
                var s = this.originalStates.get(v).bounds;
                if (!p.sameSize(s)) {
                    return false
                }
                var o = u.bounds;
                var r = this.originalStates.get(u).bounds;
                if (!o.sameSize(r)) {
                    return false
                }
                var q = f.fromPoints(s.topLeft(), p.topLeft());
                var n = f.fromPoints(r.topLeft(), o.topLeft());
                if (Math.abs(q.x - n.x) < t && Math.abs(q.y - n.y) < t) {
                    return q
                }
                return null
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.DiagramMediator")
    })(MindFusion.Diagramming);
    (function(b) {
        var f = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var d = b.InplaceEditController = function(g) {
            mflayer.initializeBase(d, this);
            this.modifiedItem = g;
            this.diagram = this.modifiedItem.getParent ? this.modifiedItem.getParent() : this.modifiedItem.parent.grid.parent
        };
        d.prototype = {
            start: function(q, n) {
                var l = this.diagram;
                var s = this.modifiedItem;
                var k;
                if (n) {
                    k = this.inplaceObject = s.getObjectToEdit(null, n)
                } else {
                    k = this.inplaceObject = s.getObjectToEdit(q)
                }
                var p = k.getEditRect(q);
                var r = k.getTextToEdit();
                var j = null;
                var g = mflayer.getHandler(l, "createEditControl");
                if (g != null) {
                    var o = new b.InplaceEditEventArgs({
                        item: s,
                        control: null,
                        bounds: l.getInplaceEditBounds(p)
                    });
                    l.raiseEvent(b.Events.createEditControl, o);
                    j = o.control
                }
                if (j == null) {
                    this.inplaceTextBox = document.createElement("textarea");
                    this.inplaceTextBox.id = l.get_element().id + "_inplaceInput";
                    this.inplaceTextBox.value = r;
                    this.inplaceTextBox.style.position = "absolute";
                    this.inplaceTextBox.style.zIndex = 2;
                    this.setInplaceEditBounds(p);
                    this.inplaceTextBox.style.border = "1px solid #5C87B2";
                    this.inplaceTextBox.className = "mf_diagram_inplaceInput";
                    document.body.appendChild(this.inplaceTextBox)
                } else {
                    this.inplaceTextBox = j
                }
                this.inplaceTextBox.onkeyup = mflayer.createDelegate(this, this.inplaceKeyUp);
                l.keyboardHandler.setTargetElement(this.inplaceTextBox);
                var h = this;
                setTimeout(function() {
                    h.focusInput.apply(h)
                }, 100);
                l.raiseEvent(b.Events.enterInplaceEditMode, new b.InplaceEditEventArgs({
                    item: s,
                    control: this.inplaceTextBox
                }))
            },
            focusInput: function() {
                if (this.inplaceTextBox) {
                    this.inplaceTextBox.focus()
                }
            },
            setInplaceEditBounds: function(h) {
                var g = this.diagram.getInplaceEditBounds(h);
                this.inplaceTextBox.style.left = g.x + "px";
                this.inplaceTextBox.style.top = g.y + "px";
                this.inplaceTextBox.style.width = g.width + "px";
                this.inplaceTextBox.style.height = g.height + "px"
            },
            validate: function(g) {
                var j = this.diagram;
                var h = (this.inplaceTextBox != null) && j.inplaceEditBounds.containsPoint(g);
                if (h) {
                    return false
                }
                return true
            },
            commit: function() {
                var h = this.diagram;
                h.raiseEvent(b.Events.leaveInplaceEditMode, new b.InplaceEditEventArgs({
                    item: this.inplaceObject,
                    control: this.inplaceTextBox
                }));
                var g = this.inplaceObject.getTextToEdit();
                var k = this.inplaceTextBox.value;
                this.inplaceTextBox.style.visibility = "hidden";
                document.body.removeChild(this.inplaceTextBox);
                this.inplaceTextBox = null;
                var l = this.inplaceObject;
                this.inplaceObject = null;
                var n = null;
                var j = l.getDiagramItem();
                if (j) {
                    n = h.startItemChange(l.getDiagramItem())
                }
                l.setEditedText(k);
                if (mflayer.isInstanceOfType(b.DiagramNode, l)) {
                    h.raiseEvent(b.Events.nodeTextEdited, l.createEditArgs(g, k))
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramLink, l)) {
                        h.raiseEvent(b.Events.linkTextEdited, l.createEditArgs(g, k))
                    } else {
                        if (mflayer.isInstanceOfType(b.LinkLabel, l)) {
                            h.raiseEvent(b.Events.linkTextEdited, l.createEditArgs(g, k))
                        } else {
                            if (mflayer.isInstanceOfType(b.CellEditor, l)) {
                                h.raiseEvent(b.Events.cellTextEdited, l.createEditArgs(g, k))
                            } else {
                                if (mflayer.isInstanceOfType(MindFusion.Diagramming.Lanes.Cell, l)) {
                                    h.raiseEvent(b.Events.laneGridCellTextEdited, l.createEditArgs(g, k))
                                }
                            }
                        }
                    }
                }
                if (n) {
                    h.endItemChange(n)
                }
                h.mouseInputDispatcher.currentController = null;
                h.keyboardHandler.setTargetElement(h.get_focusElement())
            },
            cancel: function() {
                var g = this.diagram;
                g.raiseEvent(b.Events.leaveInplaceEditMode, new b.InplaceEditEventArgs({
                    item: this.inplaceObject,
                    control: this.inplaceTextBox
                }));
                this.inplaceTextBox.style.visibility = "hidden";
                document.body.removeChild(this.inplaceTextBox);
                this.inplaceTextBox = null;
                var h = this.inplaceObject;
                this.inplaceObject = null;
                g.mouseInputDispatcher.currentController = null;
                g.keyboardHandler.setTargetElement(g.get_focusElement())
            },
            inplaceKeyUp: function(g) {
                if (g.keyCode == 27) {
                    this.cancel();
                    this.diagram.get_focusElement().focus()
                }
            },
            drawInteraction: function(g) {},
            move: function(g) {},
            shouldCancelDrag: function() {
                return false
            },
            supportsAutoScroll: function() {
                return false
            },
            supportsCursors: function() {
                return false
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.InplaceEditController")
    })(MindFusion.Diagramming);
    (function(b) {
        var f = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var d = b.KeyboardEventHandler = function(g) {
            mflayer.initializeBase(d, this);
            this.view = g;
            this.canvasElement = g.get_element();
            this.targetElement = g.get_focusElement();
            this.inputDispatcher = g.keyboardInputDispatcher;
            this.keyUpDelegate = mflayer.createDelegate(this, this.onKeyUp)
        };
        d.prototype = {
            attachHandlers: function() {
                mflayer.addHandlers(this.targetElement, {
                    keyup: this.keyUpDelegate
                })
            },
            setTargetElement: function(g) {
                if (g != this.targetElement) {
                    mflayer.removeHandler(this.targetElement, "keyup", this.keyUpDelegate);
                    this.targetElement = g;
                    this.attachHandlers()
                }
            },
            onKeyUp: function(g) {
                this.inputDispatcher.onKeyUp(this.targetElement.id, g.keyCode, null)
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.KeyboardEventHandler")
    })(MindFusion.Diagramming);
    (function(b) {
        var f = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var c = b.KeyboardInputDispatcher = function(g) {
            mflayer.initializeBase(c, this);
            this.diagram = g;
            this.inputState = {}
        };
        c.prototype = {
            onKeyUp: function(h, n, j, k) {
                var g = this.diagram;
                if (!g.enabled) {
                    return
                }
                var l = document.getElementById(h);
                if (l == this.diagram.get_focusElement()) {
                    if (n == 46 || n == 127 || (navigator.platform.toLowerCase().indexOf("mac") > -1 && n == 8)) {
                        if (g.mouseInputDispatcher.currentController == null) {
                            if (g.delKeyAction == b.DelKeyAction.DeleteActiveItem) {
                                g.deleteItem(g.activeItem)
                            }
                            if (g.delKeyAction == b.DelKeyAction.DeleteSelectedItems) {
                                g.deleteSelection()
                            }
                        }
                    }
                } else {
                    if (j) {
                        l.value = k
                    }
                }
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.KeyboardInputDispatcher")
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var c = b.LaneGridController = function(h, l, k, j) {
            mflayer.initializeBase(c, this, []);
            this.diagram = h;
            this.header = l;
            this.resizingHeaderWidth = k;
            this.dragOffset = new MindFusion.Drawing.Size(0, 0);
            this.dragInitialPos = new MindFusion.Drawing.Point(0, 0);
            this.headerBounds = j
        };
        c.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(c, this, "start", [h]);
                if (this.resizingHeaderWidth) {
                    this.current = this.last = h.x
                } else {
                    this.current = this.last = h.y
                }
            },
            move: function(h) {
                mflayer.callBaseMethod(c, this, "move", [h]);
                if (this.resizingHeaderWidth) {
                    this.current = h.x;
                    var k = this.headerBounds.width;
                    var l = Math.max(f.getMillimeter(this.diagram.measureUnit), this.headerBounds.width + (this.current - this.last));
                    this.setWidth(l);
                    if (!this.diagram.raiseHeaderResizing(this.header, this.resizingHeaderWidth)) {
                        this.setWidth(k)
                    } else {
                        this.resizing = true
                    }
                    if (k != this.headerBounds.width) {
                        this.last = this.current
                    }
                } else {
                    this.current = h.y;
                    var n = this.headerBounds.height;
                    var j = Math.max(f.getMillimeter(this.diagram.measureUnit), this.headerBounds.height + (this.current - this.last));
                    this.setHeight(j);
                    if (!this.diagram.raiseHeaderResizing(this.header, this.resizingHeaderWidth)) {
                        this.setHeight(n)
                    } else {
                        this.resizing = true
                    }
                    if (n != this.headerBounds.height) {
                        this.last = this.current
                    }
                }
                this.diagram.invalidate()
            },
            commit: function(h) {
                if (this.resizing) {
                    this.diagram.raiseHeaderResized(this.header, this.resizingHeaderWidth)
                }
                this.resizing = false
            },
            cancel: function(h) {},
            getHeadersOnLevel: function(p) {
                var h = [];
                var o = p.parent;
                if (o.parent) {
                    for (var n = 0; n < o.parent.subHeaders.length; n++) {
                        var j = o.parent.subHeaders[n];
                        for (var l = 0; l < j.subHeaders.length; l++) {
                            h.push(j.subHeaders[l])
                        }
                    }
                } else {
                    for (var n = 0; n < o.subHeaders.length; n++) {
                        h.push(o.subHeaders[n])
                    }
                }
                return h
            },
            setHeight: function(h) {
                if (this.header.isRowHeader()) {
                    this.header.setHeight(h)
                } else {
                    var k = this.getHeadersOnLevel(this.header);
                    for (var j = 0; j < k.length; j++) {
                        k[j].setHeight(h)
                    }
                }
            },
            setWidth: function(j) {
                if (this.header.isRowHeader()) {
                    var k = this.getHeadersOnLevel(this.header);
                    for (var h = 0; h < k.length; h++) {
                        k[h].setWidth(j)
                    }
                } else {
                    this.header.setWidth(j)
                }
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.LaneGridController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(c) {
        var g = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var b = c.MagnifyController = function(h) {
            mflayer.initializeBase(b, this, []);
            this.diagram = h
        };
        b.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(b, this, "start", [h]);
                this.diagram.invalidate()
            },
            move: function(h) {
                mflayer.callBaseMethod(b, this, "move", [h]);
                this.diagram.invalidate()
            },
            drawInteraction: function(h) {
                this.diagram.drawMagnifier(this.currentPoint)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.MagnifyController", c.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var e = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var f = b.ManipulatorController = function(j, h) {
            mflayer.initializeBase(f, this, []);
            this.diagram = j;
            this.manipulator = h
        };
        f.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(f, this, "start", [h]);
                this.manipulator.onMouseDown(h)
            },
            move: function(h) {
                mflayer.callBaseMethod(f, this, "move", [h]);
                this.manipulator.onMouseMove(h);
                this.diagram.invalidate()
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                this.manipulator.onMouseUp(h);
                mflayer.callBaseMethod(f, this, "commit", [h])
            },
            cancel: function(h) {
                this.manipulator.cancel()
            }
        };
        MindFusion.registerClass(f, "MindFusion.Diagramming.ManipulatorController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.ModifyLinkController = function(h, j) {
            mflayer.initializeBase(e, this, [h, j]);
            this.link = h
        };
        e.prototype = {
            start: function(h) {
                this.mediator = new b.DiagramMediator(this.link);
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(e, this, "start", [h]);
                this.link.startDrag(this)
            },
            move: function(h) {
                mflayer.callBaseMethod(e, this, "move", [h]);
                this.link.updateDrag(this);
                this.mediator.updateDependencies();
                this.lastPosition = h.clone()
            },
            validate: function(h) {
                var j = this.link;
                return j.parent.raiseModifying(j, this) && j.allowDrag(this)
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                var j = this.link;
                j.endDrag(this);
                j.parent.raiseModified(j, h, this.adjustmentHandle.index);
                mflayer.callBaseMethod(e, this, "commit", [h])
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.ModifyLinkController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.ModifyNodeController = function(h, j) {
            mflayer.initializeBase(e, this, [h, j]);
            this.node = h;
            this.startBounds = h.bounds.clone()
        };
        e.prototype = {
            start: function(h) {
                this.mediator = new b.DiagramMediator(this.node);
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(e, this, "start", [h]);
                this.node.startDrag(this)
            },
            move: function(h) {
                mflayer.callBaseMethod(e, this, "move", [h]);
                var k = this.node;
                var l = this.adjustmentHandle.index;
                if (l === 9) {
                    var j = MindFusion.Geometry.cartesianToPolar(b.Utils.getCenter(k.bounds), h).a;
                    k.setRotationAngle(90 - j * 180 / Math.PI, false)
                } else {
                    k.updateDrag(this)
                }
                this.mediator.updateDependencies();
                this.lastPosition = h.clone()
            },
            validate: function(h) {
                var j = this.node;
                return j.parent.raiseModifying(j, this) && j.allowDrag(this)
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                var k = this.node;
                k.endDrag(this);
                var j = k.parent;
                j.raiseModified(k, h, this.adjustmentHandle.index);
                j.onItemDropped(k, h);
                mflayer.callBaseMethod(e, this, "commit", [h])
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.ModifyNodeController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var d = b.ModifySelectionController = function(h, j) {
            mflayer.initializeBase(d, this, [h, j]);
            this.selection = h
        };
        d.prototype = {
            start: function(h) {
                this.mediator = new b.DiagramMediator(this.selection);
                this.mediator.ist = this;
                this.originalStates = this.mediator.originalStates;
                mflayer.callBaseMethod(d, this, "start", [h]);
                this.selection.startDrag(this)
            },
            move: function(h) {
                mflayer.callBaseMethod(d, this, "move", [h]);
                var l = this.adjustmentHandle.index;
                if (l === 9) {
                    var k = this.adjustmentHandle.item;
                    var n = this.originalStates.get(k).rotationAngle;
                    var j = MindFusion.Geometry.cartesianToPolar(b.Utils.getCenter(k.bounds), h).a;
                    j = 90 - j * 180 / Math.PI;
                    this.angleDelta = j - n
                } else {
                    this.selection.updateDrag(this)
                }
                this.mediator.updateDependencies();
                this.lastPosition = h.clone()
            },
            validate: function(h) {
                var j = this.selection;
                return j.parent.raiseModifying(j, this) && j.allowDrag(this)
            },
            commit: function(h) {
                if (!h.equals(this.lastPosition)) {
                    this.move(h)
                }
                var o = this.selection;
                o.endDrag(this);
                var k = o.parent;
                k.raiseModified(o, h, this.adjustmentHandle.index);
                k.onItemDropped(o, h);
                for (var n = 0, j = o.nodes.length; n < j; n++) {
                    o.nodes[n].endDrag(this)
                }
                mflayer.callBaseMethod(d, this, "commit", [h])
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.ModifySelectionController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(c) {
        var g = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var b = MindFusion.Drawing.Vector;
        var a = c.MouseEventHandler = function(h) {
            mflayer.initializeBase(a, this);
            this.view = h;
            this.canvasElement = h.get_element();
            this.inputDispatcher = h.mouseInputDispatcher
        };
        a.prototype = {
            attachHandlers: function() {
                var h = this.canvasElement;
                mflayer.addHandlers(h, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(h, {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                mflayer.addHandlers(h, {
                    mouseup: mflayer.createDelegate(this, this.onMouseUp)
                })
            },
            onMouseDown: function(l) {
                c.Keyboard.state = l;
                var k = this.view;
                k.stopCursorChange = false;
                if (c.Touch.lastTouch && new Date() - Touch.lastTouch < 500) {
                    return
                }
                if (!k.enabled) {
                    return
                }
                k.updateFocusable(l);
                var j = this.canvasElement;
                if (j.setCapture) {
                    j.setCapture()
                }
                var h = c.Utils.getCursorPos(l, j);
                this.inputDispatcher.onMouseDown(h, l.button)
            },
            onMouseMove: function(k) {
                c.Keyboard.state = k;
                var j = this.view;
                if (!j.enabled) {
                    return
                }
                j.clearTooltip();
                var h = c.Utils.getCursorPos(k, this.canvasElement);
                this.inputDispatcher.onMouseMove(h)
            },
            onMouseUp: function(k) {
                c.Keyboard.state = k;
                var j = this.view;
                j.stopCursorChange = false;
                j.stopAutoScroll();
                if (c.Touch.lastTouch && new Date() - Touch.lastTouch < 500) {
                    return
                }
                if (!j.enabled) {
                    return
                }
                var h = c.Utils.getCursorPos(k, this.canvasElement);
                this.inputDispatcher.onMouseUp(h, k.button);
                if (document.releaseCapture) {
                    document.releaseCapture()
                }
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.MouseEventHandler")
    })(MindFusion.Diagramming);
    (function(b) {
        var h = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var a = MindFusion.Drawing.GraphicsUnit;
        var g = MindFusion.Drawing.Vector;
        var c = 0;
        var e = 2;
        var j = -1;
        var f = b.MouseInputDispatcher = function(k) {
            mflayer.initializeBase(f, this);
            this.diagram = k;
            this.buttonDown = j;
            this.inputState = {}
        };
        f.prototype = {
            onMouseDown: function(k, p) {
                var o = this.diagram;
                var r = o.clientToDoc(k);
                this.pointerPosition = o.pointerPosition = r;
                var q = a.getMillimeter(o.measureUnit);
                if (this.buttonDown == j) {
                    var n = new Date();
                    var l = this.doubleClickCheck;
                    if (l && n - l.time < 500 && l.button == p && b.Utils.DistanceSq(r, l.position) < q) {
                        this.onDoubleClick(l.position, p);
                        this.doubleClickCheck = null;
                        return
                    }
                    this.buttonDown = p;
                    this.buttonDownPosition = r;
                    this.buttonDownItem = this.getPointedItem();
                    this.doubleClickCheck = {
                        position: r,
                        button: p,
                        time: new Date()
                    }
                }
            },
            onMouseMove: function(k) {
                var l = this.currentController;
                var n = this.diagram;
                var p = a.getMillimeter(n.measureUnit);
                var o = n.clientToDoc(k);
                this.pointerPosition = n.pointerPosition = o;
                this.pointedItem = null;
                if ((n.showAnchors & b.ShowAnchors.Auto) != 0) {
                    n.setAutoAnchorsNode(n.getNodeAt(o, true, true))
                }
                if (this.buttonDown != j) {
                    if (l == null && o.distance(this.buttonDownPosition) >= p) {
                        l = this.currentController = this.selectController();
                        if (l) {
                            l.start(this.buttonDownPosition)
                        }
                    }
                } else {
                    n.trackMouseMovement(o)
                }
                if (l) {
                    if (n.autoScroll && l.supportsAutoScroll()) {
                        n.checkAutoScroll(o)
                    }
                    l.move(o);
                    if (l.supportsCursors()) {
                        n.get_element().style.cursor = l.validate(o) ? n.currentBehavior.currentCursor : h.NotAllowed
                    }
                    if (l.shouldCancelDrag()) {
                        l.cancel(o);
                        this.currentController = null;
                        this.buttonDown = j
                    }
                }
            },
            onMouseUp: function(k, o) {
                var n = this.diagram;
                var q = a.getMillimeter(n.measureUnit);
                var p = n.clientToDoc(k);
                if (this.currentController) {
                    if (this.buttonDown == o && this.currentController.validate(p)) {
                        this.currentController.commit(p);
                        this.currentController = null
                    } else {
                        if (!mflayer.isInstanceOfType(b.InplaceEditController, this.currentController)) {
                            this.currentController.cancel(p);
                            this.currentController = null
                        }
                    }
                } else {
                    var l = this.buttonDownPosition;
                    if (!l) {
                        l = p
                    }
                    if (p.distance(l) < q) {
                        n.onClick(l, o)
                    }
                }
                this.buttonDown = j
            },
            onDoubleClick: function(l, o) {
                var n = this.diagram;
                var q = n.clientToDoc(l);
                var r = n.getItemAt(l, true, true);
                if (r == null) {
                    if (n.getShowLaneGrid() && n.laneGrid.getAllowInplaceEdit()) {
                        var p = {};
                        var k = n.laneGrid.getCellFromPoint(l, p);
                        if (k != null) {
                            k.setInplaceEditBounds(p.cellBounds);
                            k.setIndex(p.column, p.row);
                            this.currentController = new b.InplaceEditController(k);
                            this.currentController.start(l)
                        }
                    }
                } else {
                    n.raiseDoubleClicked(r, l, o);
                    if (n.allowInplaceEdit && !r.notInteractive() && r.hitTestManipulators(q) == null) {
                        this.currentController = new b.InplaceEditController(r);
                        this.currentController.start(l)
                    }
                }
            },
            selectController: function() {
                var k = this.inputState;
                k.buttonDown = this.buttonDown;
                k.pointerPosition = this.buttonDownPosition;
                k.pointedItem = this.buttonDownItem;
                k.pointedHandle = k.pointedItem ? k.pointedItem.handleAtPoint(k.pointerPosition) : null;
                return this.diagram.currentBehavior.createController(k)
            },
            getPointedItem: function() {
                if (this.pointedItem) {
                    return this.pointedItem
                }
                this.pointedItem = this.diagram.getItemAt(this.pointerPosition, true, true);
                return this.pointedItem
            }
        };
        MindFusion.registerClass(f, "MindFusion.Diagramming.MouseInputDispatcher")
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var c = b.PanController = function(h) {
            mflayer.initializeBase(c, this, []);
            this.diagram = h
        };
        c.prototype = {
            start: function(h) {
                mflayer.callBaseMethod(c, this, "start", [h]);
                this.startScroll = this.diagram.getScrollPosition();
                this.panPoint = this.diagram.docToClient(h);
                this.mouseMoved = false
            },
            move: function(h) {
                mflayer.callBaseMethod(c, this, "move", [h]);
                var j = this.diagram.docToClient(h);
                var n = this.startScroll.x - this.diagram.clientToDocLength(j.x - this.panPoint.x);
                var l = this.startScroll.y - this.diagram.clientToDocLength(j.y - this.panPoint.y);
                var k = this.diagram.getViewport();
                this.diagram.scrollStayInDoc(n, l, k);
                this.mouseMoved = true
            },
            supportsAutoScroll: function() {
                return false
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.PanController", b.SinglePointerController)
    })(MindFusion.Diagramming);
    (function(b) {
        var f = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var e = b.RecordingKeyboardDispatcher = function(g, h) {
            mflayer.initializeBase(e, this, [g]);
            this.data = [];
            this.startTimeStamp = h;
            this.eventDispatcher = null
        };
        e.prototype = {
            onKeyUp: function(g, h) {
                mflayer.callBaseMethod(e, this, "onKeyUp", [g, h, null]);
                this.addData("onKeyUp", g, h)
            },
            addData: function(j, g, h) {
                this.ellapsedTime = new Date().getTime();
                var l = (this.ellapsedTime - this.startTimeStamp);
                var k = document.getElementById(g);
                this.data.push({
                    func: j,
                    time: l,
                    targetId: g,
                    key: h,
                    value: k.value
                });
                if (this.addDataId) {
                    clearTimeout(this.addDataId);
                    this.addDataId = null
                }
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.RecordingKeyboardDispatcher", b.KeyboardInputDispatcher)
    })(MindFusion.Diagramming);
    (function(b) {
        var f = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var d = b.RecordingMouseDispatcher = function(g, h) {
            mflayer.initializeBase(d, this, [g]);
            this.data = [];
            this.startTimeStamp = h;
            this.eventDispatcher = null
        };
        d.prototype = {
            onMouseDown: function(g, h) {
                mflayer.callBaseMethod(d, this, "onMouseDown", [g, h]);
                this.addData("onMouseDown", g, h)
            },
            onMouseMove: function(g) {
                mflayer.callBaseMethod(d, this, "onMouseMove", [g]);
                if (!this.addDataId) {
                    var h = this;
                    this.addDataId = setTimeout(function() {
                        h.addData("onMouseMove", g)
                    }, 20)
                }
            },
            onMouseUp: function(g, h) {
                mflayer.callBaseMethod(d, this, "onMouseUp", [g, h]);
                this.addData("onMouseUp", g, h)
            },
            addData: function(j, g, h) {
                this.ellapsedTime = new Date().getTime();
                var k = (this.ellapsedTime - this.startTimeStamp);
                this.data.push({
                    func: j,
                    time: k,
                    position: g,
                    button: h
                });
                if (this.addDataId) {
                    clearTimeout(this.addDataId);
                    this.addDataId = null
                }
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.RecordingMouseDispatcher", b.MouseInputDispatcher)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Controls.MouseCursors;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var f = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Drawing.Vector;
        var c = b.TouchEventHandler = function(h) {
            mflayer.initializeBase(c, this);
            this.view = h;
            this.canvasElement = h.get_element();
            this.inputDispatcher = h.mouseInputDispatcher
        };
        c.prototype = {
            attachHandlers: function() {
                var h = this.canvasElement;
                h.addEventListener("touchstart", mflayer.createDelegate(this, this.onTouchStart), false);
                h.addEventListener("touchmove", mflayer.createDelegate(this, this.onTouchMove), false);
                h.addEventListener("touchend", mflayer.createDelegate(this, this.onTouchEnd), false);
                h.addEventListener("touchcancel", mflayer.createDelegate(this, this.onTouchEnd), false)
            },
            emulateMouse: function(j) {
                var h = j.touches;
                var k = {
                    button: 0,
                    clientX: h[0].clientX,
                    clientY: h[0].clientY,
                    preventDefault: function() {}
                };
                return k
            },
            onTouchStart: function(n) {
                var j = this.view;
                j.touchThreshold = 2.5 * f.getMillimeter(j.measureUnit);
                var l = j.mouseHandler;
                var h = this.inputDispatcher.currentController;
                var k = n.touches;
                if (j.preventDefaultTouch && !h) {
                    b.Touch.lastTouch = null;
                    this.lastTouch = this.emulateMouse(n);
                    l.onMouseDown(this.lastTouch);
                    b.Touch.lastTouch = new Date()
                } else {
                    if (j.preventDefaultTouch && h && k.length > 1) {
                        h.cancel();
                        this.inputDispatcher.currentController = null
                    }
                }
            },
            onTouchMove: function(l) {
                var h = this.view;
                var k = h.mouseHandler;
                var j = l.touches;
                if (h.preventDefaultTouch && j.length == 1) {
                    this.lastTouch = this.emulateMouse(l);
                    k.onMouseMove(this.lastTouch);
                    l.preventDefault()
                }
            },
            onTouchEnd: function(k) {
                var h = this.view;
                var j = h.mouseHandler;
                if (h.preventDefaultTouch) {
                    b.Touch.lastTouch = null;
                    j.onMouseUp(this.lastTouch);
                    b.Touch.lastTouch = new Date()
                }
                h.touchThreshold = 0
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.TouchEventHandler")
    })(MindFusion.Diagramming);
    (function(c) {
        var a = MindFusion.Diagramming.AnchorPoint;
        var d = MindFusion.Diagramming.MarkStyle;
        var b = c.AnchorPattern = function(f, e) {
            this.points = (f) ? f : [];
            this.regIndex = -1;
            if (e != undefined) {
                this.setPatternId(e)
            }
            this.serverRegistered = false
        };
        b.prototype = {
            toJson: function() {
                var e = {
                    id: this.patternId
                };
                if (!e.id || e.id == "" || !this.serverRegistered) {
                    e.points = this.serializePoints()
                }
                return e
            },
            serializePoints: function() {
                var f = [];
                var k = 0;
                for (var j = 0, g = this.points.length; j < g; j++) {
                    var e = this.points[j];
                    e.instanceId = k++;
                    var h = e.toJson();
                    f.push(h)
                }
                return f
            },
            fromJson: function(g) {
                var h = [];
                for (var f = 0; f < g.points.length; f++) {
                    if (g.points[f]) {
                        var e = new a();
                        e.fromJson(g.points[f]);
                        this.points.push(e)
                    }
                }
            },
            setPatternId: function(e) {
                if (b.idMap.contains(e)) {
                    throw new ArgumentException("The AnchorPattern string identifier must be unique.")
                }
                this.patternId = e;
                b.idMap.set(this.patternId, this)
            },
            allowLinkDirection: function(e, f, h) {
                if (this.points == null) {
                    return false
                }
                for (i = 0; i < this.points.length; ++i) {
                    var g = this.points[i];
                    if (e) {
                        if (g.allowOutgoing() && f.raiseValidateAnchorPoint(null, true, i, h)) {
                            return true
                        }
                    } else {
                        if (g.allowIncoming() && f.raiseValidateAnchorPoint(null, false, i, h)) {
                            return true
                        }
                    }
                }
                return false
            },
            assignId: function(e) {
                if (this.patternId != "") {
                    return
                }
                if (b.idMap.contains(e)) {
                    return
                }
                this.setPatternId(e)
            },
            apply: function(g) {
                this.points = [];
                for (var f = 0; f < g.points.length; f++) {
                    var e = g.points[f];
                    this.points.add(e.clone())
                }
            },
            getRegIndex: function() {
                return this.regIndex
            },
            setPoints: function(e) {
                this.points = e
            },
            getPoints: function() {
                return this.points
            },
            getId: function() {
                return this.patternId
            },
            isRegistered: function() {
                if (b.idMap.contains(this.patternId)) {
                    return true
                }
                return false
            }
        };
        b.idMap = new MindFusion.Collections.Dictionary();
        b.decision2In2Out = new b([new a(50, 0, true, false, d.Circle, "blue"), new a(0, 50, true, false, d.Circle, "blue"), new a(50, 100, false, true, d.Rectangle, "green"), new a(100, 50, false, true, d.Rectangle, "red")], "Decision2In2Out");
        b.decision1In3Out = new b([new a(50, 0, true, false, d.Circle, "blue"), new a(0, 50, false, true, d.Rectangle, "red"), new a(50, 100, false, true, d.Rectangle, "green"), new a(100, 50, false, true, d.Rectangle, "red")], "Decision1In3Out");
        b.leftInRightOut = new b([new a(0, 50, true, false, d.Circle, "blue"), new a(100, 50, false, true, d.Rectangle, "blue")], "LeftInRightOut");
        b.topInBottomOut = new b([new a(50, 0, true, false, d.Circle, "blue"), new a(50, 100, false, true, d.Rectangle, "green")], "TopInBottomOut");
        b.fromId = function(e) {
            if (b.idMap.contains(e)) {
                return b.idMap.get(e)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.AnchorPattern")
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Drawing.GraphicsUnit;
        var d = MindFusion.Controls.MouseCursors;
        var b = a.BehaviorBase = function(e) {
            mflayer.initializeBase(b, this);
            this.diagram = e;
            this.currentCursor = d.Move
        };
        b.prototype = {
            createController: function(e) {
                var g = this.diagram;
                var o = e.pointerPosition;
                var q = false;
                var f = g.hitTestManipulators(o);
                if (f != null) {
                    if (f.needsMouseMessages(o)) {
                        return new a.ManipulatorController(g, f)
                    }
                    f.onClick(o);
                    return null
                }
                var l = g.enabled && (g.behavior == a.Behavior.Pan || g.buttonMappedTo(e.buttonDown, a.MouseButtonActions.Pan) || (e.buttonDown == 0 && g.modifierKeyActions.getKeys(a.ModifierKeyAction.Pan, a.Keyboard.state)));
                if (l) {
                    return new a.PanController(g)
                }
                var n = g.enabled && (g.buttonMappedTo(e.buttonDown, a.MouseButtonActions.Magnify) || (e.buttonDown == 0 && g.modifierKeyActions.getKeys(a.ModifierKeyAction.Magnify, a.Keyboard.state)));
                if (n) {
                    return new a.MagnifyController(g)
                }
                if (e.buttonDown == 0 && g.getShowLaneGrid() && g.getLaneGrid().allowResizeHeaders) {
                    var j = g.canResizeLaneHeader(o);
                    if (j) {
                        return new a.LaneGridController(g, j.header, j.resizingHeaderWidth, j.headerBounds)
                    }
                }
                if (!g.buttonMappedTo(e.buttonDown, a.MouseButtonActions.Draw)) {
                    if (!g.buttonMappedTo(e.buttonDown, a.MouseButtonActions.Select)) {
                        return null
                    }
                    q = true
                }
                if ((e.buttonDown == 0 && g.modifierKeyActions.getKeys(a.ModifierKeyAction.Select, a.Keyboard.state)) || q) {
                    var k = new a.CreateSelectionController(g.selection);
                    return k
                }
                var p = null;
                if (g.selection.nodes.length > 1) {
                    var h = g.selection.handleAtPoint(o);
                    if (h && !mflayer.isInstanceOfType(a.FreeFormHandle, h)) {
                        p = g.selection;
                        var k = new a.ModifySelectionController(g.selection, h);
                        return k
                    }
                }
                var h = g.getHandleAt(o);
                p = g.activeItem;
                if (p && h == null) {
                    h = p.handleAtPoint(o)
                }
                if (h) {
                    var p = h.item;
                    if (p == g.autoHandlesItem) {
                        g.selection.clear();
                        g.selection.addItem(p);
                        g.setAutoHandlesItem(null)
                    }
                    var k = mflayer.isInstanceOfType(a.DiagramNode, p) ? new a.ModifyNodeController(p, h) : new a.ModifyLinkController(p, h);
                    return k
                }
                return null
            },
            createLink: function(f, e) {
                var g = new a.DiagramLink(this.diagram, f, e);
                g.originConnection.chooseBestAnchorPoint(e);
                return g
            },
            setModfCursor: function(e, n) {
                var j = n.index;
                var h = mflayer.isInstanceOfType(a.DiagramNode, n.item) ? n.item : null;
                if (h == null || j == 8 || mflayer.isInstanceOfType(a.FreeFormHandle, n)) {
                    return this.setCurrentCursor(d.Move)
                }
                if (j == 9) {
                    return this.setCurrentCursor(d.Rotate)
                }
                if (h.getRotationAngle() != 0) {
                    var f = 0,
                        g = 0;
                    var l = 360 / 16;
                    var k = MindFusion.Geometry.cartesianToPolar(h.getCenter(), e);
                    k.a = MindFusion.Geometry.radianToDegree(k.a);
                    f = parseInt((360 - k.a) % 360);
                    if (f >= 1 * l && f < 3 * l) {
                        this.currentCursor = d.DiagonalResize
                    } else {
                        if (f >= 3 * l && f < 5 * l) {
                            this.currentCursor = d.VerticalResize
                        } else {
                            if (f >= 5 * l && f < 7 * l) {
                                this.currentCursor = d.CounterDiagonalResize
                            } else {
                                if (f >= 7 * l && f < 9 * l) {
                                    this.currentCursor = d.HorizontalResize
                                } else {
                                    if (f >= 9 * l && f < 11 * l) {
                                        this.currentCursor = d.DiagonalResize
                                    } else {
                                        if (f >= 11 * l && f < 13 * l) {
                                            this.currentCursor = d.VerticalResize
                                        } else {
                                            if (f >= 13 * l && f < 15 * l) {
                                                this.currentCursor = d.CounterDiagonalResize
                                            } else {
                                                this.currentCursor = d.HorizontalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (j == 0 || j == 2) {
                        this.currentCursor = d.DiagonalResize
                    }
                    if (j == 1 || j == 3) {
                        this.currentCursor = d.CounterDiagonalResize
                    }
                    if (j == 4 || j == 6) {
                        this.currentCursor = d.VerticalResize
                    }
                    if (j == 5 || j == 7) {
                        this.currentCursor = d.HorizontalResize
                    }
                }
                return this.currentCursor
            },
            getResizeCursor: function(e) {
                if (e == 0 || e == 2) {
                    return d.DiagonalResize
                }
                if (e == 1 || e == 3) {
                    return d.CounterDiagonalResize
                }
                if (e == 4 || e == 6) {
                    return d.VerticalResize
                }
                if (e == 5 || e == 7) {
                    return d.HorizontalResize
                }
                return null
            },
            setMouseCursor: function(e, f) {},
            setCurrentCursor: function(e) {
                this.currentCursor = e;
                return e
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.BehaviorBase")
    })(MindFusion.Diagramming);
    (function(b) {
        var c = MindFusion.Drawing.Rect;
        var a = b.CellEditor = function(e, d) {
            this.table = e;
            this.cell = d.cell;
            this.rect = d.cellRect;
            this.column = d.column;
            this.row = d.row
        };
        a.prototype = {
            getTextToEdit: function() {
                return this.cell.getText()
            },
            getEditRect: function(d) {
                if (this.table.rotationAngle == 0) {
                    return this.rect
                } else {
                    return b.Utils.rotateRect(this.rect.clone(), this.table.getBounds().center(), this.table.rotationAngle)
                }
            },
            createEditArgs: function(d, e) {
                return new b.CellEventArgs({
                    node: this.table,
                    cell: this.cell,
                    oldText: d,
                    newText: e,
                    column: this.column,
                    row: this.row
                })
            },
            setEditedText: function(d) {
                this.cell.setText(d)
            },
            getDiagramItem: function() {
                return this.table
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.CellEditor")
    })(MindFusion.Diagramming);
    (function(c) {
        var e = MindFusion.Controls.MouseCursors;
        var a = MindFusion.Diagramming.ColumnStyle;
        var d = MindFusion.Drawing.GraphicsUnit;
        var b = c.ColumnResizer = function(g, f) {
            mflayer.initializeBase(b, this, [g]);
            this.columnIndex = f;
            this.column = this.node.getColumn(this.columnIndex);
            this.startWidth = this.column.width;
            this.autoWidth = this.column.columnStyle == a.AutoWidth
        };
        b.prototype = {
            hitTest: function(f) {
                return false
            },
            needsMouseMessages: function(f) {
                return true
            },
            setMouseCursor: function(g) {
                if (this.node.getRotationAngle() != 0) {
                    var f = this.node.getRotationAngle();
                    if (f >= -180 && f < -135) {
                        return e.DiagonalResize
                    } else {
                        if (f >= -135 && f < -90) {
                            return e.VerticalResize
                        } else {
                            if (f >= -90 && f < -45) {
                                return e.CounterDiagonalResize
                            } else {
                                if (f >= -45 && f < 0) {
                                    return e.HorizontalResize
                                } else {
                                    if (f >= 0 && f < 45) {
                                        return e.DiagonalResize
                                    } else {
                                        if (f >= 45 && f < 90) {
                                            return e.VerticalResize
                                        } else {
                                            if (f >= 90 && f < 135) {
                                                return e.CounterDiagonalResize
                                            } else {
                                                return e.HorizontalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return e.HorizontalResize
            },
            localPoint: function(f) {
                if (this.node.getRotationAngle() != 0) {
                    return c.Utils.rotatePointAt(f, this.node.bounds.center(), -this.node.getRotationAngle())
                }
                return f.clone()
            },
            onMouseDown: function(g) {
                this.mouseDown = true;
                var f = this.localPoint(g);
                this.current = this.last = f.x
            },
            onMouseMove: function(k) {
                if (!this.mouseDown) {
                    return
                }
                var h = this.localPoint(k);
                this.current = h.x;
                var g = this.node.getParent();
                if (!this.resizing) {
                    if (Math.abs(this.current - this.last) >= d.getMillimeter(g.measureUnit) * 2) {
                        this.resizing = true;
                        if (g.getUndoEnabled()) {
                            this.cmd = new c.ResizeTableColumnCommand(g, this.node, this.column)
                        }
                    }
                }
                if (this.resizing) {
                    if (this.column.columnStyle == a.AutoWidth) {
                        this.node.setColumnStyle(this.column, a.FixedWidth)
                    }
                    var f = this.column.width;
                    this.node.setColumnWidth(this.column, Math.max(d.getMillimeter(g.measureUnit), this.column.width + (this.current - this.last)));
                    var j = {
                        value: undefined
                    };
                    if (!g.raiseTableColumnResizing(this.node, this.columnIndex, k, 0, j)) {
                        this.node.setColumnWidth(this.column, f)
                    }
                    if (j.value) {
                        this.cancel()
                    }
                    if (f != this.column.width) {
                        this.last = this.current
                    }
                }
            },
            onMouseUp: function(g) {
                if (this.resizing) {
                    var f = this.node.getParent();
                    if (f.getUndoEnabled()) {
                        f.undoManager.executeCommand(this.cmd)
                    }
                    f.raiseTableColumnResized(this.node, this.columnIndex, g, 0)
                }
                this.mouseDown = false;
                this.resizing = false
            },
            cancel: function() {
                if (this.resizing) {
                    this.mouseDown = false;
                    this.resizing = false;
                    this.node.setColumnWidth(this.column, this.startWidth);
                    if (this.autoWidth) {
                        this.column.setColumnStyle(a.AutoWidth)
                    }
                    this.cmd = null
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ColumnResizer", c.Manipulator)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.Command = function(c) {
            this.diagram = c
        };
        b.prototype = {
            execute: function() {},
            undo: function() {},
            redo: function() {}
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.Command")
    })(MindFusion.Diagramming);
    (function(mdiag) {
        var Component = MindFusion.Drawing.Component;
        var CompositeNode = mdiag.CompositeNode = function(parent) {
            mdiag.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(CompositeNode, this, [parent]);
            this.root = new mdiag.SimplePanel();
            mdiag.Diagram.suppressSetDirty = false
        };
        CompositeNode.classFromTemplate = function(className, jsonTemplate, init) {
            var shortName = className;
            var ns = window;
            var qualifiedNameParts = className.split(".");
            if (qualifiedNameParts.length > 1) {
                shortName = qualifiedNameParts[qualifiedNameParts.length - 1];
                ns = eval(qualifiedNameParts.slice(0, -1).join("."))
            }
            var ctor = ns[shortName] = function(parent) {
                mflayer.initializeBase(ctor, this, [parent]);
                this.loadTemplate(jsonTemplate);
                if (init) {
                    init.apply(this, [parent])
                }
            };
            ctor.prototype = {};
            MindFusion.registerClass(ctor, className, CompositeNode);
            return ctor
        };
        CompositeNode.prototype = {
            clone: function() {
                mdiag.Diagram.suppressSetDirty = true;
                var copy = mflayer.callBaseMethod(CompositeNode, this, "clone", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var setter = props["set" + method.substring(3)];
                        setter.call(copy, getter.call(this))
                    }
                }
                mdiag.Diagram.suppressSetDirty = false;
                return copy
            },
            firstCharLower: function(string) {
                return string.charAt(0).toLowerCase() + string.slice(1)
            },
            toJson: function() {
                var json = mflayer.callBaseMethod(CompositeNode, this, "toJson", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        json[propName] = getter.call(this)
                    }
                }
                return json
            },
            fromJson: function(json) {
                mflayer.callBaseMethod(CompositeNode, this, "fromJson", [json]);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "set") {
                            continue
                        }
                        var setter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        setter.call(this, json[propName])
                    }
                }
            },
            saveState: function() {
                var state = mflayer.callBaseMethod(CompositeNode, this, "saveState", []);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "get") {
                            continue
                        }
                        var getter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        state[propName] = getter.call(this)
                    }
                }
                return state
            },
            restoreState: function(state) {
                mflayer.callBaseMethod(CompositeNode, this, "restoreState", [state]);
                var props = this.propertyMap;
                if (props) {
                    for (method in props) {
                        if (method.substring(0, 3) != "set") {
                            continue
                        }
                        var setter = props[method];
                        var propName = this.firstCharLower(method.substring(3));
                        setter.call(this, state[propName])
                    }
                }
            },
            loadTemplate: function(jsonTemplate) {
                var loader = new mdiag.ComponentLoader(this.invalidate.bind(this));
                var rootPanel = loader.componentFromJson(jsonTemplate, this);
                this.root = rootPanel;
                this.namedComponents = loader.nameMap;
                this.propertyMap = loader.propertyMap;
                var prototype = this.constructor.prototype;
                for (method in loader.propertyMap) {
                    if (!prototype[method]) {
                        prototype[method] = loader.propertyMap[method]
                    }
                }
            },
            getComponent: function(name) {
                return this.namedComponents[name]
            },
            updateCanvasElements: function() {
                var rect = this.bounds;
                this.graphicsContainer.content = [this.root];
                Component.context = this.parent;
                this.root.measure(rect.width, rect.height);
                this.root.arrange(rect.x, rect.y, rect.width, rect.height);
                if (this.outlineRenderer) {
                    this.outlineRenderer.updateData(this.diagramCoords(this.outlineRenderer.shape), this.rotationAngle)
                }
            },
            getObjectToEdit: function(point) {
                var component = this.root.hitTest(point);
                if (mflayer.isInstanceOfType(MindFusion.Drawing.Text, component)) {
                    return new mdiag.TextEditor(this, component)
                }
                return this
            },
            diagramCoords: function(component) {
                var bounds = component.getBounds().clone();
                while (component.parent != null) {
                    component = component.parent;
                    bounds.x += component.x;
                    bounds.y += component.y
                }
                return bounds
            },
            containsPoint: function(point) {
                var bounds = this.getRotatedBounds();
                if (!bounds.containsPoint(point)) {
                    return false
                }
                if (mdiag.Utils.pointInPolygon(point, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(point)) {
                    return true
                }
                return false
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                if (this.outlineRenderer) {
                    var approximation = mdiag.Utils.getApproximatingContext();
                    this.outlineRenderer.getOutline().addToContext(approximation);
                    return approximation.transformAndGetPoints()
                }
                var p = [];
                p.push(this.bounds.topLeft());
                p.push(this.bounds.topRight());
                p.push(this.bounds.bottomRight());
                p.push(this.bounds.bottomLeft());
                mdiag.Utils.rotatePointsAt(p, mdiag.Utils.getCenter(this.bounds), this.rotationAngle);
                return p
            },
            outlineRenderer: null
        };
        MindFusion.registerClass(CompositeNode, "MindFusion.Diagramming.CompositeNode", mdiag.DiagramNode);
        var TextEditor = mdiag.TextEditor = function(node, component) {
            this.node = node;
            this.component = component
        };
        TextEditor.prototype = {
            getTextToEdit: function() {
                return this.component.getText()
            },
            getEditRect: function(point) {
                return this.node.diagramCoords(this.component)
            },
            createEditArgs: function(oldText, newText) {
                return new mdiag.ComponentEventArgs({
                    node: this.node,
                    component: this.component,
                    oldText: oldText,
                    newText: newText
                })
            },
            setEditedText: function(newText) {
                this.component.setText(newText)
            },
            getDiagramItem: function() {
                return this.node
            }
        };
        MindFusion.registerClass(TextEditor, "MindFusion.Diagramming.TextEditor")
    })(MindFusion.Diagramming);
    (function(b) {
        var d = MindFusion.Drawing.Point;
        var a = b.ConnectionPoint = function(g, f, e) {
            this.node = g;
            this.link = f;
            this.incoming = e;
            this.anchorPointDetails = {
                index: -1,
                point: new MindFusion.Drawing.Point(0, 0)
            };
            this.type = this.constructor.__typeName
        };
        a.prototype = {
            addLinkToNode: function() {
                if (this.incoming) {
                    this.node.addIncomingLink(this.link)
                } else {
                    this.node.addOutgoingLink(this.link)
                }
            },
            removeLinkFromNode: function() {
                if (this.incoming) {
                    this.node.removeIncomingLink(this.link)
                } else {
                    this.node.removeOutgoingLink(this.link)
                }
            },
            sameNode: function(f) {
                var e = f.node;
                return (e != null && e === this.node)
            },
            saveEndRelative: function(h) {
                if (h === undefined) {
                    h = true
                }
                var e = this.incoming ? this.link.getEndPoint() : this.link.getStartPoint();
                var k = this.node.rotationAngle;
                if (k !== 0) {
                    var g = b.Utils.getCenter(this.node.bounds);
                    e = b.Utils.rotatePointAt(e, g, -k)
                }
                if (h) {
                    var f = b.ContainerNode.getFoldedContainer(this.node);
                    if (f) {
                        var j = f.getBounds();
                        this.relativePosition = b.Utils.getRectPtPercent(e, j);
                        return
                    }
                }
                this.relativePosition = b.Utils.getRectPtPercent(e, this.node.bounds)
            },
            chooseBestAnchorPoint: function(e) {
                this.anchorPointDetails = this.getNearestAnchorPoint(e);
                if (!this.anchorPointDetails) {
                    this.anchorPointDetails = this.getNearestBorderPoint(e)
                }
            },
            getNearestAnchorPoint: function(e) {
                if (!this.node.anchorPattern) {
                    return null
                }
                var f = this.node.getNearestAnchor(e, this.link, this.incoming);
                if (f.index === -1) {
                    return null
                }
                return f
            },
            getNearestBorderPoint: function(e) {
                var g = this.node.getNearestBorderPoint(e);
                var f = b.Utils.getRectPtPercent(g, this.node.bounds);
                return {
                    point: g,
                    location: f,
                    index: -1
                }
            },
            alignEndPointToBorder: function(e) {
                this.anchorPointDetails = this.getNearestAnchor(e, this.link, this.incoming)
            },
            linkChanges: function(f, e) {
                return (this.node !== f)
            },
            getInitialPoint: function() {
                return this.node.getCenter()
            },
            nodesIntersect: function(e) {
                return b.DiagramNode.nodesIntersect(this.node, e.node)
            },
            getIntersection: function(f, e) {
                return this.node.getIntersection(f, e)
            },
            getNodeRect: function() {
                return this.node.bounds
            },
            getLocation: function() {
                var f = b.ContainerNode.getFoldedContainer(this.node);
                if (f) {
                    var e = b.Utils.rectPtFromPercent(this.relativePosition, f.getBounds());
                    return e
                }
                return this.getEndPoint()
            },
            getEndPoint: function() {
                var e = b.Utils.rectPtFromPercent(this.relativePosition, this.node.bounds);
                var g = this.node.rotationAngle;
                if (g !== 0) {
                    var f = b.Utils.getCenter(this.node.bounds);
                    e = b.Utils.rotatePointAt(e, f, g)
                }
                return e
            },
            canMoveLink: function(e) {
                return this.node.containsPoint(e)
            },
            getType: function() {
                return this.type
            },
            getNearestAnchor: function(e, g, f) {
                return this.node.getNearestAnchor(e, g, f)
            },
            clone: function(f, e) {
                if (!e) {
                    e = this.node
                }
                var g = e.createConnectionPoint(f, new d(), this.incoming);
                if (!mflayer.isInstanceOfType(b.DummyNode, e) && e.anchorPattern && e.anchorPattern.points.length > this.anchorPointDetails.index) {
                    g.anchorPointDetails.index = this.anchorPointDetails.index
                }
                g.relativePosition = this.relativePosition.clone();
                return g
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.ConnectionPoint");
        var c = b.DummyConnectionPoint = function(g, f, e) {
            mflayer.initializeBase(c, this, [null, g, f]);
            this.point = e;
            this.node = this.link.getDummyNode()
        };
        c.prototype = {
            getInitialPoint: function() {
                return this.point
            },
            getNearestAnchor: function(e, g, f) {
                return {
                    index: 0,
                    point: this.point,
                    location: this.point
                }
            },
            getNearestBorderPoint: function(e) {
                return {
                    index: 0,
                    point: e,
                    location: e
                }
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.DummyConnectionPoint", a)
    })(MindFusion.Diagramming);
    (function(b) {
        var k = MindFusion.Collections.ArrayList;
        var e = MindFusion.Drawing.Line;
        var h = MindFusion.Collections.Dictionary;
        var a = MindFusion.Drawing.GraphicsUnit;
        var c = MindFusion.Drawing.Rect;
        var j = MindFusion.Diagramming.EffectPhase;
        var f = MindFusion.Drawing.Path;
        var g = MindFusion.Diagramming.FitSize;
        var d = b.ContainerNode = function(l) {
            b.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(d, this, [l]);
            this.captionHeight = 6;
            this.text.fitInBounds = true;
            this.children = [];
            this.margin = 3;
            this.allowAddChildren = true;
            this.allowRemoveChildren = true;
            this.zOrder = [];
            this.clipChildren = true;
            d.usingContainerNodes = true;
            this.graphicsContainer.drawCallback = mflayer.createCallback(this.drawChildren, this);
            b.Diagram.suppressSetDirty = false
        };
        d.prototype = {
            clone: function() {
                b.Diagram.suppressSetDirty = true;
                var l = mflayer.callBaseMethod(d, this, "clone", []);
                l.captionHeight = this.captionHeight;
                l.captionBackBrush = this.captionBackBrush;
                l.shape = this.shape;
                l.allowAddChildren = this.allowAddChildren;
                l.allowRemoveChildren = this.allowRemoveChildren;
                l.margin = this.margin;
                l.foldIconSize = this.foldIconSize;
                l.setFoldable(this.getFoldable());
                l.setFolded(this.getFolded());
                l.setEnableStyledText(this.getEnableStyledText());
                l.unfoldedSize = this.unfoldedSize;
                l.shape = this.shape;
                b.Diagram.suppressSetDirty = false;
                return l
            },
            toJson: function() {
                var l = mflayer.callBaseMethod(d, this, "toJson", []);
                l.captionHeight = this.captionHeight;
                l.captionBackBrush = this.captionBackBrush;
                l.allowAddChildren = this.allowAddChildren;
                l.allowRemoveChildren = this.allowRemoveChildren;
                l.margin = this.margin;
                l.clipChildren = this.clipChildren;
                l.foldIconSize = this.foldIconSize;
                l.foldable = this.getFoldable();
                l.folded = this.getFolded();
                l.enableStyledText = this.getEnableStyledText();
                l.unfoldedSize = this.unfoldedSize;
                l.shape = this.shape;
                return l
            },
            fromJson: function(l) {
                mflayer.callBaseMethod(d, this, "fromJson", [l]);
                this.captionHeight = l.captionHeight;
                this.captionBackBrush = l.captionBackBrush;
                this.allowAddChildren = l.allowAddChildren;
                this.allowRemoveChildren = l.allowRemoveChildren;
                this.margin = l.margin;
                if (l.clipChildren != undefined) {
                    this.clipChildren = l.clipChildren
                }
                if (l.foldIconSize != undefined) {
                    this.foldIconSize = l.foldIconSize
                }
                this.setFoldable(l.foldable);
                this.setFolded(l.folded);
                this.setEnableStyledText(l.enableStyledText);
                if (l.folded) {
                    this.setBounds(new c(l.bounds.x, l.bounds.y, l.bounds.width, l.bounds.height))
                }
                if (l.unfoldedSize) {
                    this.unfoldedSize = MindFusion.Drawing.Size.copy(l.unfoldedSize)
                }
                if (l.shape) {
                    this.setShape(l.shape)
                }
            },
            loadFromXml: function(o, n) {
                mflayer.callBaseMethod(d, this, "loadFromXml", [o, n]);
                if (this.getText() == "") {
                    this.setText(n.readString("Caption", o))
                }
                this.captionHeight = n.readFloat("CaptionHeight", o);
                this.captionBackBrush = n.readBrush("CaptionBackBrush", o);
                var l = n.readStringFormat("CaptionFormat", o);
                if (l) {
                    this.setTextAlignment(l.alignment);
                    this.setLineAlignment(l.lineAlignment)
                } else {
                    this.setTextAlignment(n.readInt("TextAlignment", o));
                    this.setLineAlignment(n.readInt("TextVerticalAlignment", o))
                }
                this.margin = n.readFloat("Margin", o);
                this.foldIconSize = n.readFloat("FoldIconSize", o, null);
                this.folded = n.readBool("Folded", o);
                this.setFoldable(n.readBool("Foldable", o));
                this.unfoldedSize = n.readSizeF("UnfoldedSize", o);
                this.setEnableStyledText(n.readBool("EnableStyledText", o));
                this.shape = n.readInt("Shape", o, b.SimpleShape.Rectangle);
                this.allowAddChildren = n.readBool("AllowAddChildren", o, true);
                this.allowRemoveChildren = n.readBool("AllowRemoveChildren", o, true);
                this.clipChildren = n.readBool("ClipChildren", o, true)
            },
            saveToXml: function(n, l) {
                mflayer.callBaseMethod(d, this, "saveToXml", [n, l]);
                l.writeFloat(this.captionHeight, "CaptionHeight", n);
                l.writeBrush(this.captionBackBrush, "CaptionBackBrush", n);
                l.writeInt(this.getTextAlignment(), "TextAlignment", n);
                l.writeInt(this.getLineAlignment(), "TextVerticalAlignment", n);
                l.writeFloat(this.margin, "Margin", n);
                if (this.foldIconSize) {
                    l.writeFloat(this.foldIconSize, "FoldIconSize", n)
                }
                l.writeBool(this.folded, "Folded", n);
                l.writeBool(this.getFoldable(), "Foldable", n);
                l.writeBool(this.getEnableStyledText(), "EnableStyledText", n);
                if (this.unfoldedSize) {
                    l.writeSizeF(this.unfoldedSize, "UnfoldedSize", n)
                }
                l.writeInt(this.getShape(), "Shape", n);
                l.writeBool(this.allowAddChildren, "AllowAddChildren", n);
                l.writeBool(this.allowRemoveChildren, "AllowRemoveChildren", n);
                l.writeBool(this.clipChildren, "ClipChildren", n)
            },
            add: function(n) {
                if (n.containsRecursively && n.containsRecursively(this)) {
                    return
                }
                var l = n.getMasterNode();
                if (l) {
                    if (l == this) {
                        return
                    }
                    l.detachSub(n)
                }
                l = this.getMasterNode();
                if (l == n) {
                    return
                }
                if (n.container) {
                    if (n.container == this) {
                        return
                    }
                    n.container.remove(n)
                }
                this.children.push(n);
                n.container = this;
                this.setDiagramDirty()
            },
            remove: function(n, l) {
                if (k.remove(this.children, n)) {
                    this.setDiagramDirty();
                    delete n.container;
                    if (l) {
                        this.raiseChildRemoved(n)
                    }
                    if (this.parent) {
                        this.parent.invalidateZOrder()
                    }
                }
            },
            drawChildren: function(q, n, t, s) {
                if (s.folded) {
                    return
                }
                q.save();
                var r = s.clipChildren ? s.getContentPath() : null;
                if (r) {
                    r.addToContext(q, false);
                    q.clip()
                }
                for (var p = 0, o = s.zOrder.length; p < o; p++) {
                    var u = s.zOrder[p];
                    if (u.getVisible() && !u.getTopLevel()) {
                        u.graphicsContainer.draw(q, n, t)
                    }
                }
                q.restore()
            },
            hitTest: function(o, n, p, l) {
                if (this.parent != null && !this.parent.isItemVisible(this)) {
                    return null
                }
                if (!this.folded) {
                    for (var q = this.zOrder.length - 1; q >= 0; q--) {
                        var s = this.zOrder[q];
                        if (p && mflayer.isInstanceOfType(b.DiagramLink, s)) {
                            continue
                        }
                        var r = s.hitTest(o, n, p, l);
                        if (r != null) {
                            return r
                        }
                    }
                }
                return mflayer.callBaseMethod(d, this, "hitTest", [o, n, p, l])
            },
            getContentPath: function() {
                var p = this.bounds.clone();
                p.y += this.captionHeight;
                p.height -= this.captionHeight;
                var o = new f();
                if (p.width > 0 && p.height > 0) {
                    o.addRect(p.x, p.y, p.width, p.height);
                    var q = this.getRotationAngle();
                    if (q != 0) {
                        var l = this.getCenter();
                        var n = new MindFusion.Drawing.Matrix();
                        n.rotateAt(q, l.x, l.y);
                        o.transform = n
                    }
                } else {
                    o.addRect(this.bounds.x, this.bounds.y, 0, 0)
                }
                return o
            },
            getClipChildren: function() {
                return this.clipChildren
            },
            setClipChildren: function(l) {
                if (this.clipChildren !== l) {
                    this.clipChildren = l;
                    this.setDiagramDirty()
                }
            },
            getChildren: function() {
                return this.children
            },
            addToZOrder: function(l) {
                this.zOrder.push(l);
                l.setTopLevel(false)
            },
            updateZOrder: function() {
                this.zOrder = [];
                this.visitChildren();
                this.zOrder.sort(this.sortByIndex)
            },
            sortByIndex: function(n, l) {
                return n.getRuntimeIndex() - l.getRuntimeIndex()
            },
            visitChildren: function() {
                var p = this.children;
                for (var q = 0, n = p.length; q < n; q++) {
                    this.addToZOrder(p[q])
                }
                var o = new h();
                this.getLinksInScope(o);
                o.forEach(function(l) {
                    if (o.get(l) == 3) {
                        this.addToZOrder(l)
                    }
                }, this)
            },
            getLinksInScope: function(w) {
                var n = this.children;
                for (var s = 0, q = n.length; s < q; s++) {
                    var o = n[s];
                    var t = [];
                    o.getAllOutgoingLinks(t);
                    for (var r = 0; r < t.length; r++) {
                        var u = 0;
                        if (w.contains(t[r])) {
                            u = w.get(t[r])
                        }
                        w.set(t[r], u + 1)
                    }
                    var p = [];
                    o.getAllIncomingLinks(p);
                    for (var r = 0; r < p.length; r++) {
                        var u = 0;
                        if (w.contains(p[r])) {
                            u = w.get(p[r])
                        }
                        w.set(p[r], u + 1)
                    }
                    if (mflayer.isInstanceOfType(d, o)) {
                        var v = new h();
                        o.getLinksInScope(v);
                        v.forEach(function(l) {
                            if (w.contains(l)) {
                                w.set(l, w.get(l) + v.get(l))
                            } else {
                                w.set(l, v.get(l))
                            }
                        })
                    }
                }
                w.forEach(function(l) {
                    if (w.get(l) >= 2) {
                        w.set(l, w.get(l) + 1)
                    }
                })
            },
            getIntersectingItems: function(s, t, v, r) {
                if (this.folded || !this.parent.isItemVisible(this)) {
                    return
                }
                var q = b.Utils.normalizeRect(s);
                if (r) {
                    for (var p = 0, n = this.zOrder.length; p < n; p++) {
                        var u = this.zOrder[p];
                        if (!u.notInteractive() && u.intersects(s)) {
                            t.push(u);
                            if (!v) {
                                return
                            }
                            if (mflayer.isInstanceOfType(d, u)) {
                                if (u.intersects(s)) {
                                    u.getIntersectingItems(s, t, v, r)
                                }
                            }
                        }
                    }
                } else {
                    for (var p = 0, n = this.zOrder.length; p < n; p++) {
                        var u = this.zOrder[p];
                        var o = u.getRotatedBounds();
                        if (!u.notInteractive() && q.contains(o)) {
                            t.push(u);
                            if (!v) {
                                return
                            }
                            if (mflayer.isInstanceOfType(d, u)) {
                                if (u.intersects(s)) {
                                    u.getIntersectingItems(s, t, v, r)
                                }
                            }
                        }
                    }
                }
            },
            countIntersectingItems: function(t, u, w, s) {
                if (this.folded || !this.parent.isItemVisible(this)) {
                    return
                }
                var r = 0;
                var q = b.Utils.normalizeRect(t);
                if (s) {
                    for (var p = 0, n = this.zOrder.length; p < n; p++) {
                        var v = this.zOrder[p];
                        if (!v.notInteractive() && v.intersects(t)) {
                            r += 1;
                            if (mflayer.isInstanceOfType(d, v)) {
                                if (v.intersects(t)) {
                                    r += v.countIntersectingItems(t, u, w, s)
                                }
                            }
                        }
                    }
                } else {
                    for (var p = 0, n = this.zOrder.length; p < n; p++) {
                        var v = this.zOrder[p];
                        var o = v.getRotatedBounds();
                        if (!v.notInteractive() && q.contains(o)) {
                            r += 1;
                            if (mflayer.isInstanceOfType(d, v)) {
                                if (v.intersects(t)) {
                                    r += v.countIntersectingItems(t, u, w, s)
                                }
                            }
                        }
                    }
                }
            },
            containsPoint: function(l) {
                var n = this.getRotatedBounds();
                if (!n.containsPoint(l)) {
                    return false
                }
                if (b.Utils.pointInPolygon(l, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(l)) {
                    return true
                }
                return false
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var l = [];
                l.push(this.bounds.topLeft());
                l.push(this.bounds.topRight());
                l.push(this.bounds.bottomRight());
                l.push(this.bounds.bottomLeft());
                b.Utils.rotatePointsAt(l, b.Utils.getCenter(this.bounds), this.rotationAngle);
                return l
            },
            updateCanvasElements: function() {
                var t = this.graphicsContainer.content = [];
                var A = this.getEffectiveStroke();
                var z = this.getEffectiveStrokeThickness();
                var C = this.getEffectiveStrokeDashStyle();
                var u = this.getEffectiveBrush();
                var o = {
                    brush: u,
                    phase: j.BeforeFill
                };
                this.applyEffects(t, o);
                if (o.brush) {
                    u = o.brush
                }
                this.graphicsContainer.rotationAngle = this.rotationAngle;
                this.graphicsContainer.pivot = this.bounds.center();
                var w = this.bounds.clone();
                var l = w;
                if (this.shape == b.SimpleShape.RoundedRectangle) {
                    var n = a.getMillimeter(this.parent.measureUnit);
                    var s = n * 2.5;
                    l = new f();
                    l.addRoundRect(w, s)
                }
                var r = l.clone();
                r.pen = null;
                r.brush = u;
                r.shadow = this.createShadow();
                t.push(r);
                if (this.captionBackBrush) {
                    var q = w.clone();
                    q.height = this.captionHeight;
                    q.brush = this.captionBackBrush;
                    q.pen = null;
                    if (this.shape == b.SimpleShape.RoundedRectangle) {
                        var p = new MindFusion.Drawing.Container();
                        p.clip = l;
                        p.content.push(q);
                        t.push(p)
                    } else {
                        t.push(q)
                    }
                }
                this.applyEffects(t, {
                    phase: j.AfterFill
                });
                if (this.captionHeight > 0 && this.captionHeight < w.height) {
                    var v = w.y + this.captionHeight;
                    var B = new e(w.x, v, w.right(), v);
                    B.setPen(A);
                    B.strokeThickness = z;
                    B.strokeDashStyle = C;
                    if (this.shape == b.SimpleShape.RoundedRectangle && (v < s || v > w.height - s)) {
                        B.clipPath = l
                    }
                    t.push(B)
                }
                w = w.clone();
                w.height = this.captionHeight;
                if (this.folder) {
                    w.width -= this.captionHeight
                }
                this.text.setBounds(w, 0);
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.ignoreTransform = this.rotationAngle != 0;
                t.push(this.text);
                l.pen = A;
                l.strokeThickness = z;
                l.strokeDashStyle = C;
                l.brush = null;
                t.push(l);
                this.addManipulatorVisuals(t);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            setShape: function(l) {
                if (this.shape != l) {
                    this.shape = l;
                    this.invalidate()
                }
            },
            getShape: function() {
                if (this.shape === undefined) {
                    return b.SimpleShape.Rectangle
                }
                return this.shape
            },
            getEditRect: function(l) {
                var o = this.bounds.clone();
                o.height = this.captionHeight;
                if (this.rotationAngle == 0) {
                    return o
                } else {
                    var n = this.rotateRect(this.bounds.clone());
                    return n.transformRect(o)
                }
            },
            setCaptionHeight: function(l) {
                if (this.captionHeight !== l) {
                    this.captionHeight = l;
                    this.invalidate()
                }
            },
            getCaptionHeight: function() {
                return this.captionHeight
            },
            setCaptionBackBrush: function(l) {
                if (this.captionBackBrush !== l) {
                    this.captionBackBrush = l;
                    this.invalidate()
                }
            },
            getCaptionBackBrush: function() {
                return this.captionBackBrush
            },
            addNodes: function(n) {
                var l = false;
                if (n) {
                    var o = [];
                    k.forEach(n, function(p) {
                        if (p.container != this) {
                            this.add(p);
                            if (p.container == this) {
                                l = true;
                                o.push(p)
                            }
                        }
                    }, this);
                    if (l) {
                        this.resizeToFitChildren()
                    }
                    k.forEach(o, function(p) {
                        this.raiseChildAdded(p)
                    }, this)
                }
                return l
            },
            containsRecursively: function(l) {
                return l.container == this || l.container && this.containsRecursively(l.container)
            },
            onDropOver: function(p) {
                if (p.container == this) {
                    return true
                }
                var l = [];
                if (mflayer.isInstanceOfType(b.Selection, p)) {
                    var n = p;
                    if (this.selected) {
                        return false
                    }
                    k.forEach(n.nodes, function(q) {
                        if (!k.contains(this.children, q)) {
                            l.push(q)
                        }
                    }, this)
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramNode, p)) {
                        var o = p;
                        if (!k.contains(this.children, o)) {
                            if (o.container == this) {
                                return true
                            }
                            l.push(o)
                        }
                    }
                }
                if (this.allowAddChildren && l.length > 0) {
                    this.parent.onStartInteraction(this);
                    if (this.addNodes(l)) {
                        return true
                    }
                }
                return false
            },
            visitNodes: function(l, s, q) {
                if (!this.folded && this.parent != null && this.parent.isItemVisible(this)) {
                    for (var o = this.zOrder.length - 1; o >= 0; o--) {
                        var p = this.zOrder[o];
                        if (mflayer.isInstanceOfType(b.DiagramNode, p)) {
                            if (q == p) {
                                continue
                            }
                            if (p != null && this.parent.isItemInteractive(p) && p.containsPoint(l)) {
                                if (mflayer.isInstanceOfType(b.ContainerNode, p)) {
                                    var n = p.visitNodes(l, s, q);
                                    if (n === $break) {
                                        return $break
                                    }
                                    if (n) {
                                        return true
                                    }
                                }
                                var r = s(p, q);
                                if (r === $break) {
                                    return $break
                                }
                                if (r) {
                                    return true
                                }
                            }
                        }
                    }
                }
                return false
            },
            onDragOver: function(p) {
                d.containerHit = this;
                if (!this.allowAddChildren) {
                    return false
                }
                var o = this.parent;
                var n = null;
                if (this.selected && o) {
                    var q = o.mouseInputDispatcher;
                    if (q && q.currentController) {
                        n = q.currentController.selection
                    }
                    if (n && !mflayer.isInstanceOfType(b.Selection, n)) {
                        n = null
                    }
                }
                if (!n) {
                    var l = new b.NodeEventArgs({
                        node: p,
                        container: this
                    });
                    o.raiseEvent(b.Events.containerChildAdding, l);
                    if (l.getCancel()) {
                        return l.getHandled() ? $break : false
                    }
                }
                if (mflayer.isInstanceOfType(b.DiagramNode, p) || mflayer.isInstanceOfType(b.Selection, p)) {
                    d.containerHit = this;
                    return true
                }
                return false
            },
            onDragOut: function(l) {
                this.parent.updateContainersZOrder();
                this.parent.invalidate()
            },
            getContentBounds: function(o) {
                var n = null;
                var l = new h();
                k.forEach(this.children, function(p) {
                    n = n ? n.union(p.getRotatedBounds()) : p.getRotatedBounds();
                    if (o) {
                        k.forEach(p.getAllLinks(), function(q) {
                            if (!l.contains(q)) {
                                l.set(q, 1)
                            } else {
                                l.set(q, l.get(q) + 1)
                            }
                        })
                    }
                });
                if (o) {
                    l.forEach(function(q, p) {
                        if (p == 2) {
                            n = n.union(q.getBounds())
                        }
                    })
                }
                return n
            },
            getFoldedBounds: function() {
                var n = a.getMillimeter(this.parent.measureUnit);
                var l = this.bounds.clone();
                l.height = this.captionHeight;
                l.width = 50 * n;
                return l
            },
            resizeToFitChildren: function(o, n) {
                var l = this.getContentBounds(true);
                if (!l) {
                    return
                }
                if (n === undefined) {
                    n = this.margin
                }
                l = l.inflate(n);
                l.y -= this.captionHeight;
                l.height += this.captionHeight;
                if (!o) {
                    l = l.union(this.bounds)
                }
                this.setBoundsWithRules(l, b.DiagramMediator.LinkRules);
                if (this.container) {
                    this.container.onChildModified(this, 0)
                }
            },
            resizeToFitText: function(t, r, u) {
                if (this.text == undefined || this.text == "") {
                    return false
                }
                if (t == undefined) {
                    t = g.KeepRatio
                }
                if (r == undefined) {
                    r = false
                }
                if (u == undefined) {
                    u = this.getFoldIconSize()
                }
                var v = this.bounds.clone();
                var q = v.height = this.getCaptionHeight();
                var w = this.bounds.y;
                if (this.folder) {
                    v.width -= u
                }
                var n = new b.ShapeNode(this.parent);
                n.setBounds(v);
                n.text = this.text.clone();
                if (!n.resizeToFitText(t)) {
                    return false
                }
                var o = this.bounds.width;
                if (t != g.KeepWidth) {
                    var s = this.getContentBounds(true);
                    if (s) {
                        var p = s.x - this.bounds.x - this.margin;
                        s = s.inflate(this.margin);
                        s.width += p;
                        o = Math.min(s.width, this.bounds.width)
                    }
                }
                var v = n.bounds.clone();
                this.captionHeight = v.height;
                if (this.folder) {
                    v.width += u
                }
                if (t == g.KeepWidth) {
                    v.width = this.bounds.width
                } else {
                    v.width = Math.max(o, v.width)
                }
                var z = this.captionHeight - q;
                v.height = this.bounds.height + z;
                v.x = this.bounds.x;
                v.y = this.bounds.y - z;
                var l = v.clone();
                this.setBounds(v, false);
                if (r) {
                    l.y = w;
                    this.setBounds(l, true)
                }
                return true
            },
            onChildModified: function(q, r) {
                if (r == 8) {
                    var o = this.bounds;
                    var p = q.getRotatedBounds();
                    var n = !q.getSelected() || q.parent == null || q.parent.selection.nodes.length == 1;
                    if (n && !o.contains(p) && !o.intersectsWith(p)) {
                        if (this.allowRemoveChildren) {
                            this.remove(q, true)
                        }
                    } else {
                        if (!n && q.getSelected()) {
                            var s = q.parent.selection.bounds;
                            if (this.allowRemoveChildren && !o.contains(s) && !s.intersectsWith(o)) {
                                this.remove(q, true)
                            }
                        }
                    }
                }
                var l = !q.getSelected() || q.parent == null || q == q.parent.selection.nodes[q.parent.selection.nodes.length - 1];
                if (l) {
                    this.resizeToFitChildren()
                }
            },
            getFoldable: function() {
                return this.folder ? true : false
            },
            setFoldable: function(n) {
                var l = this.getFoldable();
                if (l == n) {
                    return
                }
                if (n) {
                    this.folder = new b.Folder(this);
                    this.addManipulator(this.folder)
                } else {
                    this.removeManipulator(this.folder);
                    delete this.folder
                }
                this.invalidate()
            },
            getFolded: function() {
                return this.folded ? true : false
            },
            setFolded: function(l) {
                if (this.getFolded() == l) {
                    return
                }
                if (l) {
                    this.doFold()
                } else {
                    this.doUnfold()
                }
            },
            getFoldIconSize: function() {
                return this.foldIconSize
            },
            setFoldIconSize: function(l) {
                if (this.foldIconSize != l) {
                    this.foldIconSize = l;
                    if (this.folder) {
                        this.folder.updateContent();
                        this.folder.updateLocation()
                    }
                    this.invalidate()
                }
            },
            doFold: function() {
                this.unfoldedSize = this.bounds.getSize();
                this.deselectContainedItems();
                this.folded = true;
                this.setBoundsWithRules(this.getFoldedBounds(), b.DiagramMediator.LinkRules);
                this.updateExternalLinks();
                if (this.folder) {
                    this.folder.updateContent()
                }
            },
            doUnfold: function() {
                this.folded = false;
                var l = new c(this.bounds.x, this.bounds.y, this.unfoldedSize.width, this.unfoldedSize.height);
                this.setBoundsWithRules(l, b.DiagramMediator.LinkRules);
                this.updateAllLinks();
                if (this.folder) {
                    this.folder.updateContent()
                }
            },
            deselectContainedItems: function() {
                k.forEach(this.children, function(n) {
                    n.setSelected(false);
                    var l = this.getDescendantLinks();
                    k.forEach(l, function(o) {
                        o.setSelected(false)
                    }, this);
                    if (n.children) {
                        k.forEach(n.children, function(o) {
                            if (mflayer.isInstanceOfType(d, o)) {
                                o.deselectContainedItems()
                            }
                            o.setSelected(false)
                        }, this)
                    }
                }, this)
            },
            getDescendantNodes: function() {
                var l = [];
                k.forEach(this.children, function(n) {
                    if (mflayer.isInstanceOfType(d, n)) {
                        l = l.concat(n.getDescendantNodes())
                    }
                    l.push(n)
                }, this);
                return l
            },
            getDescendantLinks: function() {
                var s = [];
                var r = this.getDescendantNodes();
                for (var u = 0, p = r.length; u < p; u++) {
                    var o = [];
                    r[u].getAllIncomingLinks(o);
                    for (var q = 0, n = o.length; q < n; q++) {
                        if (k.indexOf(r, o[q].origin) > -1) {
                            s.push(o[q])
                        }
                    }
                    var t = [];
                    r[u].getAllOutgoingLinks(t);
                    for (var q = 0, n = t.length; q < n; q++) {
                        if (k.indexOf(r, t[q].destination) > -1) {
                            s.push(t[q])
                        }
                    }
                }
                return s
            },
            updateAllLinks: function() {
                k.forEach(this.children, function(n) {
                    var l = [];
                    d.getLinksToContainedNodes(l, n);
                    k.forEach(l, function(o) {
                        o.updatePosFromOrgAndDest()
                    });
                    if (n.updateAllLinks) {
                        n.updateAllLinks()
                    }
                }, this)
            },
            updateExternalLinks: function() {
                k.forEach(this.children, function(n) {
                    var l = [];
                    d.getLinksToContainedNodes(l, n);
                    k.forEach(l, function(o) {
                        if (o.getOrigin().container != this || o.getDestination().container != this) {
                            o.updatePosFromOrgAndDest()
                        }
                    }, this);
                    if (n.updateExternalLinks) {
                        n.updateExternalLinks()
                    }
                }, this)
            },
            getAllowAddChildren: function() {
                return this.allowAddChildren
            },
            setAllowAddChildren: function(l) {
                if (this.allowAddChildren !== l) {
                    this.allowAddChildren = l;
                    this.setDiagramDirty()
                }
            },
            getAllowRemoveChildren: function() {
                return this.allowRemoveChildren
            },
            setAllowRemoveChildren: function(l) {
                if (this.allowRemoveChildren !== l) {
                    this.allowRemoveChildren = l;
                    this.setDiagramDirty()
                }
            },
            getUnfoldedSize: function() {
                if (this.unfoldedSize === undefined) {
                    this.unfoldedSize = this.bounds.getSize()
                }
                return this.unfoldedSize
            },
            setEnableStyledText: function(l) {
                if (this.text.enableStyledText != l) {
                    this.text.enableStyledText = l;
                    this.invalidate()
                }
            },
            getEnableStyledText: function() {
                return this.text.enableStyledText
            },
            onRemove: function() {
                mflayer.callBaseMethod(d, this, "onRemove", []);
                if (this.children) {
                    k.forEach(this.children, function(l) {
                        delete l.container
                    })
                }
            },
            raiseChildAdded: function(n) {
                if (!this.parent) {
                    return
                }
                var l = new b.NodeEventArgs({
                    node: n,
                    container: this
                });
                this.parent.raiseEvent(b.Events.containerChildAdded, l);
                return l.getHandled()
            },
            raiseChildRemoved: function(n) {
                if (!this.parent) {
                    return
                }
                var l = new b.NodeEventArgs({
                    node: n,
                    container: this
                });
                this.parent.raiseEvent(b.Events.containerChildRemoved, l);
                return l.getHandled()
            },
            raiseFolded: function() {
                if (!this.parent) {
                    return
                }
                var l = new b.NodeEventArgs({
                    node: this,
                    container: this
                });
                this.parent.raiseEvent(b.Events.containerFolded, l);
                return l.getHandled()
            },
            raiseUnfolded: function() {
                if (!this.parent) {
                    return
                }
                var l = new b.NodeEventArgs({
                    node: this,
                    container: this
                });
                this.parent.raiseEvent(b.Events.containerUnfolded, l);
                return l.getHandled()
            },
            resolveInheritedStyle: function(n, o) {
                var l = o.styles["std:ContainerNode"];
                if (l) {
                    if (n.apply(l)) {
                        return l
                    }
                }
                return mflayer.callBaseMethod(d, this, "resolveInheritedStyle", [n, o])
            },
            getChildLinks: function() {
                var n = [];
                var l = new h();
                this.getLinksInScope(l);
                l.forEach(function(o) {
                    if (l.get(o) == 3) {
                        n.push(o)
                    }
                }, this);
                return n
            },
            toGraph: function(o, n, l) {
                return b.LayoutUtils.toGraph(o, n, l, this.children, this.links ? this.links : this.getChildLinks(), this)
            },
            arrange: function(n) {
                this.links = this.getChildLinks();
                var l = b.LayoutUtils.arrange(n, this);
                delete this.links;
                this.resizeToFitChildren(true, n.margins);
                return l
            },
            arrangeAnimated: function(p, q, o, n) {
                this.links = this.getChildLinks();
                o = o || 0;
                q = q || 500;
                n = n || 0;
                var l = b.LayoutUtils.arrange(p, this, {
                    animationType: o,
                    duration: q,
                    easingType: n
                });
                return l
            },
            arrangeAnimatedComplete: function(l) {
                delete this.links;
                this.resizeToFitChildren(true, l.margins)
            },
            saveState: function() {
                var l = mflayer.callBaseMethod(d, this, "saveState", []);
                l.captionHeight = this.captionHeight;
                l.captionBackBrush = this.captionBackBrush;
                l.allowAddChildren = this.allowAddChildren;
                l.allowRemoveChildren = this.allowRemoveChildren;
                l.margin = this.margin;
                l.foldIconSize = this.foldIconSize;
                l.foldable = this.getFoldable();
                l.folded = this.folded;
                l.unfoldedSize = this.unfoldedSize || this.bounds.getSize();
                l.children = k.clone(this.children);
                return l
            },
            restoreState: function(l) {
                mflayer.callBaseMethod(d, this, "restoreState", [l]);
                this.captionHeight = l.captionHeight;
                this.captionBackBrush = l.captionBackBrush;
                this.allowAddChildren = l.allowAddChildren;
                this.allowRemoveChildren = l.allowRemoveChildren;
                this.margin = l.margin;
                this.unfoldedSize = l.unfoldedSize;
                this.foldIconSize = l.foldIconSize;
                this.setFoldable(l.foldable);
                this.setFolded(l.folded);
                k.forEach(this.children, function(n) {
                    this.remove(n)
                }, this);
                k.forEach(l.children, function(n) {
                    this.add(n)
                }, this)
            },
            init: function() {
                if (!b.ContainerNodeBuilder) {
                    b.ContainerNodeBuilder = new MindFusion.Builder(d.prototype, null, this)
                } else {
                    b.ContainerNodeBuilder.setInstance(this)
                }
                return b.ContainerNodeBuilder
            }
        };
        d.With = function(l) {
            if (!b.ContainerNodeBuilder) {
                b.ContainerNodeBuilder = new MindFusion.Builder(d.prototype, l)
            } else {
                b.ContainerNodeBuilder.setInstance(null)
            }
            return b.ContainerNodeBuilder
        };
        b.ContainerNodeBuilder = null;
        d.getLinksToContainedNodes = function(l, n) {
            n.getAllIncomingLinks(l);
            n.getAllOutgoingLinks(l);
            if (n.getLinksToContainedNodes) {
                return
            }
            if (n.attachedNodes) {
                k.forEach(n.getAttachedNodes(), function(o) {
                    d.getLinksToContainedNodes(l, o)
                })
            }
        };
        d.getFoldedContainer = function(n) {
            var l = n.container;
            if (l) {
                if (l.getFolded()) {
                    return l
                }
                return d.getFoldedContainer(l)
            }
            return null
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.ContainerNode", b.DiagramNode)
    })(MindFusion.Diagramming);
    (function(a) {
        var d = MindFusion.Drawing.GraphicsUnit;
        var c = MindFusion.Drawing.Line;
        var b = MindFusion.Drawing.Rect;
        var e = a.DeleteButton = function(f) {
            mflayer.initializeBase(e, this, [f]);
            this.updateContent();
            this.updateLocation()
        };
        e.prototype = {
            updateLocation: function() {
                var f = this.getRect();
                this.x = f.x;
                this.y = f.y
            },
            onClick: function(h) {
                var g = this.getRotatedRect();
                if (!g.containsPoint(h)) {
                    return
                }
                var f = this.node;
                f.parent.deleteItem(f)
            },
            hitTest: function(f) {
                return this.getRotatedRect().containsPoint(f)
            },
            getRect: function() {
                var j = this.node;
                var k = d.getMillimeter(j.parent.measureUnit);
                var h = j.bounds.clone();
                var f = j.getEffectiveFontSize();
                var g = j.getCaptionHeight ? j.getCaptionHeight() : f + k * 2;
                return new b(f < 5 * k ? h.right() - 2.5 * k - f / 2 : h.right() - f, h.y + g / 2 - f / 2, f, f)
            },
            getRotatedRect: function() {
                var g = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var k = [];
                    k.push(g.topLeft());
                    k.push(g.topRight());
                    k.push(g.bottomRight());
                    k.push(g.bottomLeft());
                    a.Utils.rotatePointsAt(k, a.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var f = Math.min(k[0].x, Math.min(k[1].x, Math.min(k[2].x, k[3].x)));
                    var l = Math.min(k[0].y, Math.min(k[1].y, Math.min(k[2].y, k[3].y)));
                    var j = Math.max(k[0].x, Math.max(k[1].x, Math.max(k[2].x, k[3].x)));
                    var h = Math.max(k[0].y, Math.max(k[1].y, Math.max(k[2].y, k[3].y)));
                    return b.fromLTRB(f, l, j, h)
                }
                return g
            },
            updateContent: function() {
                var j = this.node;
                var h = j.getEffectiveTextColor();
                var f = j.getEffectiveStrokeThickness();
                var n = d.getMillimeter(j.parent.measureUnit);
                var g = this.getRect();
                g.x = g.y = 0;
                var l = new c(g.x + n, g.y + n, g.right() - n, g.bottom() - n);
                l.pen = h;
                l.strokeThickness = f;
                this.content.push(l);
                var k = new c(g.right() - n, g.y + n, g.x + n, g.bottom() - n);
                k.pen = h;
                k.strokeThickness = f;
                this.content.push(k)
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.DeleteButton", a.Manipulator)
    })(MindFusion.Diagramming);
    (function(b) {
        var p = MindFusion.Collections.ArrayList;
        var o = MindFusion.Collections.Dictionary;
        var k = MindFusion.Drawing.Font;
        var a = MindFusion.Drawing.GraphicsUnit;
        var n = MindFusion.Drawing.Point;
        var d = MindFusion.Drawing.Rect;
        var q = MindFusion.Collections.Set;
        var h = MindFusion.Drawing.Vector;
        var f = MindFusion.Drawing.Size;
        var e = MindFusion.Drawing.Text;
        var l = MindFusion.Controls.MouseCursors;
        var c = b.Diagram = function(t) {
            mflayer.initializeBase(c, this, [t]);
            this.mouseInputDispatcher = new b.MouseInputDispatcher(this);
            this.keyboardInputDispatcher = new b.KeyboardInputDispatcher(this);
            this.factory = new b.Factory(this);
            this.eventHandlers = mflayer.eventHandlerList();
            this.dummy = new b.DummyNode(this);
            this.laneGrid = new MindFusion.Diagramming.Lanes.Grid(this);
            this.lastMouseUp = new Date();
            this.doubleClick = false;
            this.leftButtonDownPos = new n(0, 0);
            this.leftButtonDownPosDev = new n(0, 0);
            this.rightButtonDownPos = new n(0, 0);
            this.rightButtonDownPosDev = new n(0, 0);
            this.itemTestForDoubleClick = null;
            this.lastCursorPos = new n(0, 0);
            this.lastClick = new Date();
            this.enabled = true;
            this.items = [];
            this.nodes = [];
            this.links = [];
            this.autoSnapDistance = 20;
            this.selection = new b.Selection(this);
            this.activeItem = null;
            this.modificationStart = b.ModificationStart.SelectedOnly;
            this.autoHandlesItem = null;
            this.allowMultipleResize = false;
            this.shapeLibraryLocation = "";
            this.backBrush = "#FFFFFF";
            this.shapeBrush = "#FFFFFF";
            this.shapePen = "#000000";
            this.linkBrush = "#FFFFFF";
            this.linkPen = "#000000";
            this.linkShape = b.LinkShape.Polyline;
            this.linkSegments = 1;
            this.allowSelfLoops = true;
            this.handleBrush = "#FFFFFF";
            this.adjustmentHandlesSize = 2;
            this.showDisabledHandles = true;
            this.setDefaultShape("Rectangle");
            this.setLinkHeadShape("Arrow");
            this.linkBaseShape = null;
            this.linkHeadShapeSize = 5;
            this.linkBaseShapeSize = 5;
            this.linkTextStyle = b.LinkTextStyle.Center;
            this.delKeyAction = b.DelKeyAction.DeleteSelectedItems;
            this.linkRouter = new b.Router(this);
            this.routeLinks = false;
            this.routeMargin = 8;
            this.showAnchors = b.ShowAnchors.Auto;
            this.autoAnchorsNode = null;
            this.showGrid = false;
            this.alignToGrid = true;
            this.gridColor = "#8c8c96";
            this.gridSizeX = 4;
            this.gridSizeY = 4;
            this.gridStyle = b.GridStyle.Points;
            this.gridOffsetX = 0;
            this.gridOffsetY = 0;
            this.gridPointSize = 1.5;
            this.backgroundImageAlign = MindFusion.Drawing.ImageAlign.TopLeft;
            this.setBehavior(b.Behavior.LinkShapes);
            this.expandOnIncoming = false;
            this.preventDefaultTouch = true;
            this.nodeEffects = [];
            this.linkCrossings = b.LinkCrossings.Straight;
            this.crossingRadius = 1.5;
            this.linkHitDistance = 0;
            this.roundedLinksRadius = 2;
            this.autoResize = b.AutoResize.RightAndDown;
            this.scrollZoneSize = 8;
            this.autoScrollAmount = 0;
            this.autoScroll = true;
            this.autoScrDX = 0;
            this.autoScrDY = 0;
            this.freeFormAttractDistance = 8;
            this.autoCloseDistance = Number.MAX_VALUE;
            this.freeFormTargets = ["Rectangle", "Decision", "Ellipse"];
            this.setMagnifierShape("Circle");
            this.magnifierEnabled = false;
            this.magnifierFactor = 150;
            this.magnifierWidth = 30;
            this.magnifierHeight = 30;
            this.magnifierFrameThickness = 1;
            this.magnifierShading = true;
            this.magnifierFrameColor = "black";
            this.magnifierSecondaryFrameColor = "gray";
            this.shadowsStyle = b.ShadowsStyle.OneLevel;
            this.modifierKeyActions = new b.ModifierKeyActions();
            this.setLeftButtonActions(b.MouseButtonActions.Draw);
            this.setMiddleButtonActions(b.MouseButtonActions.None);
            this.setRightButtonActions(b.MouseButtonActions.Cancel);
            this.undoManager = null;
            this.images = [];
            this.svgs = [];
            this.registerXmlTypes();
            this.setDirty(false);
            this.collectHyperlinks = true;
            this.autoArrangeAvoidSegments = true;
            this.autoArrangeAvoidContainers = true
        };
        c.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(c, this, "initialize");
                var t = this.get_element();
                this.scrollDelegate = mflayer.createDelegate(this, this.onScroll);
                mflayer.addHandlers(t.parentNode, {
                    scroll: this.scrollDelegate
                });
                this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                mflayer.addHandlers(window, {
                    resize: this.resizeDelegate
                });
                this.createFocusable();
                this.mouseHandler = new b.MouseEventHandler(this);
                this.mouseHandler.attachHandlers();
                this.touchHandler = new b.TouchEventHandler(this);
                this.touchHandler.attachHandlers();
                this.keyboardHandler = new b.KeyboardEventHandler(this);
                this.keyboardHandler.attachHandlers();
                this.raiseEvent(b.Events.controlLoaded)
            },
            dispose: function() {
                this.clearAll();
                mflayer.clearHandlers(this.get_element());
                if (this.get_element()) {
                    mflayer.removeHandler(this.get_element().parentNode, "scroll", this.scrollDelegate)
                }
                if (this.focusDiv) {
                    document.body.removeChild(this.focusDiv)
                }
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(c, this, "dispose")
            },
            get_focusElement: function() {
                return this.focusDiv || this.get_element()
            },
            createFocusable: function() {
                if (this.focusDiv) {
                    document.body.removeChild(this.focusDiv)
                }
                var t = document.getElementById(this.get_element().id + "_focusable");
                if (t) {
                    document.body.removeChild(t)
                }
                this.focusDiv = document.createElement("DIV");
                this.focusDiv.id = this.get_element().id + "_focusable";
                this.focusDiv.style.width = "0px";
                this.focusDiv.style.height = "0px";
                this.focusDiv.style.position = "absolute";
                this.focusDiv.style.outline = "0";
                this.focusDiv.tabIndex = 9999;
                document.body.appendChild(this.focusDiv)
            },
            updateFocusable: function(t) {
                if (this.focusDiv) {
                    var u = b.Utils.getClientPos(t);
                    this.focusDiv.style.left = u.x + "px";
                    this.focusDiv.style.top = u.y + "px";
                    this.focusDiv.focus();
                    t.preventDefault()
                }
            },
            registerForSubmit: function(v) {
                var u = document.getElementById(v);
                if (u) {
                    var t = u.form;
                    if (t) {
                        t.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: v
                        })))
                    }
                }
            },
            registerXmlTypes: function() {
                c.registerItemClass(b.DiagramLink, "std:DiagramLink", 2);
                c.registerItemClass(b.ShapeNode, "std:ShapeNode", 1);
                c.registerItemClass(b.TableNode, "std:TableNode", 1);
                c.registerItemClass(b.ContainerNode, "std:ContainerNode", 3);
                c.registerItemClass(b.SvgNode, "std:SvgNode", 2);
                c.registerItemClass(b.FreeFormNode, "std:FreeFormNode", 1);
                c.registerItemClass(b.GlassEffect, "std:GlassEffect", 1);
                c.registerItemClass(b.AeroEffect, "std:AeroEffect", 1);
                c.registerItemClass(b.Lanes.Header, "std:Header", 1)
            },
            getFactory: function() {
                return this.factory
            },
            addEventListener: function(t, u) {
                mflayer.addHandler(this, t, u)
            },
            removeEventListener: function(t, u) {
                mflayer.removeHandler(this, t, u)
            },
            raiseEvent: function(t, u) {
                var v = mflayer.getHandler(this, t);
                if (v != null) {
                    v(this, u)
                }
            },
            prepareScriptEvent: function(u, t) {
                if (!t || t == "") {
                    return
                }
                var v = new Function("sender", "args", "return " + t + "(sender, args)");
                this.addEventListener(u, v)
            },
            drawForeground: function() {
                if (this.autoHandlesItem != null) {
                    this.autoHandlesItem.drawHandles(this.context)
                }
                var v = this.selection.items;
                for (var t = 0; t < v.length; t++) {
                    var u = v[t];
                    u.drawHandles(this.context)
                }
            },
            resetVirtualScroll: function() {
                var z = this.get_element();
                if (this.virtualScroll && !this.scroller) {
                    mflayer.clearHandlers(z.parentNode);
                    var B = mflayer.getBounds(z.parentNode);
                    var u = B.width;
                    var A = B.height;
                    if (A != 0) {
                        z.parentNode._mf_originalHeight = A
                    }
                    z.parentNode.style.overflow = "";
                    z.style.position = "absolute";
                    z.style.zIndex = 1;
                    z.width = Math.min(u - 1 - this.getScrollbarSize(1), this.bounds.width * this.scale);
                    z.height = Math.min(A - 1 - this.getScrollbarSize(0), this.bounds.height * this.scale);
                    var t = document.createElement("div");
                    t.style.width = (u - 1) + "px";
                    t.style.height = (A - 1) + "px";
                    t.style.position = "absolute";
                    t.style.overflow = "auto";
                    this.scroller = t;
                    var v = document.createElement("div");
                    v.style.position = "absolute";
                    this.innerScroller = v;
                    t.appendChild(v);
                    z.parentNode.appendChild(t);
                    mflayer.addHandlers(t, {
                        scroll: mflayer.createDelegate(this, this.onScroll)
                    })
                } else {
                    if (!this.virtualScroll && this.scroller) {
                        z.style.zIndex = "";
                        z.style.position = "";
                        mflayer.clearHandlers(this.scroller);
                        z.parentNode.style.overflow = "auto";
                        z.parentNode.removeChild(this.scroller);
                        delete this.scroller;
                        delete this.innerScroller;
                        mflayer.addHandlers(z.parentNode, {
                            scroll: mflayer.createDelegate(this, this.onScroll)
                        })
                    }
                }
                this.updateCanvasSize()
            },
            recalcVirtualScroll: function() {
                if (this.scroller) {
                    var u = this.get_element();
                    var z = mflayer.getBounds(u.parentNode);
                    var t = z.width;
                    var v = z.height;
                    if (v == 0) {
                        v = u.parentNode._mf_originalHeight
                    }
                    if (v == 0) {
                        v = this.bounds.height * this.scale
                    }
                    u.width = Math.min(t, this.bounds.width * this.scale);
                    u.height = Math.min(v, this.bounds.height * this.scale);
                    this.scroller.style.width = t + "px";
                    this.scroller.style.height = v + "px";
                    this.updateCanvasSize()
                }
            },
            setEnabled: function(t) {
                this.enabled = t
            },
            getEnabled: function() {
                return this.enabled
            },
            setAllowInplaceEdit: function(t) {
                this.allowInplaceEdit = t
            },
            getAllowInplaceEdit: function() {
                return this.allowInplaceEdit
            },
            setDelKeyAction: function(t) {
                this.delKeyAction = t
            },
            getDelKeyAction: function() {
                return this.delKeyAction
            },
            setBackBrush: function(t) {
                if (this.backBrush != t) {
                    this.backBrush = t;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getBackBrush: function() {
                return this.backBrush
            },
            getEffectiveBackBrush: function() {
                if (this.backBrush) {
                    return this.backBrush
                }
                var u = this.resolveEffectiveStyle(b.Style.prototype.hasBrush);
                if (u) {
                    var t = u.getBackBrush();
                    if (t) {
                        return t
                    }
                }
                return "white"
            },
            resolveEffectiveStyle: function(t) {
                if (this.style && t.apply(this.style)) {
                    return this.style
                }
                var v = this.theme;
                if (v) {
                    var u = v.styles["std:Diagram"];
                    if (u) {
                        return u
                    }
                }
                return null
            },
            getNodeEffects: function() {
                if (!this.nodeEffects) {
                    this.nodeEffects = []
                }
                return this.nodeEffects
            },
            getEffectiveNodeEffects: function() {
                if (this.nodeEffects) {
                    return this.nodeEffects
                }
                var t = this.resolveEffectiveStyle(b.Style.prototype.hasNodeEffects);
                if (t) {
                    var u = t.getNodeEffects();
                    if (u) {
                        return u
                    }
                }
                return []
            },
            setDefaultShape: function(t) {
                if (typeof t == "string") {
                    t = b.Shape.fromId(t)
                }
                if (this.defaultShape !== t) {
                    this.defaultShape = t;
                    this.setDirty(true)
                }
            },
            getDefaultShape: function() {
                return this.defaultShape
            },
            setFreeFormTargets: function(t) {
                this.freeFormTargets = t
            },
            getFreeFormTargets: function() {
                return this.freeFormTargets
            },
            setAutoCloseDistance: function(t) {
                this.autoCloseDistance = t
            },
            getAutoCloseDistance: function() {
                return this.autoCloseDistance
            },
            setFreeFormAttractDistance: function(t) {
                this.freeFormAttractDistance = t
            },
            getFreeFormAttractDistance: function() {
                return this.freeFormAttractDistance
            },
            setShapeBrush: function(t) {
                if (this.shapeBrush !== t) {
                    this.shapeBrush = t;
                    this.setDirty(true)
                }
            },
            getShapeBrush: function() {
                return this.shapeBrush
            },
            setShapePen: function(t) {
                if (this.shapePen !== t) {
                    this.shapePen = t;
                    this.setDirty(true)
                }
            },
            getShapePen: function() {
                return this.shapePen
            },
            setLinkBrush: function(t) {
                if (this.linkBrush !== t) {
                    this.linkBrush = t;
                    this.setDirty(true)
                }
            },
            getLinkBrush: function() {
                return this.linkBrush
            },
            setLinkPen: function(t) {
                if (this.linkPen !== t) {
                    this.linkPen = t;
                    this.setDirty(true)
                }
            },
            getLinkPen: function() {
                return this.linkPen
            },
            setLinkShape: function(t) {
                if (!t) {
                    t = b.LinkShape.Bezier
                }
                if (this.linkShape !== t) {
                    this.linkShape = t;
                    if (this.linkShape == b.LinkShape.Cascading && this.linkSegments == 1) {
                        this.linkSegments = 2
                    }
                    this.setDirty(true)
                }
            },
            getLinkShape: function() {
                return this.linkShape
            },
            setLinkSegments: function(t) {
                if (!t) {
                    t = 1
                }
                if (this.linkSegments == t || t <= 0) {
                    return
                }
                this.linkSegments = t;
                if (this.linkShape == b.LinkShape.Cascading && this.linkSegments == 1) {
                    this.linkSegments = 2
                }
                this.setDirty(true)
            },
            getLinkSegments: function() {
                return this.linkSegments
            },
            setLinkHeadShape: function(t) {
                if (typeof t == "string") {
                    t = b.Shape.fromId(t)
                }
                if (this.linkHeadShape !== t) {
                    this.linkHeadShape = t;
                    this.setDirty(true)
                }
            },
            getLinkHeadShape: function() {
                return this.linkHeadShape
            },
            setLinkBaseShape: function(t) {
                if (typeof t == "string") {
                    t = b.Shape.fromId(t)
                }
                if (this.linkBaseShape !== t) {
                    this.linkBaseShape = t;
                    this.setDirty(true)
                }
            },
            getLinkBaseShape: function() {
                return this.linkBaseShape
            },
            setLinkHeadShapeSize: function(t) {
                if (this.linkHeadShapeSize !== t) {
                    this.linkHeadShapeSize = t;
                    this.setDirty(true)
                }
            },
            getLinkHeadShapeSize: function() {
                return this.linkHeadShapeSize
            },
            setLinkBaseShapeSize: function(t) {
                if (this.linkBaseShapeSize !== t) {
                    this.linkBaseShapeSize = t;
                    this.setDirty(true)
                }
            },
            getLinkBaseShapeSize: function() {
                return this.linkBaseShapeSize
            },
            setAllowSelfLoops: function(t) {
                if (this.allowSelfLoops != t) {
                    this.allowSelfLoops = t;
                    this.setDirty(true)
                }
            },
            getAllowSelfLoops: function() {
                return this.allowSelfLoops
            },
            setBackgroundImageAlign: function(t) {
                if (this.backgroundImageAlign != t) {
                    this.backgroundImageAlign = t;
                    this.setDirty(true);
                    this.invalidate()
                }
            },
            getBackgroundImageAlign: function() {
                return this.backgroundImageAlign
            },
            setBackgroundImageUrl: function(t) {
                if (t) {
                    if (this.backgroundImageUrl != t) {
                        this.backgroundImageUrl = t;
                        this.backgroundImage = new Image();
                        mflayer.addHandlers(this.backgroundImage, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.backgroundImage.src = t;
                        this.setDirty(true)
                    }
                } else {
                    this.backgroundImageUrl = t;
                    this.backgroundImage = null;
                    this.setDirty(true)
                }
            },
            getBackgroundImageUrl: function() {
                return this.backgroundImageUrl
            },
            setBackgroundImageContent: function(u) {
                if (this.backgroundImageContent != u) {
                    this.backgroundImageContent = u;
                    if (u) {
                        this.backgroundImage = new Image();
                        this.backgroundImage.width = 100;
                        this.backgroundImage.height = 100;
                        var t = "data:image/png;base64," + this.backgroundImageContent;
                        mflayer.addHandlers(this.backgroundImage, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.backgroundImage.src = t;
                        this.setDirty(true)
                    }
                }
            },
            getBackgroundImageContent: function() {
                return this.backgroundImageContent
            },
            getBackgroundImage: function() {
                return this.backgroundImage
            },
            getBackgroundImageSize: function() {
                if (this.backgroundImage) {
                    return new MindFusion.Drawing.Size(this.backgroundImage.width, this.backgroundImage.height)
                }
                return new MindFusion.Drawing.Size(0, 0)
            },
            loadImage: function() {
                this.backgroundImage.loaded = true;
                this.invalidate()
            },
            saveImage: function(u) {
                var t = p.indexOf(this.images, u);
                if (t == -1) {
                    p.add(this.images, u)
                }
                return p.indexOf(this.images, u)
            },
            saveSVG: function(u) {
                var t = p.indexOf(this.svgs, u);
                if (t == -1) {
                    p.add(this.svgs, u)
                }
                return p.indexOf(this.svgs, u)
            },
            raiseInitialize: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.initializeNode, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.initializeLink, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseCreated: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodeCreated, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkCreated, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseCreating: function(v, u) {
                var t = u.currentPoint.clone();
                var z = true;
                var A = false;
                var w;
                if (mflayer.isInstanceOfType(b.DiagramNode, v)) {
                    w = new b.NodeEventArgs({
                        node: v,
                        mousePosition: t
                    });
                    this.raiseEvent(b.Events.nodeCreating, w)
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, v)) {
                    w = new b.LinkEventArgs({
                        link: v,
                        mousePosition: t
                    });
                    this.raiseEvent(b.Events.linkCreating, w)
                }
                if (w) {
                    z = !w.getCancel();
                    A = w.shouldCancelDrag()
                }
                if (A) {
                    u.cancelNow();
                    z = false
                }
                return z
            },
            raiseModifying: function(v, u) {
                var t = u.currentPoint.clone();
                var w = u.adjustmentHandle.index;
                var A = true;
                var B = false;
                var z;
                if (mflayer.isInstanceOfType(b.DiagramNode, v)) {
                    z = new b.NodeEventArgs({
                        node: v,
                        mousePosition: t,
                        adjustmentHandle: w
                    });
                    this.raiseEvent(b.Events.nodeModifying, z)
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, v)) {
                    z = new b.LinkEventArgs({
                        link: v,
                        mousePosition: t,
                        adjustmentHandle: w
                    });
                    this.raiseEvent(b.Events.linkModifying, z)
                }
                if (mflayer.isInstanceOfType(b.Selection, v)) {
                    z = new b.SelectionEventArgs({
                        mousePosition: t,
                        adjustmentHandle: w
                    });
                    this.raiseEvent(b.Events.selectionModifying, z)
                }
                if (z) {
                    A = !z.getCancel();
                    B = z.shouldCancelDrag()
                }
                if (B) {
                    u.cancelNow();
                    A = false
                }
                return A
            },
            raiseDeleting: function(t) {
                var v = true;
                var u;
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    u = new b.NodeEventArgs({
                        node: t
                    });
                    this.raiseEvent(b.Events.nodeDeleting, u)
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    u = new b.LinkEventArgs({
                        link: t
                    });
                    this.raiseEvent(b.Events.linkDeleting, u)
                }
                if (u) {
                    v = !u.getCancel()
                }
                return v
            },
            raiseModified: function(t, v, u) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodeModified, new b.NodeEventArgs({
                        node: t,
                        mousePosition: v,
                        adjustmentHandle: u
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkModified, new b.LinkEventArgs({
                        link: t,
                        mousePosition: v,
                        adjustmentHandle: u
                    }))
                }
            },
            raiseTreeExpanded: function(t) {
                this.raiseEvent(b.Events.treeExpanded, new b.NodeEventArgs({
                    node: t
                }))
            },
            raiseTreeCollapsed: function(t) {
                this.raiseEvent(b.Events.treeCollapsed, new b.NodeEventArgs({
                    node: t
                }))
            },
            raiseSelectionMoved: function() {
                var t = p.clone(this.selection.items);
                p.forEach(t, function(u) {
                    this.raiseModified(u, new n(0, 0), -1)
                }, this)
            },
            raiseDeleted: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodeDeleted, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkDeleted, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseClicked: function(v, w, t) {
                if (v) {
                    return v.raiseClicked(w, t)
                } else {
                    var u = new b.DiagramEventArgs({
                        mousePosition: w,
                        mouseButton: t
                    });
                    this.raiseEvent(b.Events.clicked, u);
                    return true
                }
            },
            raiseDoubleClicked: function(u, v, t) {
                return u.raiseDoubleClicked(v, t)
            },
            raiseSelected: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodeSelected, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkSelected, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseDeselected: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodeDeselected, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkDeselected, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseHitTestAdjustmentHandles: function(t, v) {
                var u;
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    u = new b.NodeEventArgs({
                        node: t,
                        mousePosition: v
                    })
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                        u = new b.LinkEventArgs({
                            link: t,
                            mousePosition: v
                        })
                    }
                }
                this.raiseEvent(b.Events.hitTestAdjustmentHandles, u);
                return u.getAdjustmentHandle()
            },
            raiseDrawAdjustmentHandles: function(u, t) {
                var v;
                if (mflayer.isInstanceOfType(b.DiagramNode, u)) {
                    v = new b.NodeEventArgs({
                        node: u,
                        context: t
                    })
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramLink, u)) {
                        v = new b.LinkEventArgs({
                            link: u,
                            context: t
                        })
                    }
                }
                this.raiseEvent(b.Events.drawAdjustmentHandles, v)
            },
            raiseMouseHover: function(u, w) {
                var t = b.AdjustmentHandles.None;
                var v;
                if (mflayer.isInstanceOfType(b.DiagramNode, u)) {
                    v = new b.NodeEventArgs({
                        node: u,
                        mousePosition: w,
                        adjustmentHandle: t
                    });
                    this.raiseEvent(b.Events.nodePointed, v)
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramLink, u)) {
                        v = new b.LinkEventArgs({
                            link: u,
                            mousePosition: w,
                            adjustmentHandle: t
                        });
                        this.raiseEvent(b.Events.linkPointed, v)
                    }
                }
            },
            raiseSerializeTag: function(u) {
                var t = new b.SerializeTagEventArgs(u);
                this.raiseEvent(b.Events.serializeTag, t);
                return t.getHandled()
            },
            raiseDeserializeTag: function(u) {
                var t = new b.SerializeTagEventArgs(u);
                this.raiseEvent(b.Events.deserializeTag, t);
                u.tag = t.getTag();
                return t.getHandled()
            },
            raiseTableColumnResizing: function(z, w, B, u, A) {
                var t = z.getCell(w, 0);
                var v = new b.CellValidationEventArgs({
                    cell: t,
                    mouseButton: u,
                    mousePosition: B,
                    column: w,
                    row: -1
                });
                this.raiseEvent(b.Events.tableColumnResizing, v);
                A.value = v.shouldCancelDrag();
                return !v.getCancel()
            },
            raiseTableColumnResized: function(z, w, A, u) {
                var t = z.getCell(w, 0);
                var v = new b.CellEventArgs({
                    cell: t,
                    mouseButton: u,
                    mousePosition: A,
                    column: w,
                    row: -1
                });
                this.raiseEvent(b.Events.tableColumnResized, v)
            },
            raiseTableRowResizing: function(w, z, B, u, A) {
                var t = w.getCell(0, z);
                var v = new b.CellValidationEventArgs({
                    cell: t,
                    mouseButton: u,
                    mousePosition: B,
                    column: -1,
                    row: z
                });
                this.raiseEvent(b.Events.tableRowResizing, v);
                A.value = v.shouldCancelDrag();
                return !v.getCancel()
            },
            raiseTableRowResized: function(w, z, A, u) {
                var t = w.getCell(0, z);
                var v = new b.CellValidationEventArgs({
                    cell: t,
                    mouseButton: u,
                    mousePosition: A,
                    column: -1,
                    row: z
                });
                this.raiseEvent(b.Events.tableRowResized, v)
            },
            raiseHeaderResizing: function(v, t) {
                var u = new b.HeaderResizeEventArgs(v, t);
                this.raiseEvent(b.Events.headerStartResizing, u);
                return !u.getCancel()
            },
            raiseHeaderResized: function(v, t) {
                var u = new b.HeaderResizeEventArgs(v, t);
                this.raiseEvent(b.Events.headerResized, u)
            },
            raisePasted: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.raiseEvent(b.Events.nodePasted, new b.NodeEventArgs({
                        node: t
                    }))
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    this.raiseEvent(b.Events.linkPasted, new b.LinkEventArgs({
                        link: t
                    }))
                }
            },
            raiseAnimatedLayoutCompleted: function(u) {
                var t = new b.NodeEventArgs({
                    node: null
                });
                if (u && mflayer.isInstanceOfType(b.DiagramNode, u)) {
                    t.node = u
                }
                this.raiseEvent(b.Events.animatedLayoutCompleted, t)
            },
            onScroll: function() {
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(b.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    this.mouseInputDispatcher.currentController.cancel()
                }
                if (this.scroller) {
                    this.invalidate()
                }
            },
            checkAutoScroll: function(v) {
                var u = this.getViewport();
                if (u.width > this.scrollZoneSize * 2) {
                    u = b.Utils.inflate(u, -this.scrollZoneSize, 0)
                }
                if (u.height > this.scrollZoneSize * 2) {
                    u = b.Utils.inflate(u, 0, -this.scrollZoneSize)
                }
                var t = !u.containsPoint(v);
                if (t) {
                    var z = this.autoScrollAmount > 0 ? this.autoScrollAmount : (4 * a.getMillimeter(this.measureUnit));
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (v.x < u.left()) {
                        this.autoScrDX = -z
                    }
                    if (v.y < u.top()) {
                        this.autoScrDY = -z
                    }
                    if (v.x > u.right()) {
                        this.autoScrDX = z
                    }
                    if (v.y > u.bottom()) {
                        this.autoScrDY = z
                    }
                    this.onAutoScroll();
                    if (!this.scrollTimeoutId) {
                        var w = this;
                        this.scrollTimeoutId = setInterval(function() {
                            w.onAutoScroll()
                        }, 100)
                    }
                } else {
                    if (this.scrollTimeoutId) {
                        this.stopAutoScroll();
                        this.invalidate()
                    }
                }
                return t
            },
            stopAutoScroll: function() {
                if (this.scrollTimeoutId) {
                    clearInterval(this.scrollTimeoutId);
                    delete this.scrollTimeoutId
                }
            },
            onAutoScroll: function() {
                var v = this.getViewport();
                if (this.scroller) {
                    v.width -= this.getScrollbarSize(0);
                    v.height -= this.getScrollbarSize(1)
                }
                var w = this.getScrollX(),
                    u = this.getScrollY();
                if (v.width < this.bounds.width) {
                    w += this.autoScrDX
                }
                if (v.height < this.bounds.height) {
                    u += this.autoScrDY
                }
                this.scrollStayInDoc(w, u, v, this.bounds);
                var t = this.mouseInputDispatcher.currentController;
                if (t) {
                    t.move(this.pointerPosition);
                    if (this.autoResize != b.AutoResize.None) {
                        this.resizeToFitItem(this.mouseInputDispatcher.currentController.modifiedItem)
                    }
                }
            },
            setAutoHandles: function(A) {
                var w = this.getItemAt(A, true, true);
                if (w == null && this.autoHandlesItem != null && mflayer.isInstanceOfType(b.DiagramNode, this.autoHandlesItem)) {
                    var v = this.autoHandlesItem;
                    var t = b.Utils.distToRectPoint(A, v.bounds);
                    var u = b.Utils.DistanceSq(A, t);
                    var z = this.adjustmentHandlesSize / 2 + 7 * a.getMillimeter(this.measureUnit);
                    z *= z;
                    if (u <= z) {
                        w = this.autoHandlesItem
                    }
                }
                this.setAutoHandlesItem(w)
            },
            onContextMenu: function(t) {
                t.preventDefault()
            },
            canResizeLaneHeader: function(D) {
                var B = d.empty;
                var A = null;
                var w = false;
                var u = this.getLaneGrid();
                var z = u.getHeaderFromPoint(D, B, new n(0, 0));
                if (z != null) {
                    var C = 2 * a.getMillimeter(this.measureUnit);
                    var t = B.headerBounds.clone();
                    t.y = t.bottom() - C;
                    t.height = C;
                    var v = B.headerBounds.clone();
                    v.x = v.right() - C;
                    v.width = C;
                    var A = null;
                    var w = false;
                    if (t.contains(D)) {
                        A = z;
                        w = false
                    } else {
                        if (v.contains(D)) {
                            A = z;
                            w = true
                        }
                    }
                    if (A != null) {
                        return {
                            header: A,
                            resizingHeaderWidth: w,
                            headerBounds: B.headerBounds
                        }
                    }
                }
                return false
            },
            clearTooltip: function() {
                if (this.tooltipTimeoutId) {
                    clearTimeout(this.tooltipTimeoutId)
                }
                if (this.tooltipDiv) {
                    document.body.removeChild(this.tooltipDiv);
                    this.tooltipDiv = null
                }
            },
            trackMouseMovement: function(t) {
                if (this.modificationStart == b.ModificationStart.AutoHandles) {
                    this.setAutoHandles(t)
                }
                if (this.trackMouseHover()) {
                    this.startHoverTimer(t)
                }
                var z = this.get_element();
                var v = this.handleMouseMove(t);
                if (v == MindFusion.Controls.MouseCursors.DontChange) {
                    v = this.currentBehavior.setMouseCursor(t)
                }
                if (z != null && this.stopCursorChange != true && v != MindFusion.Controls.MouseCursors.DontChange) {
                    z.style.cursor = v
                }
                var u = this.docToClient(t);
                var w = mflayer.getBounds(this._element);
                this.tooltipX = u.x + w.x;
                this.tooltipY = u.y + w.y;
                this.tooltipPoint = t;
                var A = this;
                this.tooltipTimeoutId = setTimeout(function() {
                    return A.onTooltip()
                }, this.getTooltipDelay());
                if (this.magnifierEnabled) {
                    this.magnifyTimeoutId = setTimeout(function() {
                        return A.invalidate()
                    }, 100)
                }
            },
            handleMouseMove: function(A) {
                var z = MindFusion.Controls.MouseCursors.DontChange;
                for (var u = this.items.length - 1; u >= 0; u--) {
                    var v = this.items[u];
                    if (!this.isItemInteractive(v)) {
                        continue
                    }
                    var t = v.hitTestManipulators(A);
                    if (t != null) {
                        if (t.needsMouseMessages(A)) {
                            t.onMouseMove(A)
                        }
                        z = t.setMouseCursor(A)
                    }
                }
                if (this.getShowLaneGrid() && this.getLaneGrid().allowResizeHeaders) {
                    var w = this.canResizeLaneHeader(A);
                    if (w) {
                        if (w.resizingHeaderWidth) {
                            z = l.HorizontalResize
                        } else {
                            z = l.VerticalResize
                        }
                    }
                }
                return z
            },
            buttonMappedTo: function(t, v) {
                var u = b.MouseButtonActions.None;
                if (t == 0 && this.enabled) {
                    u = this.leftButtonActions
                }
                if (t == 1 && this.enabled) {
                    u = this.middleButtonActions
                }
                if (t == 2 && this.enabled) {
                    u = this.rightButtonActions
                }
                return (u & v) != 0
            },
            trackMouseHover: function() {
                return mflayer.getHandler(this, "nodePointed") || mflayer.getHandler(this, "linkPointed")
            },
            startHoverTimer: function(u) {
                if (this.hoverTimeoutId) {
                    clearTimeout(this.hoverTimeoutId);
                    delete this.hoverTimeoutId
                }
                var t = this;
                this.hoverTimeoutId = setTimeout(function() {
                    return t.onHover(u)
                }, 800)
            },
            onHover: function(t) {
                if (this.hoverTimeoutId) {
                    clearTimeout(this.hoverTimeoutId);
                    delete this.hoverTimeoutId
                }
                this.raiseMouseHover(this.getItemAt(t, false), t)
            },
            onClick: function(A, z) {
                var w = this.hitTestManipulators(A);
                if (w != null) {
                    w.onClick(A);
                    return
                }
                var C = this.getItemAt(A, true);
                var E = C;
                if (E && E.getLocked()) {
                    E = this.getItemAt(A, true, true)
                }
                var t = this.modifierKeyActions.getKeys(b.ModifierKeyAction.Select, b.Keyboard.state);
                if (z == 0 || this.buttonMappedTo(z, b.MouseButtonActions.Select)) {
                    if (!(t) || !this.selection.allowMultipleSelection) {
                        if (!this.selection.itemInSelection(E)) {
                            this.selection.clear()
                        }
                    }
                }
                if (E != null) {
                    if (z == 0 || this.buttonMappedTo(z, b.MouseButtonActions.Select)) {
                        if (t && E.getSelected()) {
                            this.selection.removeItem(E)
                        } else {
                            this.selection.addItem(E)
                        }
                    }
                }
                var u = this.context._mf_links;
                if (typeof u != "undefined") {
                    for (var v = 0; v < u.length; v++) {
                        var D = u[v];
                        if (D.rect && D.rect.containsPoint(this.docToClient(A))) {
                            var B = new b.NodeEventArgs({
                                node: D.item,
                                hyperlink: D.link
                            });
                            this.raiseEvent(b.Events.hyperlinkClicked, B);
                            break
                        }
                    }
                }
                this.raiseClicked(C, A, z)
            },
            onTooltip: function() {
                var u = this.getItemAt(this.tooltipPoint, true, false);
                if (u) {
                    var v = u.getTooltip(this.tooltipPoint);
                    if (!v) {
                        return
                    }
                    var t = this.get_element().id + "_tooltip";
                    var w = this.tooltipDiv = document.createElement("div");
                    document.body.appendChild(w);
                    w.setAttribute("id", t);
                    w.innerHTML = v;
                    w.style.left = this.tooltipX + 20 + "px";
                    w.style.top = this.tooltipY + "px";
                    w.style.width = "auto";
                    w.style.position = "absolute";
                    w.style.display = "block";
                    w.style.background = "white";
                    w.style.border = "solid 1px";
                    w.style.zIndex = 2
                }
            },
            onMagnify: function() {
                this.invalidate()
            },
            beginEdit: function(v, u, t) {
                var w = this;
                setTimeout(function() {
                    if (w.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(b.InplaceEditController, w.mouseInputDispatcher.currentController)) {
                        return
                    }
                    var A = v;
                    var z = u || w.clientToDoc(w.lastCursorPos);
                    w.mouseInputDispatcher.currentController = new b.InplaceEditController(A);
                    w.mouseInputDispatcher.currentController.start(z, t)
                }, 1)
            },
            getInplaceEditBounds: function(v) {
                var u = new d();
                var t = b.Utils.getBounds(this.get_element());
                this.inplaceEditBounds = new d(t.x - (this.scroller ? this.scroller.scrollLeft : 0) + this.scale * this.bounds.x + this.scale * v.x, t.y - (this.scroller ? this.scroller.scrollTop : 0) + this.scale * this.bounds.y + this.scale * v.y, this.scale * v.width, this.scale * v.height);
                var w = this.docToClient(v.topLeft());
                u.x = t.x + w.x;
                u.y = t.y + w.y;
                u.width = this.inplaceEditBounds.width;
                u.height = this.inplaceEditBounds.height;
                return u
            },
            setInplaceEditBounds: function(u) {
                var t = this.getInplaceEditBounds(u);
                this.inplaceTextBox.style.left = t.x + "px";
                this.inplaceTextBox.style.top = t.y + "px";
                this.inplaceTextBox.style.width = t.width + "px";
                this.inplaceTextBox.style.height = t.height + "px"
            },
            focusInput: function() {
                if (this.inplaceTextBox) {
                    this.inplaceTextBox.focus()
                }
            },
            endEdit: function(u) {
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(b.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    var t = this.clientToDoc(this.lastCursorPos);
                    if (u) {
                        this.mouseInputDispatcher.currentController.commit(t)
                    } else {
                        this.mouseInputDispatcher.currentController.cancel(t)
                    }
                    this.mouseInputDispatcher.currentController = null
                }
            },
            onResize: function() {
                this.recalcVirtualScroll();
                if (this.mouseInputDispatcher.currentController != null && mflayer.isInstanceOfType(b.InplaceEditController, this.mouseInputDispatcher.currentController)) {
                    var t = this.clientToDoc(this.lastCursorPos);
                    var u = this.mouseInputDispatcher.currentController.inplaceObject.getEditRect(t);
                    this.mouseInputDispatcher.currentController.setInplaceEditBounds(u)
                }
            },
            getItems: function() {
                return this.items
            },
            getNodes: function() {
                return this.nodes
            },
            getLinks: function() {
                return this.links
            },
            clearAll: function() {
                this.setAutoHandlesItem(null);
                this.selection.clear();
                for (var u = 0, t = this.items.length; u < t; u++) {
                    var v = this.items[0];
                    p.remove(this.items, v);
                    this.onItemRemoved(v)
                }
                this.nodes = [];
                this.links = [];
                if (this.undoManager != null) {
                    this.undoManager = new b.UndoManager(this)
                }
                this.invalidate()
            },
            addItem: function(t) {
                if (this.getUndoEnabled()) {
                    this.undoManager.startComposite();
                    this.undoManager.executeCommand(new b.AddItemCommand(this, t));
                    this.undoManager.endComposite()
                } else {
                    this.doAddItem(t)
                }
            },
            doAddItem: function(t) {
                if (p.contains(this.items, t)) {
                    return
                }
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    this.nodes.push(t);
                    t.updateAnchorVisibility4()
                } else {
                    if (!p.contains(this.items, t.origin) && (t.origin == null || !mflayer.isInstanceOfType(b.DummyNode, t.origin))) {
                        return
                    }
                    if (!p.contains(this.items, t.destination) && (t.destination == null || !mflayer.isInstanceOfType(b.DummyNode, t.destination))) {
                        return
                    }
                    this.links.push(t);
                    t.updateNodeCollections()
                }
                if (t.getZIndex() === undefined) {
                    t.setZIndex(this.items.length)
                }
                p.add(this.items, t);
                this.onItemAdded(t);
                if (this.autoResize != b.AutoResize.None) {
                    this.resizeToFitItem(t)
                }
                if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                    if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                        if (t.origin.container != null || t.destination.container != null) {
                            this.invalidateZOrder()
                        }
                    }
                }
                this.raiseEvent(b.Events.itemAdded, new b.ItemEventArgs({
                    item: t
                }));
                this.setDirty(true)
            },
            removeItem: function(t) {
                if (!t) {
                    return
                }
                if (this.getUndoEnabled()) {
                    this.undoManager.startComposite();
                    this.undoManager.executeCommand(new b.RemoveItemCommand(this, t));
                    this.undoManager.endComposite()
                } else {
                    this.doRemoveItem(t, true)
                }
            },
            doRemoveItem: function(t) {
                if (this.autoHandlesItem == t) {
                    this.setAutoHandlesItem(null)
                }
                this.selection.removeItem(t);
                this.removeFromCollection(t);
                this.removeFromZOrder(t);
                if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    this.invalidateZOrder()
                }
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    t.deleteLinks();
                    t.detach();
                    if (t.obstacle) {
                        this.routeLinksAt([t.getBounds()])
                    }
                } else {
                    if (mflayer.isInstanceOfType(b.DiagramLink, t)) {
                        t.resetCrossings();
                        t.destinationConnection.removeLinkFromNode();
                        t.originConnection.removeLinkFromNode()
                    }
                }
                t.onRemove();
                if (this.autoResize != b.AutoResize.None) {
                    this.sizeDocForItems()
                }
                this.raiseEvent(b.Events.itemRemoved, new b.ItemEventArgs({
                    item: t
                }));
                this.setDirty(true)
            },
            removeFromCollection: function(t) {
                if (mflayer.isInstanceOfType(b.DiagramNode, t)) {
                    p.remove(this.nodes, t)
                } else {
                    p.remove(this.links, t)
                }
            },
            removeFromZOrder: function(t) {
                p.remove(this.items, t);
                this.onItemRemoved(t)
            },
            getLinksFromZ: function(v, B) {
                var t = [];
                var A = this.getZOrder();
                if (B > A.length) {
                    B = A.length
                }
                if (v) {
                    for (var u = B - 1; u >= 0; u--) {
                        var w = A[u].item;
                        if (mflayer.isInstanceOfType(b.DiagramLink, w)) {
                            t.push(w)
                        }
                    }
                } else {
                    for (var u = B + 1; u < A.length; u++) {
                        var w = A[u].item;
                        if (mflayer.isInstanceOfType(b.DiagramLink, w)) {
                            t.push(w)
                        }
                    }
                }
                return t
            },
            deleteItem: function(t) {
                if (t != null && this.raiseDeleting(t)) {
                    this.removeItem(t)
                }
            },
            deleteSelection: function() {
                this.startCompositeOperation();
                var w = this.selection.links;
                for (var u = 0, t = w.length; u < t; u++) {
                    if (this.selection.links.indexOf(w[0]) > -1) {
                        this.deleteItem(w[0])
                    }
                }
                var v = this.selection.nodes;
                for (var u = 0, t = v.length; u < t; u++) {
                    if (this.selection.nodes.indexOf(v[0]) > -1) {
                        this.deleteItem(v[0])
                    }
                }
                this.commitCompositeOperation()
            },
            getItemsAt: function(t) {
                return s(this.items, t)
            },
            getNodesAt: function(t) {
                return s(this.nodes, t)
            },
            getLinksAt: function(t) {
                return s(this.links, t)
            },
            getItemAt: function(u, v, t) {
                return g(this.items, u, v, t)
            },
            getNodeAt: function(u, v, t) {
                return g(this.nodes, u, v, t, true)
            },
            getLinkAt: function(u, v, t) {
                return g(this.links, u, v, t)
            },
            getHandleAt: function(t, w) {
                var z = this.selection.items;
                for (var u = 0; u < z.length; u++) {
                    var v = z[u].handleAtPoint(t);
                    if (v != null) {
                        return v
                    }
                }
                if (w) {
                    return null
                }
                if (this.autoHandlesItem != null) {
                    var v = this.autoHandlesItem.handleAtPoint(t);
                    if (v != null) {
                        return v
                    }
                }
            },
            getNearestNode: function(D, t, w, u) {
                var z = Number.MAX_VALUE;
                var C = null;
                for (var A = 0; A < this.nodes.length; A++) {
                    var v = this.nodes[A];
                    if (u && v.notInteractive()) {
                        continue
                    }
                    if (v === w) {
                        continue
                    }
                    if (b.ContainerNode.getFoldedContainer(v) != null) {
                        continue
                    }
                    if (b.Utils.checkIntersect(D, v.bounds, t)) {
                        var B = b.Utils.minDistToRect(D, v.bounds);
                        if (B < z) {
                            C = v;
                            z = B
                        }
                    }
                }
                return C
            },
            getIntersectingItems: function(A, B, D, z) {
                var w = b.Utils.normalizeRect(A);
                if (z) {
                    for (var v = 0, t = this.items.length; v < t; v++) {
                        var C = this.items[v];
                        if (!C.getTopLevel()) {
                            continue
                        }
                        if (!C.notInteractive() && C.intersects(A)) {
                            B.push(C);
                            if (!D) {
                                return
                            }
                            if (mflayer.isInstanceOfType(b.ContainerNode, C)) {
                                C.getIntersectingItems(A, B, D, z)
                            }
                        }
                    }
                } else {
                    for (var v = 0, t = this.items.length; v < t; v++) {
                        var C = this.items[v];
                        if (!C.getTopLevel()) {
                            continue
                        }
                        var u = C.getRotatedBounds();
                        if (!C.notInteractive() && w.contains(u)) {
                            B.push(C);
                            if (!D) {
                                return
                            }
                            if (mflayer.isInstanceOfType(b.ContainerNode, C)) {
                                C.getIntersectingItems(A, B, D, z)
                            }
                        }
                    }
                }
            },
            countIntersectingItems: function(B, C, E, A) {
                var z = 0;
                var w = b.Utils.normalizeRect(B);
                if (A) {
                    for (var v = 0, t = this.items.length; v < t; v++) {
                        var D = this.items[v];
                        if (!D.getTopLevel()) {
                            continue
                        }
                        if (!D.notInteractive() && D.intersects(B)) {
                            z += 1;
                            if (mflayer.isInstanceOfType(b.ContainerNode, D)) {
                                z += D.countIntersectingItems(B, C, E, A)
                            }
                        }
                    }
                } else {
                    for (var v = 0, t = this.items.length; v < t; v++) {
                        var D = this.items[v];
                        if (!D.getTopLevel()) {
                            continue
                        }
                        var u = D.getRotatedBounds();
                        if (!this.items[v].notInteractive() && w.contains(u)) {
                            z += 1;
                            if (mflayer.isInstanceOfType(b.ContainerNode, D)) {
                                z += D.countIntersectingItems(B, C, E, A)
                            }
                        }
                    }
                }
            },
            updateContainersZOrder: function() {
                if (MindFusion.Diagramming.ContainerNode.usingContainerNodes) {
                    for (var u = 0, t = this.items.length; u < t; u++) {
                        this.items[u].setTopLevel(true)
                    }
                    for (var u = 0, t = this.nodes.length; u < t; u++) {
                        if (mflayer.isInstanceOfType(MindFusion.Diagramming.ContainerNode, this.nodes[u])) {
                            this.nodes[u].updateZOrder()
                        }
                    }
                }
            },
            isItemVisible: function(v) {
                if (!v.getVisible()) {
                    return false
                }
                if (!v.topLevel) {
                    if (mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramNode, v)) {
                        if (b.ContainerNode.getFoldedContainer(v) != null) {
                            return false
                        }
                    }
                    if (mflayer.isInstanceOfType(MindFusion.Diagramming.DiagramLink, v)) {
                        var u = b.ContainerNode.getFoldedContainer(v.origin);
                        if (u != null) {
                            var t = b.ContainerNode.getFoldedContainer(v.destination);
                            if (u == t) {
                                return false
                            }
                        }
                    }
                }
                return true
            },
            isItemInteractive: function(t) {
                if (t.notInteractive()) {
                    return false
                }
                return true
            },
            getType: function() {
                return this.constructor.__typeName
            },
            preparePostback: function(u, t) {
                var v = document.getElementById(t.id);
                if (v) {
                    v.value = b.Utils.escapeHtml(this.toJson())
                }
            },
            toJson: function() {
                var A = this.get_element().parentNode;
                var z = mflayer.getBounds(A);
                var v = {
                    version: 1,
                    id: this.get_element().id,
                    width: z.width,
                    height: z.height,
                    diagramBounds: this.bounds,
                    enabled: this.enabled,
                    measureUnit: this.measureUnit,
                    allowInplaceEdit: this.allowInplaceEdit,
                    font: this.font,
                    defaultShape: this.defaultShape ? this.defaultShape.id : "RoundRect",
                    backBrush: this.backBrush,
                    shapePen: this.shapePen,
                    shapeBrush: this.shapeBrush,
                    linkShape: this.linkShape,
                    linkPen: this.linkPen,
                    linkSegments: this.linkSegments,
                    linkBrush: this.linkBrush,
                    linkBaseShape: (this.linkBaseShape) ? this.linkBaseShape.id : null,
                    linkHeadShape: (this.linkHeadShape) ? this.linkHeadShape.id : null,
                    linkBaseShapeSize: this.linkBaseShapeSize,
                    linkHeadShapeSize: this.linkHeadShapeSize,
                    linkHitDistance: this.linkHitDistance,
                    scrollLeft: this.get_element().parentNode.scrollLeft,
                    scrollTop: this.get_element().parentNode.scrollTop,
                    routeLinks: this.routeLinks,
                    dynamicLinks: this.dynamicLinks,
                    roundedLinks: this.roundedLinks,
                    roundedLinksRadius: this.roundedLinksRadius,
                    linkCrossings: this.linkCrossings,
                    crossingRadius: this.crossingRadius,
                    zoomFactor: this.zoomFactor,
                    virtualScroll: this.virtualScroll,
                    showAnchors: this.showAnchors,
                    modificationStart: this.modificationStart,
                    delKeyAction: this.delKeyAction,
                    gridStyle: this.gridStyle,
                    gridColor: this.gridColor,
                    gridSizeX: this.gridSizeX,
                    gridSizeY: this.gridSizeY,
                    gridOffsetX: this.gridOffsetX,
                    gridOffsetY: this.gridOffsetY,
                    gridPointSize: this.gridPointSize,
                    showGrid: this.showGrid,
                    alignToGrid: this.alignToGrid,
                    magnifierEnabled: this.magnifierEnabled,
                    magnifierShape: (this.magnifierShape) ? this.magnifierShape.id : null,
                    magnifierFactor: this.magnifierFactor,
                    magnifierWidth: this.magnifierWidth,
                    magnifierHeight: this.magnifierHeight,
                    magnifierFrameThickness: this.magnifierFrameThickness,
                    magnifierShading: this.magnifierShading,
                    magnifierFrameColor: this.magnifierFrameColor,
                    magnifierSecondaryFrameColor: this.magnifierSecondaryFrameColor,
                    undoEnabled: this.getUndoEnabled(),
                    behavior: this.behavior,
                    expandOnIncoming: this.expandOnIncoming,
                    adjustmentHandlesSize: this.adjustmentHandlesSize,
                    showDisabledHandles: this.showDisabledHandles,
                    autoResize: this.autoResize,
                    autoScroll: this.autoScroll,
                    autoArrangeAvoidSegments: this.autoArrangeAvoidSegments,
                    autoArrangeAvoidContainers: this.autoArrangeAvoidContainers,
                    scrollZoneSize: this.scrollZoneSize,
                    autoScrollAmount: this.autoScrollAmount,
                    allowMultipleResize: this.allowMultipleResize,
                    allowUnconnectedLinks: this.allowUnconnectedLinks,
                    linkTextStyle: this.linkTextStyle,
                    tag: this.getTag() || null,
                    style: this.style ? this.style.toJson() : null,
                    theme: this.theme ? this.theme.toJson() : null,
                    backgroundImageUrl: this.backgroundImageUrl,
                    backgroundImageAlign: this.backgroundImageAlign,
                    shadowOffsetX: this.getShadowOffsetX(),
                    shadowOffsetY: this.getShadowOffsetY(),
                    shadowsStyle: this.getShadowsStyle(),
                    items: this.serializeItems(),
                    laneGrid: this.laneGrid.toJson(),
                    showLaneGrid: this.showLaneGrid,
                    images: this.images,
                    svgs: this.svgs,
                    tooltipDelay: this.tooltipDelay,
                    shapeLibraryLocation: this.shapeLibraryLocation,
                    autoCloseDistance: this.autoCloseDistance,
                    freeFormAttractDistance: this.freeFormAttractDistance,
                    freeFormTargets: this.freeFormTargets,
                    allowSelfLoops: this.allowSelfLoops,
                    minVisibleFontSize: this.minVisibleFontSize
                };
                var w = [];
                for (var u = 0, t = this.nodeEffects.length; u < t; u++) {
                    if (this.nodeEffects[u] != null) {
                        w.push(this.nodeEffects[u].toJson())
                    }
                }
                v.effects = w;
                if (this.backgroundImageContent) {
                    v.backgroundImageIndex = this.saveImage(this.backgroundImageContent)
                }
                return mflayer.toJson(v)
            },
            serializeItems: function() {
                var t = [];
                this.assignInstanceIds();
                for (var w = 0, u = this.nodes.length; w < u; w++) {
                    var v = this.nodes[w].toJson();
                    t.push(v)
                }
                for (var w = 0, u = this.links.length; w < u; w++) {
                    var v = this.links[w].toJson();
                    t.push(v)
                }
                return t
            },
            assignInstanceIds: function() {
                var v = 0;
                for (var u = 0, t = this.nodes.length; u < t; u++) {
                    this.nodes[u].instanceId = v++
                }
                for (var u = 0, t = this.links.length; u < t; u++) {
                    this.links[u].instanceId = v++
                }
            },
            fromJson: function(D) {
                this.clearAll();
                if (D > "") {
                    var u = mflayer.fromJson(D);
                    if (u.shapeLibraryLocation != null && u.shapeLibraryLocation != "") {
                        this.setShapeLibraryLocation(u.shapeLibraryLocation)
                    }
                    this.bounds = new MindFusion.Drawing.Rect(u.diagramBounds.x, u.diagramBounds.y, u.diagramBounds.width, u.diagramBounds.height);
                    this.setEnabled(u.enabled);
                    this.font = u.font ? k.copy(u.font) : null;
                    this.setDefaultShape(u.defaultShape);
                    this.setVirtualScroll(u.virtualScroll);
                    this.setMeasureUnit(u.measureUnit);
                    this.updateScale();
                    this.setAllowInplaceEdit(u.allowInplaceEdit);
                    this.setDelKeyAction(u.delKeyAction);
                    this.setRouteLinks(u.routeLinks);
                    if (u.linkRouter == "GridRouter") {
                        this.linkRouter = new b.GridRouter(this)
                    }
                    this.setZoomFactor(u.zoomFactor);
                    this.setShowAnchors(u.showAnchors);
                    this.setModificationStart(u.modificationStart);
                    this.setGridStyle(u.gridStyle);
                    this.setGridColor(u.gridColor);
                    this.setGridSizeX(u.gridSizeX);
                    this.setGridSizeY(u.gridSizeY);
                    this.setGridOffsetX(u.gridOffsetX || 0);
                    this.setGridOffsetY(u.gridOffsetY || 0);
                    if (u.autoResize !== undefined) {
                        this.setAutoResize(u.autoResize)
                    }
                    if (u.autoScroll !== undefined) {
                        this.setAutoScroll(u.autoScroll)
                    }
                    this.setScrollZoneSize(u.scrollZoneSize || 8);
                    this.setAutoScrollAmount(u.autoScrollAmount || 0);
                    if (u.autoArrangeAvoidSegments !== undefined) {
                        this.setAutoArrangeAvoidSegments(u.autoArrangeAvoidSegments)
                    }
                    if (u.autoArrangeAvoidContainers !== undefined) {
                        this.setAutoArrangeAvoidContainers(u.autoArrangeAvoidContainers)
                    }
                    if (u.gridPointSize !== undefined) {
                        this.setGridPointSize(u.gridPointSize)
                    }
                    this.setShowGrid(u.showGrid);
                    this.setAlignToGrid(u.alignToGrid);
                    this.setBackBrush(u.backBrush);
                    this.setShapePen(u.shapePen);
                    this.setShapeBrush(u.shapeBrush);
                    this.setLinkPen(u.linkPen);
                    this.setLinkBrush(u.linkBrush);
                    this.setLinkShape(u.linkShape);
                    this.setLinkSegments(u.linkSegments);
                    this.setLinkBaseShape(u.linkBaseShape);
                    this.setLinkHeadShape(u.linkHeadShape);
                    this.setLinkBaseShapeSize(u.linkBaseShapeSize);
                    this.setLinkHeadShapeSize(u.linkHeadShapeSize);
                    this.setLinkHitDistance(u.linkHitDistance);
                    if (u.magnifierEnabled !== undefined) {
                        this.setMagnifierEnabled(u.magnifierEnabled)
                    }
                    if (u.magnifierShape !== undefined) {
                        this.setMagnifierShape(u.magnifierShape)
                    }
                    if (u.magnifierFactor !== undefined) {
                        this.setMagnifierFactor(u.magnifierFactor)
                    }
                    if (u.magnifierWidth !== undefined) {
                        this.setMagnifierWidth(u.magnifierWidth)
                    }
                    if (u.magnifierHeight !== undefined) {
                        this.setMagnifierHeight(u.magnifierHeight)
                    }
                    if (u.magnifierFrameThickness !== undefined) {
                        this.setMagnifierFrameThickness(u.magnifierFrameThickness)
                    }
                    if (u.magnifierFrameDashStops !== undefined) {
                        MindFusion.Drawing.Gradient.tm = u.magnifierFrameDashStops
                    }
                    if (u.magnifierShading !== undefined) {
                        this.setMagnifierShading(u.magnifierShading)
                    }
                    if (u.magnifierFrameColor !== undefined) {
                        this.setMagnifierFrameColor(u.magnifierFrameColor)
                    }
                    if (u.magnifierSecondaryFrameColor !== undefined) {
                        this.setMagnifierSecondaryFrameColor(u.magnifierSecondaryFrameColor)
                    }
                    if (u.undoEnabled !== undefined) {
                        this.setUndoEnabled(u.undoEnabled)
                    }
                    if (u.customNodeType !== undefined) {
                        this.setCustomNodeType(u.customNodeType)
                    }
                    if (u.customLinkType !== undefined) {
                        this.setCustomLinkType(u.customLinkType)
                    }
                    if (u.behavior !== undefined) {
                        this.setBehavior(u.behavior)
                    }
                    if (u.expandOnIncoming !== undefined) {
                        this.expandOnIncoming = u.expandOnIncoming
                    }
                    if (u.adjustmentHandlesSize !== undefined) {
                        this.adjustmentHandlesSize = u.adjustmentHandlesSize
                    }
                    if (u.showDisabledHandles !== undefined) {
                        this.showDisabledHandles = u.showDisabledHandles
                    }
                    if (u.dynamicLinks !== undefined) {
                        this.dynamicLinks = u.dynamicLinks
                    }
                    if (u.roundedLinks !== undefined) {
                        this.roundedLinks = u.roundedLinks
                    }
                    if (u.roundedLinksRadius !== undefined) {
                        this.roundedLinksRadius = u.roundedLinksRadius
                    }
                    if (u.linkCrossings !== undefined) {
                        this.linkCrossings = u.linkCrossings
                    }
                    if (u.crossingRadius !== undefined) {
                        this.crossingRadius = u.crossingRadius
                    }
                    if (u.allowMultipleResize !== undefined) {
                        this.allowMultipleResize = u.allowMultipleResize
                    }
                    if (u.allowUnconnectedLinks !== undefined) {
                        this.allowUnconnectedLinks = u.allowUnconnectedLinks
                    }
                    if (u.linkTextStyle !== undefined) {
                        this.linkTextStyle = u.linkTextStyle
                    }
                    if (u.autoCloseDistance !== undefined) {
                        this.autoCloseDistance = u.autoCloseDistance
                    }
                    if (u.freeFormAttractDistance !== undefined) {
                        this.freeFormAttractDistance = u.freeFormAttractDistance
                    }
                    if (u.freeFormTargets !== undefined) {
                        this.freeFormTargets = u.freeFormTargets
                    }
                    if (u.tag !== undefined) {
                        this.tag = u.tag
                    }
                    if (u.style) {
                        this.style = new b.Style(false);
                        this.style.fromJson(u.style)
                    }
                    if (u.theme) {
                        this.theme = new b.Theme();
                        this.theme.fromJson(u.theme)
                    }
                    this.nodeEffects = [];
                    if (u.effects) {
                        for (var v = 0, t = u.effects.length; v < t; v++) {
                            var A = mflayer.parseType(u.effects[v].typeName);
                            if (A) {
                                var E = new A(this);
                                E.fromJson(u.effects[v]);
                                this.nodeEffects.push(E)
                            }
                        }
                    }
                    if (u.images != undefined) {
                        this.images = u.images
                    }
                    if (u.svgs != undefined) {
                        this.svgs = u.svgs
                    }
                    if (u.backgroundImageAlign !== undefined) {
                        this.backgroundImageAlign = u.backgroundImageAlign
                    }
                    if (u.backgroundImageUrl !== undefined) {
                        this.setBackgroundImageUrl(u.backgroundImageUrl)
                    }
                    if (u.backgroundImageIndex != undefined) {
                        this.setBackgroundImageContent(this.images[u.backgroundImageIndex])
                    }
                    if (u.shadowOffsetX !== undefined) {
                        this.shadowOffsetX = u.shadowOffsetX
                    }
                    if (u.shadowOffsetY !== undefined) {
                        this.shadowOffsetY = u.shadowOffsetY
                    }
                    if (u.shadowsStyle !== undefined) {
                        this.shadowsStyle = u.shadowsStyle
                    }
                    if (u.tooltipDelay !== undefined) {
                        this.tooltipDelay = u.tooltipDelay
                    }
                    if (u.allowSelfLoops !== undefined) {
                        this.allowSelfLoops = u.allowSelfLoops
                    }
                    if (u.minVisibleFontSize !== undefined) {
                        this.minVisibleFontSize = u.minVisibleFontSize
                    }
                    this.prepareScriptEvent(b.Events.nodeClicked, u.nodeClickedScript);
                    this.prepareScriptEvent(b.Events.linkClicked, u.linkClickedScript);
                    this.prepareScriptEvent(b.Events.nodeCreated, u.nodeCreatedScript);
                    this.prepareScriptEvent(b.Events.nodeCreating, u.nodeCreatingScript);
                    this.prepareScriptEvent(b.Events.linkCreated, u.linkCreatedScript);
                    this.prepareScriptEvent(b.Events.linkCreating, u.linkCreatingScript);
                    this.prepareScriptEvent(b.Events.nodeModified, u.nodeModifiedScript);
                    this.prepareScriptEvent(b.Events.nodeModifying, u.nodeModifyingScript);
                    this.prepareScriptEvent(b.Events.linkModified, u.linkModifiedScript);
                    this.prepareScriptEvent(b.Events.linkModifying, u.linkModifyingScript);
                    this.prepareScriptEvent(b.Events.nodeDeleted, u.nodeDeletedScript);
                    this.prepareScriptEvent(b.Events.nodeDeleting, u.nodeDeletingScript);
                    this.prepareScriptEvent(b.Events.linkDeleted, u.linkDeletedScript);
                    this.prepareScriptEvent(b.Events.linkDeleting, u.linkDeletingScript);
                    this.prepareScriptEvent(b.Events.nodeTextEdited, u.nodeTextEditedScript);
                    this.prepareScriptEvent(b.Events.linkTextEdited, u.linkTextEditedScript);
                    this.prepareScriptEvent(b.Events.cellTextEdited, u.cellTextEditedScript);
                    this.prepareScriptEvent(b.Events.repaint, u.repaintScript);
                    this.prepareScriptEvent(b.Events.sizeChanged, u.sizeChangedScript);
                    this.prepareScriptEvent(b.Events.selectionModifying, u.selectionModifyingScript);
                    this.prepareScriptEvent(b.Events.initializeNode, u.initializeNodeScript);
                    this.prepareScriptEvent(b.Events.initializeLink, u.initializeLinkScript);
                    this.prepareScriptEvent(b.Events.treeExpanded, u.treeExpandedScript);
                    this.prepareScriptEvent(b.Events.treeCollapsed, u.treeCollapsedScript);
                    this.prepareScriptEvent(b.Events.nodeSelected, u.nodeSelectedScript);
                    this.prepareScriptEvent(b.Events.nodeDeselected, u.nodeDeselectedScript);
                    this.prepareScriptEvent(b.Events.linkSelected, u.linkSelectedScript);
                    this.prepareScriptEvent(b.Events.linkDeselected, u.linkDeselectedScript);
                    this.prepareScriptEvent(b.Events.nodeDoubleClicked, u.nodeDoubleClickedScript);
                    this.prepareScriptEvent(b.Events.linkDoubleClicked, u.linkDoubleClickedScript);
                    this.prepareScriptEvent(b.Events.nodePointed, u.nodePointedScript);
                    this.prepareScriptEvent(b.Events.linkPointed, u.linkPointedScript);
                    this.prepareScriptEvent(b.Events.controlLoaded, u.controlLoadedScript);
                    this.prepareScriptEvent(b.Events.containerFolded, u.containerFoldedScript);
                    this.prepareScriptEvent(b.Events.containerUnfolded, u.containerUnfoldedScript);
                    this.prepareScriptEvent(b.Events.containerChildAdded, u.containerChildAddedScript);
                    this.prepareScriptEvent(b.Events.containerChildRemoved, u.containerChildRemovedScript);
                    this.prepareScriptEvent(b.Events.containerChildAdding, u.containerChildAddingScript);
                    this.prepareScriptEvent(b.Events.containerChildRemoving, u.containerChildRemovingScript);
                    this.prepareScriptEvent(b.Events.drawAdjustmentHandles, u.drawAdjustmentHandlesScript);
                    this.prepareScriptEvent(b.Events.hitTestAdjustmentHandles, u.hitTestAdjustmentHandlesScript);
                    this.prepareScriptEvent(b.Events.clicked, u.clickedScript);
                    this.prepareScriptEvent(b.Events.enterInplaceEditMode, u.enterInplaceEditScript);
                    this.prepareScriptEvent(b.Events.leaveInplaceEditMode, u.leaveInplaceEditScript);
                    this.prepareScriptEvent(b.Events.createEditControl, u.createEditControlScript);
                    this.prepareScriptEvent(b.Events.tableColumnResizing, u.tableColumnResizingScript);
                    this.prepareScriptEvent(b.Events.tableRowResizing, u.tableRowResizingScript);
                    this.prepareScriptEvent(b.Events.tableColumnResized, u.tableColumnResizedScript);
                    this.prepareScriptEvent(b.Events.tableRowResized, u.tableRowResizedScript);
                    this.prepareScriptEvent(b.Events.nodePasted, u.nodePastedScript);
                    this.prepareScriptEvent(b.Events.linkPasted, u.linkPastedScript);
                    this.prepareScriptEvent(b.Events.headerStartResizing, u.headerStartResizingScript);
                    this.prepareScriptEvent(b.Events.headerResized, u.headerResizedScript);
                    this.prepareScriptEvent(b.Events.itemAdded, u.itemAddedScript);
                    this.prepareScriptEvent(b.Events.itemRemoved, u.itemRemovedScript);
                    this.prepareScriptEvent(b.Events.laneGridCellTextEdited, u.laneGridCellTextEditedScript);
                    this.prepareScriptEvent(b.Events.serializeTag, u.serializeTagScript);
                    this.prepareScriptEvent(b.Events.deserializeTag, u.deserializeTagScript);
                    this.prepareScriptEvent(b.Events.animatedLayoutCompleted, u.animatedLayoutCompletedScript);
                    this.prepareScriptEvent(b.Events.hyperlinkClicked, u.hyperlinkClickedScript);
                    if (u.scrollLeft) {
                        this.get_element().parentNode.scrollLeft = u.scrollLeft
                    }
                    if (u.scrollTop) {
                        this.get_element().parentNode.scrollTop = u.scrollTop
                    }
                    if (u.autoClasses) {
                        for (var z in u.autoClasses) {
                            var B = mflayer.fromJson(u.autoClasses[z]);
                            b.CompositeNode.classFromTemplate(z, B)
                        }
                    }
                    var w = [];
                    if (u.items instanceof Object) {
                        for (var v = 0; v < u.items.length; v++) {
                            if (u.items[v]) {
                                if (this.isNodeType(u.items[v])) {
                                    var C = this.loadItem(u.items[v], w);
                                    w[u.items[v].instanceId] = C;
                                    this.addItem(C);
                                    if (u.items[v].selected) {
                                        this.selection.addItem(C)
                                    }
                                }
                            }
                        }
                        for (var v = 0; v < u.items.length; v++) {
                            if (u.items[v]) {
                                if (this.isLinkType(u.items[v])) {
                                    var C = this.loadItem(u.items[v], w);
                                    w[u.items[v].instanceId] = C;
                                    this.addItem(C);
                                    if (u.items[v].selected) {
                                        this.selection.addItem(C)
                                    }
                                }
                            }
                        }
                    }
                    if (u.laneGrid !== undefined) {
                        this.laneGrid.fromJson(u.laneGrid)
                    }
                    if (u.showLaneGrid != undefined) {
                        this.showLaneGrid = u.showLaneGrid
                    }
                }
                for (var v = 0; v < w.length; v++) {
                    w[v].onLoad(w)
                }
                if (this.onLoad) {
                    this.onLoad()
                }
                this.invalidate();
                this.setDirty(false);
                this.raiseEvent(b.Events.controlLoaded)
            },
            isNodeType: function(u) {
                var t = mflayer.parseType(u.__type || u.type);
                if (!t) {
                    return false
                }
                return mflayer.inheritsFrom(t, b.DiagramNode)
            },
            isLinkType: function(u) {
                var t = mflayer.parseType(u.__type || u.type);
                if (!t) {
                    return false
                }
                return t == b.DiagramLink || mflayer.inheritsFrom(t, b.DiagramLink)
            },
            loadItem: function(B, v) {
                var w = mflayer.parseType(B.__type || B.type);
                if (!w) {
                    return null
                }
                if (mflayer.inheritsFrom(w, b.DiagramNode)) {
                    var A = new w(this);
                    A.fromJson(B);
                    return A
                }
                if (w == b.DiagramLink || mflayer.inheritsFrom(w, b.DiagramLink)) {
                    var u = v[B.origin];
                    var t = v[B.destination];
                    var z = new w(this, u, t);
                    z.fromJson(B);
                    return z
                }
                return null
            },
            loadFromXml: function(t, v, w) {
                var u = this;
                var z = new XMLHttpRequest();
                z.onload = function() {
                    u.fromXmlDocument(z.responseXML);
                    if (v) {
                        v(u)
                    }
                };
                z.onerror = function() {
                    console.log("Error while getting XML.");
                    if (w) {
                        w(u)
                    }
                };
                z.open("GET", t);
                z.responseType = "document";
                z.send()
            },
            saveToXml: function(t) {
                var u = new XMLHttpRequest();
                u.open("POST", t, true);
                u.setRequestHeader("Content-Type", "text/xml");
                u.send(this.saveToString(b.SaveToStringFormat.Xml))
            },
            loadFromString: function(t) {
                if (t.charAt(0) == "{") {
                    this.fromJson(t)
                } else {
                    var u = new DOMParser();
                    this.fromXmlDocument(u.parseFromString(t, "application/xml"))
                }
            },
            saveToString: function(u) {
                if (typeof u == "undefined") {
                    u = b.SaveToStringFormat.Json
                }
                if (u == b.SaveToStringFormat.Xml) {
                    var t = new XMLSerializer();
                    return t.serializeToString(this.toXmlDocument())
                } else {
                    return this.toJson()
                }
            },
            fromXmlDocument: function(D) {
                this.clearAll();
                var F = D.documentElement;
                var u = new b.XmlPersistContext(this, D);
                u.fileVersion = parseInt(F.getAttribute("Version"));
                u.readResources(F);
                this.loadProperties("Properties", F, u);
                var G = this.bounds;
                this.loadEffects("Effects", F, u);
                var t = F.getElementsByTagName("Nodes")[0];
                var C = t.firstElementChild;
                while (C != null) {
                    var w = u.loadItemFromXml(C);
                    this.addItem(w);
                    C = C.nextElementSibling
                }
                var H = F.getElementsByTagName("Links")[0];
                var C = H.firstElementChild;
                while (C != null) {
                    var E = u.loadItemFromXml(C);
                    this.addItem(E);
                    C = C.nextElementSibling
                }
                var v = u.selectSingleNode("Selection", F);
                if (v) {
                    var z = v.getElementsByTagName("Item");
                    for (var B = 0; B < z.length; B++) {
                        var C = z[B];
                        var I = u.readItemReference(C);
                        if (I) {
                            this.selection.addItem(I)
                        }
                    }
                    var A = u.selectSingleNode("ActiveItem", v);
                    if (A) {
                        this.activeItem = u.readItemReference(A)
                    }
                }
                this.setStyle(u.readStyle("Style", F));
                this.setTheme(u.readTheme("Theme", F));
                this.loadView("View", F, u);
                this.setBounds(G)
            },
            toXmlDocument: function() {
                this.assignInstanceIds();
                var u = document.implementation.createDocument("", "", null);
                var w = u.createElement("Diagram");
                w.setAttribute("Version", "17");
                u.appendChild(w);
                var A = new b.XmlPersistContext(this, u);
                var t = A.addChildElement("Nodes", w);
                for (var z = 0; z < this.nodes.length; z++) {
                    A.saveItemToXml(this.nodes[z], t, "Node")
                }
                var B = A.addChildElement("Links", w);
                for (var z = 0; z < this.links.length; z++) {
                    A.saveItemToXml(this.links[z], B, "Link")
                }
                this.saveProperties("Properties", w, A);
                this.saveEffects("Effects", w, A);
                var v = A.addChildElement("Selection", w);
                var C = this.selection.items;
                for (var z = 0; z < C.length; z++) {
                    A.writeItemReference(C[z], "Item", v)
                }
                A.writeItemReference(this.activeItem, "ActiveItem", v);
                A.writeStyle(this.style, "Style", w, "std:DiagramStyle");
                A.writeTheme(this.theme, "Theme", w);
                A.writeResources(w);
                this.setDirty(false);
                return u
            },
            loadProperties: function(u, v, z) {
                var w = z.selectSingleNode(u, v);
                if (!w) {
                    throw new Error("Unable to load diagram properties.")
                }
                this.setMeasureUnit(z.readInt("MeasureUnit", w));
                if (z.fileVersion > 13) {
                    this.setLinkHeadShape(z.readShape("LinkHeadShape", w));
                    this.setLinkBaseShape(z.readShape("LinkBaseShape", w))
                } else {
                    this.setLinkHeadShape(z.readArrowheadV13("LinkHeadShape", w));
                    this.setLinkBaseShape(z.readArrowheadV13("LinkBaseShape", w))
                }
                this.setLinkHeadShapeSize(z.readFloat("LinkHeadShapeSize", w));
                this.setLinkBaseShapeSize(z.readFloat("LinkBaseShapeSize", w));
                this.alignToGrid = z.readBool("AlignToGrid", w);
                this.showGrid = z.readBool("ShowGrid", w);
                this.gridStyle = z.readInt("GridStyle", w);
                this.gridColor = z.readColor("GridColor", w);
                this.gridSizeX = z.readFloat("GridSizeX", w);
                this.gridSizeY = z.readFloat("GridSizeY", w);
                this.gridOffsetX = z.readFloat("GridOffsetX", w);
                this.gridOffsetY = z.readFloat("GridOffsetY", w);
                this.shadowsStyle = z.readInt("ShadowsStyle", w);
                this.shadowOffsetX = z.readFloat("ShadowOffsetX", w);
                this.shadowOffsetY = z.readFloat("ShadowOffsetY", w);
                this.backgroundImageAlign = z.readInt("ImageAlign", w);
                this.setBackgroundImageUrl(z.readImage("BackgroundImageUrl", w));
                this.setBackgroundImageContent(z.readImage("BackgroundImage", w));
                this.setLinkShape(z.readInt("LinkStyle", w));
                this.setLinkSegments(z.readInt("LinkSegments", w));
                this.bounds = z.readRectangleF("Bounds", w);
                this.nodesExpandable = z.readBool("NodesExpandable", w);
                this.tablesScrollable = z.readBool("TablesScrollable", w);
                this.toolTip = z.readString("ToolTip", w);
                this.font = z.readFont("Font", w);
                if (!this.font) {
                    var t = z.readString("FontFamily", w);
                    var A = z.readFloat("FontSize", w);
                    if (t != "" && A > 0) {
                        this.font = new k(t, A)
                    }
                }
                this.setDefaultShape(z.readShape("DefaultShape", w));
                this.shapePen = z.readPen("ShapePen", w);
                this.linkPen = z.readPen("LinkPen", w);
                this.setShapeBrush(z.readBrush("ShapeBrush", w));
                this.setLinkBrush(z.readBrush("LinkBrush", w));
                this.setBackBrush(z.readBrush("Brush", w));
                this.allowUnconnectedLinks = z.readBool("AllowUnconnectedLinks", w);
                this.routeLinks = z.readBool("RouteLinks", w);
                this.linkTextStyle = z.readInt("LinkTextStyle", w);
                this.linkText = z.readString("LinkText", w);
                this.shapeText = z.readString("ShapeText", w);
                this.linkCrossings = z.readInt("LinkCrossings", w);
                this.autoSnapDistance = z.readFloat("AutoSnapDistance", w, 20);
                this.tag = z.readTag(this, "Tag", w);
                this.roundedLinks = z.readBool("RoundedLinks", w);
                this.roundedLinksRadius = z.readFloat("RoundedLinksRadius", w);
                this.setShowLaneGrid(z.readBool("EnableLanes", w));
                var B = z.selectSingleNode("Lane", w);
                if (B != null) {
                    this.laneGrid.loadFromXml(B, z)
                }
                this.autoResize = z.readInt("AutoResize", w);
                this.allowSelfLoops = z.readBool("AllowSelfLoops", w, true);
                this.expandOnIncoming = z.readBool("ExpandOnIncoming", w);
                this.showAnchors = z.readInt("ShowAnchors", w, b.ShowAnchors.Auto);
                this.adjustmentHandlesSize = z.readFloat("AdjustmentHandlesSize", w, 2);
                this.showDisabledHandles = z.readBool("ShowDisabledHandles", w, true);
                this.dynamicLinks = z.readBool("DynamicLinks", w);
                this.autoArrangeAvoidSegments = z.readBool("AutoArrangeAvoidSegments", w, true);
                this.autoArrangeAvoidContainers = z.readBool("AutoArrangeAvoidContainers", w, true);
                this.selection.allowMultipleSelection = z.readBool("AllowMultipleSelection", w)
            },
            saveProperties: function(t, u, w) {
                var v = w.addChildElement(t, u);
                w.writeShape(this.linkHeadShape, "LinkHeadShape", v);
                w.writeShape(this.linkBaseShape, "LinkBaseShape", v);
                w.writeFloat(this.linkHeadShapeSize, "LinkHeadShapeSize", v);
                w.writeFloat(this.linkBaseShapeSize, "LinkBaseShapeSize", v);
                w.writeBool(this.alignToGrid, "AlignToGrid", v);
                w.writeBool(this.showGrid, "ShowGrid", v);
                w.writeInt(this.gridStyle, "GridStyle", v);
                w.writeColor(this.gridColor, "GridColor", v);
                w.writeFloat(this.gridSizeX, "GridSizeX", v);
                w.writeFloat(this.gridSizeY, "GridSizeY", v);
                w.writeFloat(this.gridOffsetX, "GridOffsetX", v);
                w.writeFloat(this.gridOffsetY, "GridOffsetY", v);
                w.writeInt(this.shadowsStyle, "ShadowsStyle", v);
                w.writeFloat(this.getShadowOffsetX(), "ShadowOffsetX", v);
                w.writeFloat(this.getShadowOffsetY(), "ShadowOffsetY", v);
                w.writeInt(this.linkShape, "LinkStyle", v);
                w.writeInt(this.linkSegments, "LinkSegments", v);
                w.writeRectangleF(this.bounds, "Bounds", v);
                w.writeBool(this.nodesExpandable, "NodesExpandable", v);
                w.writeBool(this.tablesScrollable, "TablesScrollable", v);
                w.writeString(this.toolTip, "ToolTip", v);
                w.writeFont(this.font, "Font", v);
                w.writeImage(this.backgroundImageContent, "BackgroundImage", v);
                w.writeInt(this.backgroundImageAlign, "ImageAlign", v);
                w.writeString(this.backgroundImageUrl, "BackgroundImageUrl", v);
                w.writeShape(this.defaultShape, "DefaultShape", v);
                w.writePen(this.shapePen, "ShapePen", v);
                w.writePen(this.linkPen, "LinkPen", v);
                w.writeBrush(this.shapeBrush, "ShapeBrush", v);
                w.writeBrush(this.linkBrush, "LinkBrush", v);
                w.writeBrush(this.backBrush, "Brush", v);
                w.writeBool(this.allowUnconnectedLinks, "AllowUnconnectedLinks", v);
                w.writeBool(this.routeLinks, "RouteLinks", v);
                w.writeInt(this.linkTextStyle, "LinkTextStyle", v);
                w.writeInt(this.measureUnit, "MeasureUnit", v);
                w.writeString(this.linkText, "LinkText", v);
                w.writeString(this.shapeText, "ShapeText", v);
                w.writeInt(this.linkCrossings, "LinkCrossings", v);
                w.writeFloat(this.autoSnapDistance, "AutoSnapDistance", v);
                w.writeTag(this, this.tag, "Tag", v);
                w.writeBool(this.roundedLinks, "RoundedLinks", v);
                w.writeFloat(this.roundedLinksRadius, "RoundedLinksRadius", v);
                w.writeBool(this.showLaneGrid, "EnableLanes", v);
                var z = w.addChildElement("Lane", v);
                this.laneGrid.saveToXml(z, w);
                w.writeInt(this.autoResize, "AutoResize", v);
                w.writeBool(this.allowSelfLoops, "AllowSelfLoops", v);
                w.writeBool(this.expandOnIncoming, "ExpandOnIncoming", v);
                w.writeInt(this.showAnchors, "ShowAnchors", v);
                w.writeFloat(this.adjustmentHandlesSize, "AdjustmentHandlesSize", v);
                w.writeBool(this.showDisabledHandles, "ShowDisabledHandles", v);
                w.writeBool(this.dynamicLinks, "DynamicLinks", v);
                w.writeBool(this.autoArrangeAvoidSegments, "AutoArrangeAvoidSegments", v);
                w.writeBool(this.autoArrangeAvoidContainers, "AutoArrangeAvoidContainers", v);
                w.writeBool(this.selection.allowMultipleSelection, "AllowMultipleSelection", v)
            },
            loadEffects: function(t, u, A) {
                this.nodeEffects = [];
                var B = u.getElementsByTagName(t);
                var z = null;
                for (var w = 0; w < B.length; w++) {
                    if (B[w].parentNode != u) {
                        continue
                    }
                    z = B[w];
                    break
                }
                if (!z) {
                    return
                }
                var C = z.getElementsByTagName("Effect");
                for (var w = 0; w < C.length; w++) {
                    var v = C[w];
                    this.nodeEffects.push(A.readEffect(v))
                }
            },
            saveEffects: function(t, v, z) {
                var u = z.addChildElement(t, v);
                for (var w = 0; w < this.nodeEffects.length; w++) {
                    z.writeEffect(this.nodeEffects[w], "Effect", u)
                }
            },
            loadView: function(t, u, w) {
                var v = w.selectSingleNode(t, u);
                if (!v) {
                    return
                }
                this.setBehavior(w.readInt("Behavior", v))
            },
            onItemAdded: function(t) {
                t.parent = this;
                t.addCanvasElements()
            },
            onItemRemoved: function(t) {
                t.removeCanvasElements()
            },
            setDirty: function(t) {
                if (c.suppressSetDirty) {
                    return
                }
                if (t === undefined) {
                    t = true
                }
                this.dirty = t
            },
            getDirty: function() {
                return this.dirty
            },
            clearRuntimeData: function(w) {
                for (var u = 0, t = this.items.length; u < t; u++) {
                    var v = this.items[u];
                    v[w] = undefined
                }
            },
            copyToClipboard: function(t) {
                if (this.selection.items.length == 0) {
                    return
                }
                var u = this.selection.toJson();
                if (t && window.clipboardData) {
                    window.clipboardData.setData("text", u)
                } else {
                    window.mf_clipboard = u
                }
            },
            pasteFromClipboard: function(C, z, F, u) {
                var H;
                if (F && window.clipboardData) {
                    H = window.clipboardData.getData("text")
                } else {
                    H = window.mf_clipboard
                }
                if (H) {
                    var J = C || 0;
                    var I = z || 0;
                    this.startCompositeOperation();
                    this.selection.clear();
                    var A = mflayer.fromJson(H);
                    var B = [];
                    var D = A.items;
                    if (D instanceof Object) {
                        for (var w = 0; w < D.length; w++) {
                            if (this.isNodeType(D[w])) {
                                var G = this.loadItem(D[w], B);
                                B[D[w].instanceId] = G;
                                if (J != 0 || I != 0) {
                                    var E = G.getBounds();
                                    G.setBounds(new d(E.x + J, E.y + I, E.width, E.height))
                                }
                                this.addItem(G);
                                this.selection.addItem(G)
                            }
                        }
                        for (var w = 0; w < D.length; w++) {
                            if (this.isLinkType(D[w])) {
                                if (!u && (D[w].origin == -1 || D[w].destination == -1)) {
                                    continue
                                }
                                var G = this.loadItem(D[w], B);
                                B[D[w].instanceId] = G;
                                if (J != 0 || I != 0) {
                                    for (var v = 0; v < G.points.length; ++v) {
                                        var t = G.points[v];
                                        G.points[v] = new n(t.x + J, t.y + I)
                                    }
                                }
                                this.addItem(G);
                                this.selection.addItem(G);
                                G.updateFromPoints()
                            }
                        }
                    }
                    for (var w = 0; w < this.selection.items.length; w++) {
                        this.selection.items[w].onLoad(B)
                    }
                    this.commitCompositeOperation();
                    for (var w = 0; w < this.selection.items.length; w++) {
                        this.raisePasted(this.selection.items[w])
                    }
                }
            },
            cutToClipboard: function(t) {
                this.copyToClipboard(t);
                this.deleteSelection()
            },
            setFont: function(t) {
                if (this.font !== t) {
                    this.font = t;
                    this.setDirty(true)
                }
            },
            getFont: function() {
                return this.font
            },
            arrange: function(u) {
                this.startTotalChange();
                var t = b.LayoutUtils.arrange(u, this);
                this.commitCompositeOperation();
                return t
            },
            arrangeAnimated: function(w, z, v, u) {
                this.startTotalChange();
                v = v || 0;
                z = z || 500;
                u = u || 0;
                var t = b.LayoutUtils.arrange(w, this, {
                    animationType: v,
                    duration: z,
                    easingType: u
                });
                this.commitCompositeOperation();
                return t
            },
            toGraph: function(v, u, t) {
                return b.LayoutUtils.toGraph(v, u, t, this.nodes, this.links)
            },
            resizeToFitItems: function(u) {
                if (u === undefined) {
                    u = 10
                }
                var t = this.getContentBounds();
                this.setBounds(d.fromLTRB(t.left() - u, t.top() - u, t.right() + u, t.bottom() + u))
            },
            resizeToFitItem: function(B) {
                if (B == null) {
                    this.sizeDocForItems();
                    return
                }
                if ((mflayer.isInstanceOfType(b.Selection, B) && (this.mouseInputDispatcher.currentController != null && this.mouseInputDispatcher.currentController.action == b.Action.Create)) || !mflayer.isInstanceOfType(b.DiagramItem, B)) {
                    return
                }
                var C = false;
                var w = this.bounds.left();
                var t = this.bounds.top();
                var v = this.bounds.right();
                var z = this.bounds.bottom();
                var u = B.getBounds ? B.getBounds().clone() : B.bounds.clone();
                var A = 12 * a.getMillimeter(this.measureUnit);
                if (this.autoResize == b.AutoResize.AllDirections) {
                    if (u.left() < w + A) {
                        w = u.left() - A;
                        C = true
                    }
                    if (u.top() < t + A) {
                        t = u.top() - A;
                        C = true
                    }
                }
                if (u.right() > v - A) {
                    v = u.right() + A;
                    C = true
                }
                if (u.bottom() > z - A) {
                    z = u.bottom() + A;
                    C = true
                }
                if (C) {
                    this.setBounds(d.fromLTRB(w, t, v, z))
                }
            },
            sizeDocForItems: function() {
                var u = this.bounds.clone();
                var t = this.bounds.clone();
                p.forEach(this.items, function(v) {
                    if (u == d.empty) {
                        u = v.getBounds().clone()
                    } else {
                        u = u.union(v.getBounds())
                    }
                });
                if (u != t) {
                    this.setBounds(d.fromLTRB(this.bounds.left(), this.bounds.top(), u.right(), u.bottom()))
                }
            },
            getContentBounds: function() {
                var t = d.empty;
                p.forEach(this.items, function(u) {
                    if (t == d.empty) {
                        t = u.getBounds().clone()
                    } else {
                        t = t.union(u.getBounds())
                    }
                });
                return t
            },
            scrollTo: function(t, z) {
                var v = this.getScrollX();
                var u = this.getScrollY();
                var w = this.docToClientOverflow(new n(t, z));
                if (this.scroller) {
                    this.invalidate();
                    this.scroller.scrollLeft = w.x;
                    this.scroller.scrollTop = w.y
                } else {
                    this.get_element().parentNode.scrollLeft = w.x;
                    this.get_element().parentNode.scrollTop = w.y
                }
                if (this.pointerPosition) {
                    this.pointerPosition.x += this.getScrollX() - v;
                    this.pointerPosition.y += this.getScrollY() - u
                }
            },
            scrollStayInDoc: function(v, u, t, w) {
                if (!w) {
                    w = this.bounds
                }
                if (v < w.left()) {
                    v = w.left()
                }
                if (v > w.right() - t.width) {
                    v = Math.max(w.right() - t.width, w.left())
                }
                if (u < w.top()) {
                    u = w.top()
                }
                if (u > w.bottom() - t.height) {
                    u = Math.max(w.bottom() - t.height, w.top())
                }
                this.scrollTo(v, u)
            },
            getScrollX: function() {
                if (this.scroller) {
                    var t = new n(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var t = new n(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(t).x
            },
            setScrollX: function(u) {
                var t = this.docToClientOverflow(new n(u, 0));
                if (this.scroller) {
                    this.scroller.scrollLeft = t.x
                } else {
                    this.get_element().parentNode.scrollLeft = t.x
                }
            },
            getScrollY: function() {
                if (this.scroller) {
                    var t = new n(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var t = new n(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(t).y
            },
            setScrollY: function(u) {
                var t = this.docToClientOverflow(new n(0, u));
                if (this.scroller) {
                    this.scroller.scrollTop = t.y
                } else {
                    this.get_element().parentNode.scrollTop = t.y
                }
            },
            getScrollPosition: function() {
                if (this.scroller) {
                    var t = new n(this.scroller.scrollLeft, this.scroller.scrollTop)
                } else {
                    var t = new n(this.get_element().parentNode.scrollLeft, this.get_element().parentNode.scrollTop)
                }
                return this.clientToDocOverflow(t)
            },
            getViewport: function() {
                var v = this.scroller ? this.scroller : this.get_element().parentNode;
                var u = new n(v.scrollLeft, v.scrollTop);
                u = this.clientToDocOverflow(u);
                var t = new n(v.scrollLeft + v.offsetWidth, v.scrollTop + v.offsetHeight);
                t = this.clientToDocOverflow(t);
                return d.fromPoints(u, t)
            },
            setZoomFactorPivot: function(w, v) {
                var u = this.docToClientOverflow(v);
                var t = this.docToClientOverflow(this.getScrollPosition());
                var z = b.Utils.subtract(u, t);
                this.setZoomFactor(w);
                z = this.clientToDocOverflow(z);
                this.scrollTo(v.x - z.x, v.y - z.y)
            },
            zoomToRect: function(v) {
                this.setZoomFactor(100);
                var u = this.getViewport();
                var w = Math.min(u.width / v.width, u.height / v.height);
                this.setZoomFactor(100 * w);
                var t = v.center();
                u = this.getViewport();
                this.scrollTo(Math.max(this.bounds.x, t.x - u.width / 2), Math.max(this.bounds.y, t.y - u.height / 2))
            },
            zoomToFit: function() {
                this.zoomToRect(this.getContentBounds())
            },
            setZoomLevel: function(t) {
                this.setZoomFactor(t)
            },
            setScroll: function(t, u) {
                this.scrollTo(t, u)
            },
            getDynamicLinks: function() {
                return this.dynamicLinks
            },
            setDynamicLinks: function(t) {
                this.dynamicLinks = t
            },
            getRouteLinks: function() {
                return this.routeLinks
            },
            setRouteLinks: function(t) {
                this.routeLinks = t
            },
            routeLinksAt: function(t) {
                var v = [];
                for (var w = 0; w < this.links.length; w++) {
                    var B = this.links[w];
                    if (!B.autoRoute) {
                        continue
                    }
                    for (var A = 0; A < t.length; A++) {
                        var z = t[A];
                        var C = this.routeMargin;
                        var u = b.Utils.inflate(z, C, C);
                        if (u.intersectsWith(B.getBounds())) {
                            v.push(B);
                            break
                        }
                    }
                }
                this.linkRouter.routeLinks(v);
                v.forEach(function(D) {
                    D.finalizeRoute()
                })
            },
            getActiveItem: function() {
                return this.activeItem
            },
            getAutoHandlesItem: function() {
                return this.autoHandlesItem
            },
            setAutoHandlesItem: function(t) {
                if (t != this.autoHandlesItem) {
                    if (this.autoHandlesItem) {
                        this.autoHandlesItem.invalidate()
                    }
                    this.autoHandlesItem = t;
                    if (this.autoHandlesItem) {
                        this.autoHandlesItem.invalidate()
                    }
                }
            },
            getModificationStart: function() {
                return this.modificationStart
            },
            setModificationStart: function(t) {
                if (this.modificationStart != t) {
                    this.modificationStart = t;
                    this.autoHandlesItem = null
                }
            },
            getLinkRouter: function() {
                return this.linkRouter
            },
            setLinkRouter: function(t) {
                this.linkRouter = t
            },
            getRouteMargin: function() {
                return this.routeMargin
            },
            setRouteMargin: function(t) {
                this.routeMargin = t
            },
            routeAllLinks: function() {
                this.invalidate();
                this.startTotalChange();
                this.linkRouter.routeLinks(this.links);
                this.links.forEach(function(t) {
                    t.finalizeRoute()
                });
                this.commitCompositeOperation()
            },
            getSelection: function() {
                return this.selection
            },
            getAllowMultipleResize: function() {
                return this.allowMultipleResize
            },
            setAllowMultipleResize: function(t) {
                this.allowMultipleResize = t
            },
            getAllowUnconnectedLinks: function() {
                return this.allowUnconnectedLinks
            },
            setAllowUnconnectedLinks: function(t) {
                this.allowUnconnectedLinks = t
            },
            getLinkTextStyle: function() {
                return this.linkTextStyle
            },
            setLinkTextStyle: function(t) {
                if (this.linkTextStyle == t) {
                    return
                }
                this.linkTextStyle = t;
                this.setDirty(true)
            },
            getAdjustmentHandlesSize: function() {
                return this.adjustmentHandlesSize
            },
            invalidateIfSelection: function() {
                if (this.activeItem || this.autoHandlesItem) {
                    this.invalidate();
                    return
                }
                var t = this.selection.items;
                if (t.length > 0) {
                    this.invalidate()
                }
            },
            setAdjustmentHandlesSize: function(t) {
                if (this.adjustmentHandlesSize == t) {
                    return
                }
                this.adjustmentHandlesSize = t;
                this.invalidateIfSelection()
            },
            getShowDisabledHandles: function() {
                return this.showDisabledHandles
            },
            setShowDisabledHandles: function(t) {
                if (this.showDisabledHandles == t) {
                    return
                }
                this.showDisabledHandles = t;
                this.invalidateIfSelection();
                this.setDirty(true)
            },
            getShowAnchors: function() {
                return this.showAnchors
            },
            setShowAnchors: function(t) {
                if (this.showAnchors == t) {
                    return
                }
                this.showAnchors = t;
                this.updateAnchorVisibility();
                this.setDirty(true)
            },
            updateAnchorVisibility: function() {
                for (var t = 0; t < this.nodes.length; t++) {
                    this.nodes[t].updateAnchorVisibility()
                }
            },
            getAutoAnchorsNode: function() {
                return this.autoAnchorsNode
            },
            setAutoAnchorsNode: function(t) {
                if (t != this.autoAnchorsNode) {
                    if (this.autoAnchorsNode != null) {
                        this.autoAnchorsNode.updateAnchorVisibility(t)
                    }
                    this.autoAnchorsNode = t;
                    if (this.autoAnchorsNode != null) {
                        this.autoAnchorsNode.updateAnchorVisibility4()
                    }
                }
            },
            getBehavior: function() {
                return this.behavior
            },
            setBehavior: function(u) {
                if (this.behavior == u) {
                    return
                }
                this.behavior = u;
                this.setDirty(true);
                var t = b.Behavior;
                switch (this.behavior) {
                    case t.Modify:
                        this.currentBehavior = new b.ModifyBehavior(this);
                        break;
                    case t.DoNothing:
                        this.currentBehavior = new b.DoNothingBehavior(this);
                        break;
                    case t.LinkShapes:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.ShapeNode(this.diagram)
                        });
                        break;
                    case t.DrawLinks:
                        this.currentBehavior = new b.DrawLinksBehavior(this);
                        break;
                    case t.DrawShapes:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.ShapeNode(this.diagram)
                        });
                        break;
                    case t.LinkTables:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.TableNode(this.diagram)
                        });
                        break;
                    case t.DrawTables:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.TableNode(this.diagram)
                        });
                        break;
                    case t.LinkContainers:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.ContainerNode(this.diagram)
                        });
                        break;
                    case t.DrawContainers:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.ContainerNode(this.diagram)
                        });
                        break;
                    case t.LinkSvgNodes:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.SvgNode(this.diagram)
                        });
                        break;
                    case t.DrawSvgNodes:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.SvgNode(this.diagram)
                        });
                        break;
                    case t.Pan:
                        this.currentBehavior = new b.PanBehavior(this);
                        break;
                    case t.SelectOnly:
                        this.currentBehavior = new b.SelectOnlyBehavior(this);
                        break;
                    case t.Custom:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            var w = mflayer.parseType(this.diagram.customNodeType);
                            if (!w) {
                                return new b.ShapeNode(this.diagram)
                            }
                            return new w(this.diagram)
                        }, function(z, w, v) {
                            var A = mflayer.parseType(this.diagram.customLinkType);
                            if (!A) {
                                return new b.DiagramLink(this.diagram, w, v)
                            }
                            return new A(this.diagram, w, v)
                        });
                        break;
                    case t.LinkFreeForms:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.FreeFormNode(this.diagram)
                        });
                        break;
                    case t.DrawFreeForms:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.FreeFormNode(this.diagram)
                        });
                        break;
                    case t.LinkFreeShapes:
                        this.currentBehavior = new b.LinkNodesBehavior(this, function(v) {
                            return new b.FreeFormNode(this.diagram)
                        });
                        this.currentBehavior.convertToShape = true;
                        break;
                    case t.DrawFreeShapes:
                        this.currentBehavior = new b.DrawNodesBehavior(this, function(v) {
                            return new b.FreeFormNode(this.diagram)
                        });
                        this.currentBehavior.convertToShape = true;
                        break;
                    case t.Magnify:
                        this.currentBehavior = new b.MagnifyBehavior(this);
                        break
                }
            },
            record: function() {
                var u = new Date().getTime();
                var t = this.mouseInputDispatcher;
                var v = new b.RecordingMouseDispatcher(this, u);
                v.eventDispatcher = t;
                this.mouseInputDispatcher = v;
                this.mouseHandler.inputDispatcher = v;
                var t = this.keyboardInputDispatcher;
                var v = new b.RecordingKeyboardDispatcher(this, u);
                v.eventDispatcher = t;
                this.keyboardInputDispatcher = v;
                this.keyboardHandler.inputDispatcher = v
            },
            stopRecording: function() {
                var w = this.mouseInputDispatcher;
                var z = w.data;
                this.mouseInputDispatcher = w.eventDispatcher;
                this.mouseHandler.inputDispatcher = this.mouseInputDispatcher;
                var w = this.keyboardInputDispatcher;
                var t = w.data;
                this.keyboardInputDispatcher = w.eventDispatcher;
                this.keyboardHandler.inputDispatcher = this.keyboardInputDispatcher;
                var v = z.concat(t);

                function u(B, A) {
                    if (B.time < A.time) {
                        return -1
                    }
                    if (B.time > A.time) {
                        return 1
                    }
                    return 0
                }
                v.sort(u);
                return v
            },
            replay: function(u, B, w, A) {
                if (!u) {
                    throw new Error("Recording is null.")
                }
                if (w) {
                    this.fromJson(w);
                    this.invalidate()
                }
                this.enabled = false;
                var v = -1;
                if (B) {
                    var z = this;
                    if (A) {
                        var t = setInterval(function() {
                            ++v;
                            if (v == u.length - 1) {
                                this.enabled = true;
                                clearInterval(t);
                                delete t
                            }
                            return z.onReplay(u[v])
                        }, A)
                    } else {
                        this.onReplay(u[0]);
                        this.onReplayTimeout(this, u, 1)
                    }
                } else {
                    while (v < u.length - 1) {
                        ++v;
                        this.onReplay(u[v])
                    }
                    this.enabled = true
                }
            },
            onReplayTimeout: function(w, v, u) {
                if (u >= v.length) {
                    return
                }
                var t = v[u].time - v[u - 1].time;
                var z = setTimeout(function() {
                    w.onReplay(v[u]);
                    clearTimeout(z);
                    z = null;
                    if (++u < v.length) {
                        w.onReplayTimeout(w, v, u)
                    } else {
                        w.enabled = true
                    }
                }, t)
            },
            onReplay: function(t) {
                if (t.func.toLowerCase().indexOf("key") > -1) {
                    this.keyboardInputDispatcher[t.func](t.targetId, t.key, true, t.value)
                } else {
                    this.mouseInputDispatcher[t.func](t.position, t.button)
                }
                this.updateContainersZOrder()
            },
            getShowGrid: function() {
                return this.showGrid
            },
            setShowGrid: function(t) {
                if (this.showGrid == t) {
                    return
                }
                this.showGrid = t;
                this.invalidate();
                this.setDirty(true)
            },
            getAlignToGrid: function() {
                return this.alignToGrid
            },
            setAlignToGrid: function(t) {
                if (this.alignToGrid !== t) {
                    this.alignToGrid = t;
                    this.setDirty(true)
                }
            },
            getGridColor: function() {
                return this.gridColor
            },
            setGridColor: function(t) {
                if (this.gridColor == t) {
                    return
                }
                this.gridColor = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridSizeX: function() {
                return this.gridSizeX
            },
            setGridSizeX: function(t) {
                if (this.gridSizeX == t) {
                    return
                }
                this.gridSizeX = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridSizeY: function() {
                return this.gridSizeY
            },
            setGridSizeY: function(t) {
                if (this.gridSizeY == t) {
                    return
                }
                this.gridSizeY = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridOffsetX: function() {
                return this.gridOffsetX
            },
            setGridOffsetX: function(t) {
                if (this.gridOffsetX == t) {
                    return
                }
                this.gridOffsetX = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridOffsetY: function() {
                return this.gridOffsetY
            },
            setGridOffsetY: function(t) {
                if (this.gridOffsetY == t) {
                    return
                }
                this.gridOffsetY = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridStyle: function() {
                return this.gridStyle
            },
            setGridStyle: function(t) {
                if (this.gridStyle == t) {
                    return
                }
                this.gridStyle = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            getGridPointSize: function() {
                return this.gridPointSize
            },
            setGridPointSize: function(t) {
                if (this.gridPointSize == t) {
                    return
                }
                this.gridPointSize = t;
                this.setDirty(true);
                if (this.showGrid) {
                    this.invalidate()
                }
            },
            alignMove: function(u, t) {
                return this.alignPointToGrid(t.topLeft())
            },
            alignPointToGrid: function(t) {
                if (this.alignToGrid) {
                    var u = this.gridSizeX / 2;
                    if (b.Utils.isNumber(this.gridOffsetX)) {
                        u = this.gridOffsetX - this.gridSizeX * Math.floor(this.gridOffsetX / this.gridSizeX)
                    }
                    var v = this.gridSizeY / 2;
                    if (b.Utils.isNumber(this.gridOffsetY)) {
                        v = this.gridOffsetY - this.gridSizeY * Math.floor(this.gridOffsetY / this.gridSizeY)
                    }
                    return new n(u + this.gridSizeX * Math.round((t.x - u) / this.gridSizeX), v + this.gridSizeY * Math.round((t.y - v) / this.gridSizeY))
                }
                return t
            },
            alignResize: function(u, t, v) {
                return this.alignPointToGrid(t)
            },
            getShowLaneGrid: function() {
                return this.showLaneGrid
            },
            setShowLaneGrid: function(t) {
                if (this.showLaneGrid == t) {
                    return
                }
                this.showLaneGrid = t;
                this.invalidate();
                this.setDirty(true)
            },
            hitTestManipulators: function(z) {
                for (var v = 0, u = this.items.length; v < u; v++) {
                    var w = this.items[v];
                    var t = w.hitTestManipulators(z);
                    if (t !== null) {
                        return t
                    }
                }
                return null
            },
            setExpandOnIncoming: function(t) {
                if (this.expandOnIncoming !== t) {
                    this.expandOnIncoming = t;
                    this.setDirty(true)
                }
            },
            getExpandOnIncoming: function() {
                return this.expandOnIncoming
            },
            setNodesExpandable: function(t) {
                if (this.nodesExpandable !== t) {
                    this.nodesExpandable = t;
                    this.setDirty(true)
                }
            },
            getNodesExpandable: function() {
                return this.nodesExpandable
            },
            onItemDragging: function(A, t) {
                if (b.ContainerNode.usingContainerNodes) {
                    b.ContainerNode.containerHit = null;
                    var B = this.visitNodes(t, this.onDragOverNode, A);
                    if (b.ContainerNode.containerHit) {
                        if (!B) {
                            b.ContainerNode.containerHit = null
                        }
                        return B
                    }
                    var u = A.container;
                    if (u) {
                        var w = u.bounds;
                        var z = A.getRotatedBounds();
                        if (!w.contains(z) && !w.intersectsWith(z)) {
                            if (!u.allowRemoveChildren) {
                                return false
                            }
                            var v = new b.NodeEventArgs({
                                node: A,
                                container: u
                            });
                            this.raiseEvent(b.Events.containerChildRemoving, v);
                            if (v.getCancel()) {
                                return false
                            }
                        }
                    }
                }
                return true
            },
            onDragOverNode: function(u, t) {
                if (u == t) {
                    return false
                }
                return u.onDragOver(t)
            },
            onItemDropped: function(u, t) {
                if (b.ContainerNode.containerHit) {
                    b.ContainerNode.containerHit.onDropOver(u)
                }
                b.ContainerNode.containerHit = null
            },
            onDropOverNode: function(u, t) {
                if (u == t) {
                    return false
                }
                return u.onDropOver(t)
            },
            visitNodes: function(t, B, z) {
                for (var v = this.items.length - 1; v >= 0; v--) {
                    var w = this.items[v];
                    if (z == w) {
                        continue
                    }
                    if (mflayer.isInstanceOfType(b.DiagramNode, w) && w.getTopLevel() && !w.notInteractive() && w.containsPoint(t)) {
                        if (mflayer.isInstanceOfType(b.ContainerNode, w)) {
                            var u = w.visitNodes(t, B, z);
                            if (u === $break) {
                                return false
                            }
                            if (u) {
                                return true
                            }
                        }
                        var A = B(w, z);
                        if (A === $break) {
                            return false
                        }
                        if (A) {
                            return true
                        }
                    }
                }
                return false
            },
            setStyle: function(t) {
                if (this.style !== t) {
                    this.style = t;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getStyle: function() {
                return this.style
            },
            setTheme: function(t) {
                if (this.theme != t) {
                    this.theme = t;
                    p.forEach(this.items, function(u) {
                        u.invalidate()
                    });
                    this.setDirty(true)
                }
            },
            getTheme: function() {
                return this.theme
            },
            setTag: function(t) {
                if (this.tag != t) {
                    this.tag = t;
                    this.setDirty(true)
                }
            },
            getTag: function() {
                return this.tag
            },
            setCustomNodeType: function(t) {
                this.customNodeType = t
            },
            getCustomNodeType: function() {
                return this.customNodeType
            },
            setCustomLinkType: function(t) {
                this.customLinkType = t
            },
            getCustomLinkType: function() {
                return this.customLinkType
            },
            setVirtualScroll: function(t) {
                if (this.virtualScroll != t) {
                    this.virtualScroll = t;
                    this.resetVirtualScroll()
                }
            },
            getVirtualScroll: function() {
                return this.virtualScroll
            },
            setTooltipDelay: function(t) {
                if (this.tooltipDelay !== t) {
                    this.tooltipDelay = t;
                    this.setDirty()
                }
            },
            getTooltipDelay: function() {
                return this.tooltipDelay != undefined ? this.tooltipDelay : 1000
            },
            getLinkHitDistance: function() {
                return this.linkHitDistance
            },
            setLinkHitDistance: function(t) {
                if (this.linkHitDistance !== t) {
                    this.linkHitDistance = t || 0;
                    this.setDirty(true)
                }
            },
            getLinkCrossings: function() {
                return this.linkCrossings
            },
            setLinkCrossings: function(v) {
                if (this.linkCrossings == v) {
                    return
                }
                this.linkCrossings = v;
                this.clearRuntimeData("_mf_linkCrossings");
                for (var t = 0; t < this.links.length; t++) {
                    var u = this.links[t];
                    u.invalidate()
                }
                this.invalidate();
                this.setDirty(true)
            },
            getCrossingRadius: function() {
                return this.crossingRadius
            },
            setCrossingRadius: function(t) {
                if (this.crossingRadius == t) {
                    return
                }
                this.crossingRadius = t;
                this.clearRuntimeData("_mf_linkCrossings");
                this.invalidate();
                this.setDirty(true)
            },
            getRoundedLinks: function() {
                return this.roundedLinks
            },
            setRoundedLinks: function(t) {
                if (this.roundedLinks !== t) {
                    this.roundedLinks = t;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getRoundedLinksRadius: function() {
                return this.roundedLinksRadius
            },
            setRoundedLinksRadius: function(t) {
                if (this.roundedLinksRadius !== t) {
                    this.roundedLinksRadius = t;
                    this.invalidate();
                    this.setDirty(true)
                }
            },
            getAutoResize: function() {
                return this.autoResize
            },
            setAutoResize: function(t) {
                this.autoResize = t
            },
            getAutoScroll: function() {
                return this.autoScroll
            },
            setAutoScroll: function(t) {
                if (this.autoScroll != t) {
                    this.autoScroll = t;
                    this.stopAutoScroll()
                }
            },
            getScrollZoneSize: function() {
                return this.scrollZoneSize
            },
            setScrollZoneSize: function(t) {
                if (this.scrollZoneSize != t) {
                    this.scrollZoneSize = t
                }
            },
            getAutoScrollAmount: function() {
                return this.autoScrollAmount
            },
            setAutoScrollAmount: function(t) {
                if (this.autoScrollAmount != t) {
                    this.autoScrollAmount = t
                }
            },
            getMagnifierEnabled: function() {
                return this.magnifierEnabled
            },
            setMagnifierEnabled: function(t) {
                if (this.magnifierEnabled != t) {
                    this.magnifierEnabled = t;
                    this.invalidate()
                }
            },
            getMagnifierFactor: function() {
                return this.magnifierFactor
            },
            setMagnifierFactor: function(t) {
                if (this.magnifierFactor != t) {
                    this.magnifierFactor = t
                }
            },
            getMagnifierWidth: function() {
                return this.magnifierWidth
            },
            setMagnifierWidth: function(t) {
                if (this.magnifierWidth != t) {
                    this.magnifierWidth = t
                }
            },
            getMagnifierHeight: function() {
                return this.magnifierHeight
            },
            setMagnifierHeight: function(t) {
                if (this.magnifierHeight != t) {
                    this.magnifierHeight = t
                }
            },
            getMagnifierFrameThickness: function() {
                return this.magnifierFrameThickness
            },
            setMagnifierFrameThickness: function(t) {
                if (this.magnifierFrameThickness != t) {
                    this.magnifierFrameThickness = t
                }
            },
            getMagnifierShading: function() {
                return this.magnifierShading
            },
            setMagnifierShading: function(t) {
                if (this.magnifierEnabled != t) {
                    this.magnifierShading = t
                }
            },
            getMagnifierShape: function() {
                return this.magnifierShape
            },
            setMagnifierShape: function(t) {
                if (typeof t == "string") {
                    t = b.Shape.fromId(t)
                }
                if (this.magnifierShape != t) {
                    this.magnifierShape = t;
                    if (this.magnifierRenderer) {
                        this.magnifierRenderer.setShape(this.magnifierShape)
                    }
                }
            },
            getMagnifierFrameColor: function() {
                return this.magnifierFrameColor
            },
            setMagnifierFrameColor: function(t) {
                if (this.magnifierFrameColor == t) {
                    return
                }
                this.magnifierFrameColor = t;
                if (this.magnifierEnabled) {
                    this.invalidate()
                }
            },
            getMagnifierSecondaryFrameColor: function() {
                return this.magnifierSecondaryFrameColor
            },
            setMagnifierSecondaryFrameColor: function(t) {
                if (this.magnifierSecondaryFrameColor == t) {
                    return
                }
                this.magnifierSecondaryFrameColor = t;
                if (this.magnifierSecondaryFrameColor) {
                    this.invalidate()
                }
            },
            getModifierKeyActions: function() {
                return this.modifierKeyActions
            },
            getLeftButtonActions: function() {
                return this.leftButtonActions
            },
            setLeftButtonActions: function(t) {
                if (this.leftButtonActions != t) {
                    this.leftButtonActions = t
                }
            },
            getMiddleButtonActions: function() {
                return this.middleButtonActions
            },
            setMiddleButtonActions: function(t) {
                if (this.middleButtonActions != t) {
                    this.middleButtonActions = t
                }
            },
            getRightButtonActions: function() {
                return this.rightButtonActions
            },
            setRightButtonActions: function(t) {
                if (this.rightButtonActions != t) {
                    this.rightButtonActions = t;
                    if (t && t != b.MouseButtonActions.None) {
                        this.get_element().oncontextmenu = this.onContextMenu
                    } else {
                        this.get_element().oncontextmenu = null
                    }
                }
            },
            getUndoEnabled: function() {
                return this.undoManager != null
            },
            setUndoEnabled: function(t) {
                if (this.getUndoEnabled() != t) {
                    this.undoManager = t ? new b.UndoManager(this) : null;
                    this.updateCanUndo()
                }
            },
            setShadowOffsetX: function(t) {
                if (this.shadowOffsetX !== t) {
                    this.shadowOffsetX = t;
                    this.invalidate()
                }
            },
            getShadowOffsetX: function() {
                if (this.shadowOffsetX === undefined) {
                    return 4
                }
                return this.shadowOffsetX
            },
            setShadowOffsetY: function(t) {
                if (this.shadowOffsetY !== t) {
                    this.shadowOffsetY = t;
                    this.invalidate()
                }
            },
            getShadowOffsetY: function() {
                if (this.shadowOffsetY === undefined) {
                    return 4
                }
                return this.shadowOffsetY
            },
            setShadowsStyle: function(t) {
                if (this.shadowsStyle !== t) {
                    this.shadowsStyle = t;
                    this.invalidate()
                }
            },
            getShadowsStyle: function() {
                if (this.shadowsStyle === undefined) {
                    return b.ShadowsStyle.None
                }
                return this.shadowsStyle
            },
            setShapeLibraryLocation: function(u) {
                if (this.shapeLibraryLocation != u) {
                    this.shapeLibraryLocation = u;
                    if (this.shapeLibraryLocation != null && this.shapeLibraryLocation != "") {
                        try {
                            b.Shape.loadFromLibPending = true;
                            new b.ShapeLibrary().loadFromXml(this.shapeLibraryLocation, mflayer.createDelegate(this, this.onShapeLibraryLoad), mflayer.createDelegate(this, this.onShapeLibraryError))
                        } catch (t) {
                            b.Shape.loadFromLibPending = false;
                            throw t
                        }
                    } else {
                        b.Shape.loadFromLibPending = false
                    }
                }
            },
            getShapeLibraryLocation: function() {
                return this.shapeLibraryLocation
            },
            onShapeLibraryLoad: function() {
                b.Shape.loadFromLibPending = false;
                this.invalidateDefaultShapes();
                this.invalidate()
            },
            onShapeLibraryLoaded: function(t) {
                b.Shape.loadFromLibPending = false;
                p.forEach(this.items, function(u) {
                    if (u.onShapeLoaded) {
                        u.onShapeLoaded()
                    }
                })
            },
            onShapeLibraryError: function() {
                b.Shape.loadFromLibPending = false;
                this.invalidateDefaultShapes();
                this.invalidate()
            },
            invalidateDefaultShapes: function() {
                if (this.magnifierShape && this.magnifierShape.isDummy()) {
                    this.magnifierShape = b.Shape.fromId(this.magnifierShape.id);
                    if (this.magnifierRenderer) {
                        this.magnifierRenderer.setShape(this.magnifierShape)
                    }
                }
                if (this.defaultShape && this.defaultShape.isDummy()) {
                    this.defaultShape = b.Shape.fromId(this.defaultShape.id)
                }
                if (this.linkHeadShape && this.linkHeadShape.isDummy()) {
                    this.linkHeadShape = b.Shape.fromId(this.linkHeadShape.id)
                }
                if (this.linkBaseShape && this.linkBaseShape.isDummy()) {
                    this.linkBaseShape = b.Shape.fromId(this.linkBaseShape.id)
                }
            },
            invalidateLabelLayout: function(t) {
                if (!this.labelsAutoArrange) {
                    return
                }
                this.invalidate(t);
                this.labelLayoutInvalid = true
            },
            updateLabelLayout: function(u) {
                if (!this.labelLayoutInvalid) {
                    return d.empty
                }
                if (!u) {
                    u = this.bounds
                }
                var t = this.doArrangeLinkLabels(u);
                this.labelLayoutInvalid = false;
                return t
            },
            arrangeLinkLabels: function() {
                if (!this.labelsAutoArrange) {
                    return
                }
                var t = this.getContentBounds();
                t = t.union(this.bounds);
                this.labelLayoutInvalid = true;
                this.updateLabelLayout(t);
                this.invalidate()
            },
            doArrangeLinkLabels: function(E) {
                var G = null;
                var D = [];
                var C = [];
                for (var B = 0, w = this.nodes.length; B < w; B++) {
                    var v = this.nodes[B];
                    if (!this.autoArrangeAvoidContainers && mflayer.isInstanceOfType(b.ContainerNode, v)) {
                        continue
                    }
                    if (E.intersectsWith(v.bounds)) {
                        D.push(v.bounds)
                    }
                }
                for (var B = 0, w = this.links.length; B < w; B++) {
                    if (this.links[B].labels != undefined) {
                        for (var A = 0, u = this.links[B].labels.length; A < u; A++) {
                            if (this.links[B].labels[A].autoArrange) {
                                if (E.intersectsWith(this.links[B].labels[A].getLayoutRect())) {
                                    C.push(this.links[B].labels[A])
                                }
                            } else {
                                this.links[B].labels[A].invalidateLayout()
                            }
                        }
                    }
                }
                for (var B = 0, w = C.length; B < w; B++) {
                    var F = C[B];
                    if (F.cachedLayoutRect && F.cachedLayoutRect != d.empty) {
                        if (!G) {
                            G = F.cachedLayoutRect
                        } else {
                            G = G.union(F.cachedLayoutRect)
                        }
                    }
                    var H = this.arrangeLinkLabel(F, D);
                    var t = F.updateRect(H);
                    F.link.invalidate();
                    D.push(t);
                    if (!G) {
                        G = t
                    } else {
                        G = G.union(t)
                    }
                }
                if (G) {
                    var z = a.getMillimeter(this.measureUnit);
                    G = G.adjusted(-z, -z, z, z)
                }
                return G
            },
            arrangeLinkLabel: function(I, X) {
                I.invalidateLayout();
                var v = I.getLayoutRect();
                var E = this.bounds.clone();
                E = E.inflate(-v.width / 2, -v.height / 2);
                var Y = Number.MAX_VALUE;
                var D = 4 * a.getMillimeter(this.measureUnit);
                var G = new n(v.x + v.width / 2, v.y + v.height / 2);
                var C = G.clone();
                var F = I.link;
                var U = F.getPolyLine(30);
                for (var V = 0, Q = U.length - 1; V < Q; V++) {
                    var z = U[V];
                    var w = U[V + 1];
                    var Z = new h(w.x - z.x, w.y - z.y);
                    var t = Math.floor(Z.length() / D);
                    Z = h.multiplyScalar(Z, (D / Z.length()));
                    var M = this.pointsAlongVector(z, Z, w, t);
                    for (var S = 0, O = M.length; S < O; S++) {
                        var P = M[S];
                        if (this.autoArrangeAvoidSegments) {
                            var A = new h(Z.y, -Z.x);
                            var B = new h(-Z.y, Z.x);
                            A = h.multiplyScalar(h.divideScalar(A, A.length()), this.maxDiagonalDistance(v, A.negate()) + 1);
                            B = h.multiplyScalar(h.divideScalar(B, B.length()), this.maxDiagonalDistance(v, B.negate()) + 1);
                            var H = P.clone().addVector(A);
                            var K = P.clone().addVector(B);
                            var L = this.evalPos(I, X, H, H.distance(C) + ((H.y > K.y) ? 1 : 0));
                            var N = this.evalPos(I, X, K, K.distance(C) + ((K.y > H.y) ? 1 : 0));
                            var R = new d(H.x - v.width / 2, H.y - v.height / 2, v.width, v.height);
                            var J = new d(K.x - v.width / 2, K.y - v.height / 2, v.width, v.height);
                            if (F.intersects(R)) {
                                L += 50
                            }
                            if (F.intersects(J)) {
                                N += 50
                            }
                            if (L < Y && E.containsPoint(H)) {
                                G = H;
                                Y = L
                            }
                            if (N < Y && E.containsPoint(K)) {
                                G = K;
                                Y = N
                            }
                        } else {
                            var T = P.clone();
                            var W = this.evalPos(I, X, T, T.distance(C));
                            var u = new d(T.x - v.width / 2, T.y - v.height / 2, v.width, v.height);
                            if (W < Y && E.containsPoint(T)) {
                                G = T;
                                Y = W
                            }
                        }
                    }
                }
                return G
            },
            getAutoArrangeAvoidSegments: function() {
                return this.autoArrangeAvoidSegments
            },
            setAutoArrangeAvoidSegments: function(t) {
                if (this.autoArrangeAvoidSegments != t) {
                    this.autoArrangeAvoidSegments = t;
                    this.invalidateLabelLayout()
                }
            },
            getAutoArrangeAvoidContainers: function() {
                return this.autoArrangeAvoidContainers
            },
            setAutoArrangeAvoidContainers: function(t) {
                if (this.autoArrangeAvoidContainers != t) {
                    this.autoArrangeAvoidContainers = t;
                    this.invalidateLabelLayout()
                }
            },
            drawMagnifier: function(z) {
                if (z || mflayer.isInstanceOfType(b.MagnifyBehavior, this.currentBehavior) || this.magnifierEnabled) {
                    var u = z;
                    if (!u) {
                        u = this.pointerPosition
                    }
                    if (u == undefined) {
                        return
                    }
                    var C = this.docToClient(u);
                    var E = Math.round(this.magnifierWidth / (this.magnifierFactor / 100)) * this.scale;
                    var A = Math.round(this.magnifierHeight / (this.magnifierFactor / 100)) * this.scale;
                    var t = new d(Math.round(C.x - E / 2), Math.round(C.y - A / 2), E, A);
                    E = this.magnifierWidth * (1 / (this.zoomFactor / 100));
                    A = this.magnifierHeight * (1 / (this.zoomFactor / 100));
                    var D = new d(Math.round(u.x - E / 2), Math.round(u.y - A / 2), E, A);
                    if (!this.magnifierRenderer) {
                        this.magnifierRenderer = new b.ShapeRenderer(this.magnifierShape)
                    }
                    this.magnifierRenderer.updateData(D, 0);
                    this.magnifierRenderer.outlineBrush = "transparent";
                    this.magnifierRenderer.outlinePen = "transparent";
                    this.magnifierRenderer.drawOutline(this.context);
                    this.context.clip();
                    this.context.drawImage(this.get_element(), Math.max(t.x, 0), Math.max(t.y, 0), Math.max(t.width, 1), Math.max(t.height, 1), Math.max(D.x, 0), Math.max(D.y, 0), Math.max(D.width, 1), Math.max(D.height, 1));
                    if (this.magnifierShading) {
                        var B = {
                            type: "RadialGradientBrush",
                            colorStops: [{
                                position: 0,
                                color: "rgba(0,0,0,0)"
                            }, {
                                position: 0.8,
                                color: "rgba(0,0,0,0.1)"
                            }, {
                                position: 0.9,
                                color: "rgba(0,0,0,0.2)"
                            }]
                        };
                        this.magnifierRenderer.outlineBrush = B;
                        this.magnifierRenderer.drawOutline(this.context)
                    }
                    if (this.magnifierFrameThickness > 0) {
                        var v = this.scale / (this.zoomFactor / 100);
                        this.magnifierRenderer.outlineBrush = "transparent";
                        this.magnifierRenderer.outlinePen = this.magnifierSecondaryFrameColor;
                        this.magnifierRenderer.strokeThickness = (this.magnifierFrameThickness + 1) * v;
                        this.magnifierRenderer.drawOutline(this.context);
                        this.magnifierRenderer.outlinePen = this.magnifierFrameColor;
                        this.magnifierRenderer.strokeThickness = this.magnifierFrameThickness * v;
                        this.magnifierRenderer.drawOutline(this.context)
                    }
                }
            },
            pointsAlongVector: function(A, v, u, z) {
                var t = [];
                for (var w = 0; w <= z; ++w) {
                    A = MindFusion.Drawing.Point.addVector(A, v);
                    t.push(A)
                }
                if (t.length == 0 || !t[t.length - 1].equals(u)) {
                    t.push(u.clone())
                }
                return t
            },
            evalPos: function(B, z, E, D) {
                var A = B.getLayoutRect();
                A.setLocation(E);
                A.offset(-A.width / 2, -A.height / 2);
                var C = 0;
                for (var w = 0, v = z.length; w < v; w++) {
                    if (A.intersectsWith(z[w])) {
                        var t = A.intersect(z[w]);
                        var u = t.width * t.height;
                        C = Math.max(C, u)
                    }
                }
                return C + D
            },
            maxDiagonalDistance: function(A, u) {
                var t = new n(A.x + A.width / 2, A.y + A.height / 2);
                var B = h.fromPoints(t, new n(A.x, A.y));
                var z = h.fromPoints(t, new n(A.x + A.width, A.y));
                var w = h.fromPoints(t, new n(A.x + A.width, A.y + A.height));
                var v = h.fromPoints(t, new n(A.x, A.y + A.height));
                var C = [];
                C.push((B.x * u.x + B.y * u.y) / u.length());
                C.push((z.x * u.x + z.y * u.y) / u.length());
                C.push((w.x * u.x + w.y * u.y) / u.length());
                C.push((v.x * u.x + v.y * u.y) / u.length());
                C.sort(function(E, D) {
                    return E - D
                });
                return C[3]
            },
            updateCanUndo: function() {
                this.canUndo = this.getUndoEnabled() && this.undoManager.canUndo();
                this.canRedo = this.getUndoEnabled() && this.undoManager.canRedo()
            },
            undo: function() {
                if (this.undoManager != null) {
                    this.undoManager.undo();
                    this.invalidate()
                }
            },
            redo: function() {
                if (this.undoManager != null) {
                    this.undoManager.redo();
                    this.invalidate()
                }
            },
            startCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.startComposite()
                }
            },
            commitCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.endComposite(true)
                }
            },
            cancelCompositeOperation: function() {
                if (this.undoManager != null) {
                    this.undoManager.endComposite(false)
                }
            },
            onStartInteraction: function(v) {
                if (this.undoManager != null) {
                    if (Array.isArray(v)) {
                        for (var t = 0; t < v.length; t++) {
                            var u = v[t];
                            var w = new b.ChangeItemCommand(this, u);
                            this.undoManager.executeCommand(w)
                        }
                    } else {
                        if (mflayer.isInstanceOfType(q, v)) {
                            v.forEach(function(z) {
                                var A = new b.ChangeItemCommand(this, z);
                                this.undoManager.executeCommand(A)
                            }, this)
                        } else {
                            if (mflayer.isInstanceOfType(b.DiagramItem, v)) {
                                var w = new b.ChangeItemCommand(this, v);
                                this.undoManager.executeCommand(w)
                            }
                        }
                    }
                }
            },
            executeCommand: function(t) {
                if (this.undoManager != null) {
                    this.undoManager.executeCommand(t)
                }
            },
            startItemChange: function(t) {
                return this.undoManager == null ? null : new b.ChangeItemCommand(this, t)
            },
            endItemChange: function(t) {
                if (this.undoManager != null && t != null) {
                    this.undoManager.executeCommand(t)
                }
            },
            startTotalChange: function() {
                if (this.undoManager != null) {
                    this.undoManager.startComposite();
                    for (var u = 0, t = this.items.length; u < t; u++) {
                        var v = new b.ChangeItemCommand(this, this.items[u]);
                        this.undoManager.executeCommand(v)
                    }
                }
            },
            getLaneGrid: function() {
                return this.laneGrid
            },
            millimeter: function() {
                return a.getMillimeter(this.measureUnit)
            }
        };

        function r(u, t) {
            return u.filter(function(v) {
                return v.containsPoint(t)
            })
        }

        function s(u, t) {
            var v = r(u, t);
            v.sort(j);
            return v
        }

        function g(w, A, t, B, D) {
            var z = s(w, A);
            for (var u = z.length - 1; u >= 0; u--) {
                var C = z[u];
                if (t && !C.getVisible()) {
                    continue
                }
                if (B && C.getLocked()) {
                    continue
                }
                if (C.getTopLevel()) {
                    var v = C.hitTest(A, 0, D, B);
                    if (v != null) {
                        return v
                    }
                }
            }
            return null
        }

        function j(w, v) {
            var u = w.getZIndex();
            if (u === undefined) {
                u = Number.MAX_VALUE
            }
            var t = v.getZIndex();
            if (t === undefined) {
                t = Number.MAX_VALUE
            }
            if (u < t) {
                return -1
            }
            if (u > t) {
                return 1
            }
            return 0
        }
        c.ns = "MindFusion.Diagramming";
        MindFusion.registerClass(c, "MindFusion.Diagramming.Diagram", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Diagram.registerItemClass = function(c, a, b) {
        MindFusion.Diagramming.Diagram.xmlClassMap[a] = c;
        c.xmlInfo = {
            classId: a,
            classVersion: b
        }
    };
    MindFusion.Diagramming.Diagram.xmlClassMap = new MindFusion.Collections.Dictionary();
    MindFusion.Diagramming.Diagram.create = function(a) {
        return mflayer.createControl(MindFusion.Diagramming.Diagram, null, null, null, a)
    };
    MindFusion.Diagramming.Diagram.find = function(b, a) {
        return mflayer.findControl(b, a)
    };
    (function(c) {
        var b = MindFusion.Drawing.GraphicsUnit;
        var e = MindFusion.Drawing.Rect;
        var k = MindFusion.Drawing.Path;
        var o = MindFusion.Drawing.Point;
        var l = MindFusion.Drawing.Size;
        var g = MindFusion.Drawing.DashStyle;
        var p = MindFusion.Collections.ArrayList;
        var q = MindFusion.Diagramming.Alignment;
        var r = c.DiagramLink = function(v, u, t) {
            c.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(r, this, [v]);
            this.shape = c.LinkShape.Polyline;
            this.points = [];
            this.points.push(new o(0, 0));
            this.points.push(new o(20, 20));
            this.angles = [];
            this.baseShapeSize = 5;
            this.headShapeSize = 5;
            this.validateParams(arguments);
            this.headShapeObj = {};
            this.baseShapeObj = {};
            this.setHeadShape(c.Shapes.Triangle());
            this.text = "";
            this.textAlignment = q.Center;
            this.textStyle = c.LinkTextStyle.Center;
            this.textSize = new l(0, 0);
            if (v) {
                if (v.linkShape !== undefined) {
                    this.setShape(v.linkShape)
                }
                if (v.linkSegments !== undefined) {
                    this.setSegmentCount(v.linkSegments)
                }
                this.baseShapeSize = v.linkBaseShapeSize;
                this.headShapeSize = v.linkHeadShapeSize;
                if (v.linkBaseShape) {
                    this.setBaseShape(v.linkBaseShape)
                }
                if (v.linkHeadShape) {
                    this.setHeadShape(v.linkHeadShape)
                }
                if (v.dynamicLinks != undefined) {
                    this.dynamic = v.dynamicLinks
                }
                if (v.linkTextStyle != undefined) {
                    this.textStyle = v.linkTextStyle
                }
            }
            this.baseShapeBounds = new MindFusion.Drawing.Rect(this.points[0].x - this.baseShapeSize / 2, this.points[0].y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize);
            this.headShapeBounds = new MindFusion.Drawing.Rect(this.points[this.points.length - 1].x - this.headShapeSize / 2, this.points[this.points.length - 1].y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize);
            if (v && r.useStyles === false) {
                this.setPen(v.linkPen);
                this.setBaseBrush(v.linkBrush);
                this.setHeadBrush(v.linkBrush)
            }
            this.textRenderer = new MindFusion.Diagramming.LinkTextRenderer(this);
            this.textRenderer.textStyle = this.textStyle;
            this.textRenderer.textAlignment = c.Alignment.Center;
            this.updateText();
            if (v) {
                this.autoRoute = v.routeLinks
            }
            c.Diagram.suppressSetDirty = false
        };
        r.prototype = {
            clone: function() {
                c.Diagram.suppressSetDirty = true;
                var w = mflayer.callBaseMethod(r, this, "clone", []);
                w.points = p.clone(this.points);
                w.shape = this.shape;
                w.autoRoute = this.autoRoute;
                w.dynamic = this.dynamic;
                w.cascadeStartHorizontal = this.cascadeStartHorizontal;
                w.textRenderer = this.textRenderer.clone();
                w.text = this.text;
                w.textStyle = this.textStyle;
                w.baseShapeSize = this.baseShapeSize;
                w.headShapeSize = this.headShapeSize;
                w.setBaseShape(this.baseShape);
                w.setHeadShape(this.headShape);
                w.setBaseBrush(this.baseBrush);
                w.setHeadBrush(this.headBrush);
                w.headStroke = this.getHeadStroke();
                w.headStrokeThickness = this.getHeadStrokeThickness();
                w.headStrokeDashStyle = this.getHeadStrokeDashStyle();
                w.updateFromPoints();
                w.updateText();
                if (this.labels != undefined) {
                    w.labels = [];
                    for (var v = 0, t = this.labels.length; v < t; v++) {
                        var u = this.labels[v].clone();
                        u.link = w;
                        w.labels.push(u)
                    }
                }
                c.Diagram.suppressSetDirty = false;
                return w
            },
            toJson: function() {
                var v = mflayer.callBaseMethod(r, this, "toJson", []);
                v.origin = (this.origin) ? this.origin.instanceId : -1;
                v.destination = (this.destination) ? this.destination.instanceId : -1;
                v.originConnection = this.originConnection.relativePosition;
                v.destinationConnection = this.destinationConnection.relativePosition;
                v.originIndex = this.getOriginIndex();
                v.destinationIndex = this.getDestinationIndex();
                v.controlPoints = this.points;
                v.shape = this.shape;
                v.baseShape = (this.baseShape) ? this.baseShape.id : null;
                v.headShape = (this.headShape) ? this.headShape.id : null;
                v.baseShapeSize = this.baseShapeSize;
                v.headShapeSize = this.headShapeSize;
                v.baseBrush = this.getBaseBrush() || null;
                v.headBrush = this.getHeadBrush() || null;
                v.headStroke = this.getHeadStroke();
                v.headStrokeThickness = this.getHeadStrokeThickness();
                v.headStrokeDashStyle = this.getHeadStrokeDashStyle();
                v.dynamic = this.dynamic;
                v.cascadeStartHorizontal = this.cascadeStartHorizontal;
                v.textStyle = this.textStyle;
                v.autoRoute = this.autoRoute;
                if (this.originConnection.anchorPointDetails) {
                    v.originAnchor = this.originConnection.anchorPointDetails.index
                }
                if (this.destinationConnection.anchorPointDetails) {
                    v.destinationAnchor = this.destinationConnection.anchorPointDetails.index
                }
                if (this.labels != undefined) {
                    var w = [];
                    for (var u = 0, t = this.labels.length; u < t; u++) {
                        w.push(this.labels[u].toJson())
                    }
                    v.labels = w
                }
                return v
            },
            fromJson: function(w) {
                mflayer.callBaseMethod(r, this, "fromJson", [w]);
                if (w.shape !== undefined) {
                    this.setShape(w.shape)
                }
                if (w.textStyle !== undefined) {
                    this.setTextStyle(w.textStyle)
                }
                this.setBaseShape(w.baseShape ? c.Shape.fromId(w.baseShape) : null);
                if (w.baseBrush) {
                    this.setBaseBrush(w.baseBrush)
                }
                if (w.baseShapeSize) {
                    this.setBaseShapeSize(w.baseShapeSize)
                }
                this.setHeadShape(w.headShape ? c.Shape.fromId(w.headShape) : null);
                if (w.headBrush) {
                    this.setHeadBrush(w.headBrush)
                }
                if (w.headShapeSize) {
                    this.setHeadShapeSize(w.headShapeSize)
                }
                if (w.headStroke) {
                    this.setHeadStroke(w.headStroke)
                }
                if (w.headStrokeThickness) {
                    this.setHeadStrokeThickness(w.headStrokeThickness)
                }
                if (w.headStrokeDashStyle != null) {
                    this.setHeadStrokeDashStyle(w.headStrokeDashStyle)
                }
                if (w.originIndex !== undefined) {
                    this.originConnection.setRow(w.originIndex, false)
                }
                if (w.destinationIndex !== undefined) {
                    this.destinationConnection.setRow(w.destinationIndex, false)
                }
                var z = new MindFusion.Drawing.Point(w.originConnection.x, w.originConnection.y);
                var A = new MindFusion.Drawing.Point(w.destinationConnection.x, w.destinationConnection.y);
                if (!z.empty()) {
                    this.originConnection.relativePosition = z
                }
                if (!A.empty()) {
                    this.destinationConnection.relativePosition = A
                }
                this.setPoints(w.controlPoints, true);
                if (w.originAnchor !== undefined) {
                    this.originConnection.anchorPointDetails.index = w.originAnchor
                }
                if (w.destinationAnchor !== undefined) {
                    this.destinationConnection.anchorPointDetails.index = w.destinationAnchor
                }
                if (w.labels) {
                    this.labels = [];
                    for (var v = 0, t = w.labels.length; v < t; v++) {
                        var u = new c.LinkLabel(this);
                        u.fromJson(w.labels[v]);
                        this.labels.push(u)
                    }
                }
                this.dynamic = w.dynamic;
                this.cascadeStartHorizontal = w.cascadeStartHorizontal;
                if (w.autoRoute != undefined) {
                    this.autoRoute = w.autoRoute
                }
            },
            loadFromXml: function(D, u) {
                mflayer.callBaseMethod(r, this, "loadFromXml", [D, u]);
                var C = u.fileVersion < 16 ? u.readInt("Style", D, this.shape) : u.readInt("Shape", D, this.shape);
                this.setShape(C);
                this.setControlPoints(u.readPoints("Points", D));
                if (this.originConnection.setRow) {
                    this.originConnection.setRow(u.readInt("OriginRow", D), true)
                }
                if (this.destinationConnection.setRow) {
                    this.destinationConnection.setRow(u.readInt("DestinationRow", D), true)
                }
                this.originConnection.anchorPointDetails.index = u.readInt("OriginAnchor", D);
                this.originConnection.anchorPointDetails.point = this.getStartPoint();
                this.destinationConnection.anchorPointDetails.index = u.readInt("DestinationAnchor", D);
                this.destinationConnection.anchorPointDetails.point = this.getEndPoint();
                this.dynamic = u.readBool("Dynamic", D);
                this.autoRoute = u.readBool("AutoRoute", D);
                this.cascadeStartHorizontal = u.readBool("CascadeStartHorizontal", D);
                this.setTextStyle(u.readInt("TextStyle", D));
                if (u.classVersion > 1) {
                    this.setBaseShape(u.readShape("BaseShape", D));
                    this.setHeadShape(u.readShape("HeadShape", D))
                } else {
                    this.setBaseShape(u.readArrowheadV13("BaseShape", D));
                    this.setHeadShape(u.readArrowheadV13("HeadShape", D))
                }
                this.setHeadShapeSize(u.readFloat("HeadShapeSize", D));
                this.setBaseShapeSize(u.readFloat("BaseShapeSize", D));
                this.headBrush = u.readBrush("HeadBrush", D);
                this.baseBrush = u.readBrush("BaseBrush", D);
                var v = u.readPen("HeadPen", D);
                if (v) {
                    this.headStroke = v.brush;
                    this.headStrokeThickness = v.width;
                    this.headStrokeDashStyle = v.dashStyle
                } else {
                    this.headStroke = u.readBrush("HeadStroke", D);
                    this.headStrokeThickness = u.readFloat("HeadStrokeThickness", D);
                    this.headStrokeDashStyle = MindFusion.Drawing.DashStyle[u.readString("HeadStrokeDashStyle", D)];
                    if (this.headStrokeDashStyle === undefined) {
                        this.headStrokeDashStyle = u.readInt("HeadStrokeDashStyle", D)
                    }
                }
                var A = u.selectNode(D, "Labels");
                if (A) {
                    this.labels = [];
                    var t = A.getElementsByTagName("Label");
                    for (var w = 0; w < t.length; ++w) {
                        var z = t[w];
                        var B = new c.LinkLabel(this);
                        B.loadFromXml(z, u);
                        labels.push(B)
                    }
                }
            },
            saveToXml: function(v, u) {
                mflayer.callBaseMethod(r, this, "saveToXml", [v, u]);
                u.writeItemReference(mflayer.isInstanceOfType(c.DummyNode, this.originConnection.node) ? null : this.originConnection.node, "Origin", v);
                u.writePointF(this.originConnection.relativePosition, "OriginRelative", v);
                u.writeInt(this.getOriginAnchor(), "OriginAnchor", v);
                u.writeItemReference(mflayer.isInstanceOfType(c.DummyNode, this.destinationConnection.node) ? null : this.destinationConnection.node, "Destination", v);
                u.writePointF(this.destinationConnection.relativePosition, "DestinationRelative", v);
                u.writeInt(this.getDestinationAnchor(), "DestinationAnchor", v);
                if (this.originConnection.setRow) {
                    u.writeInt(this.originConnection.row, "OriginRow", v)
                }
                if (this.destinationConnection.setRow) {
                    u.writeInt(this.destinationConnection.row, "DestinationRow", v)
                }
                u.writeInt(this.getShape(), "Shape", v);
                u.writeInt(this.getSegmentCount(), "SegmentCount", v);
                u.writePointCollection(this.points, "Points", v);
                u.writeBool(this.dynamic, "Dynamic", v);
                u.writeBool(this.autoRoute, "AutoRoute", v);
                u.writeBool(true, "AutoSnapToNode", v);
                u.writeBool(this.cascadeStartHorizontal, "CascadeStartHorizontal", v);
                u.writeInt(this.getTextStyle(), "TextStyle", v);
                u.writeShape(this.getBaseShape(), "BaseShape", v);
                u.writeShape(this.getHeadShape(), "HeadShape", v);
                u.writeFloat(this.getHeadShapeSize(), "HeadShapeSize", v);
                u.writeFloat(this.getBaseShapeSize(), "BaseShapeSize", v);
                u.writeBrush(this.headBrush, "HeadBrush", v);
                u.writeBrush(this.baseBrush, "BaseBrush", v);
                if (this.headStroke !== undefined) {
                    u.writeBrush(this.headStroke, "HeadStroke", v)
                }
                if (this.headStrokeThickness !== undefined) {
                    u.writeFloat(this.headStrokeThickness, "HeadStrokeThickness", v)
                }
                if (this.headStrokeDashStyle !== undefined) {
                    u.writeInt(this.headStrokeDashStyle, "HeadStrokeDashStyle", v)
                }
                if (this.labels) {
                    var t = u.addChildElement("Labels", v);
                    this.labels.forEach(function(z) {
                        var w = u.addChildElement("Label", t);
                        z.saveToXml(w, u)
                    })
                }
            },
            invalidate: function() {
                mflayer.callBaseMethod(r, this, "invalidate");
                if (this.labels) {
                    for (var u = 0, t = this.labels.length; u < t; u++) {
                        this.labels[u].invalidate(true)
                    }
                }
            },
            setShape: function(u) {
                if (this.shape != u) {
                    var t = this.getSegmentCount();
                    this.shape = u;
                    if (this.isReflexive() && this.shape == c.LinkShape.Cascading) {
                        this.setSegmentCount(3)
                    } else {
                        if (this.shape == c.LinkShape.Cascading && t == 1) {
                            this.setSegmentCount(2)
                        } else {
                            this.setSegmentCount(t)
                        }
                    }
                    if (this.isReflexive()) {
                        this.shapeImpl().resetSelfLoopPoints(this, true)
                    }
                    if (!this.shapeImpl().pointsValid(this)) {
                        this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                    }
                    this.resetCrossings();
                    this.invalidate()
                }
            },
            getShape: function() {
                return this.shape
            },
            shapeImpl: function() {
                return n[this.shape]
            },
            setControlPoints: function(t) {
                this.invalidate();
                this.points = t;
                this.updateFromPoints();
                this.setDiagramDirty()
            },
            getControlPoints: function() {
                return this.points
            },
            setTextStyle: function(t) {
                if (this.textStyle != t) {
                    this.textStyle = t;
                    this.updateText();
                    this.invalidate();
                    this.setDiagramDirty()
                }
            },
            getTextStyle: function() {
                return this.textStyle
            },
            setTextAlignment: function(t) {
                if (this.textAlignment != t) {
                    this.textAlignment = t;
                    this.updateText();
                    this.invalidate();
                    this.setDiagramDirty()
                }
            },
            getTextAlignment: function() {
                return this.textAlignment
            },
            getTextToEdit: function() {
                return this.text
            },
            setText: function(t) {
                if (t != undefined && t !== this.text) {
                    this.invalidate();
                    this.text = t + "";
                    if (this.parent) {
                        this.textSize = this.parent.measureString(this.text, this.getEffectiveFont())
                    }
                    this.invalidate()
                }
            },
            getText: function() {
                return this.text
            },
            raiseClicked: function(v, t) {
                var u = new c.LinkEventArgs({
                    link: this,
                    mousePosition: v,
                    mouseButton: t
                });
                this.parent.raiseEvent(c.Events.linkClicked, u);
                return u.getHandled()
            },
            raiseDoubleClicked: function(v, t) {
                var u = new c.LinkEventArgs({
                    link: this,
                    mousePosition: v,
                    mouseButton: t
                });
                this.parent.raiseEvent(c.Events.linkDoubleClicked, u);
                return u.getHandled()
            },
            updateIntersections: function() {
                this.points[0] = this.originConnection.getInitialPoint();
                this.points[this.points.length - 1] = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[0] = this.originConnection.getIntersection(this.points[0], this.points[1]);
                    this.points[this.points.length - 1] = this.destinationConnection.getIntersection(this.points[this.points.length - 1], this.points[this.points.length - 2])
                }
                if (c.ContainerNode.usingContainerNodes) {
                    var w = c.ContainerNode.getFoldedContainer(this.getOrigin());
                    var v = c.ContainerNode.getFoldedContainer(this.getDestination());
                    if (w != null || v != null) {
                        if (w != null) {
                            this.points[0] = w.getCenter()
                        }
                        if (v != null) {
                            this.points[this.points.length - 1] = v.getCenter()
                        }
                        var u = w != null ? w : this.getOrigin();
                        var t = v != null ? v : this.getDestination();
                        this.points[0] = u.getIntersection(this.points[0], this.points[1]);
                        this.points[this.points.length - 1] = t.getIntersection(this.points[this.points.length - 1], this.points[this.points.length - 2]);
                        if (this.shape == c.LinkShape.Cascading) {
                            f.AlignLastCascadingSegment(this)
                        }
                    }
                }
                this.originConnection.saveEndRelative();
                this.destinationConnection.saveEndRelative()
            },
            updateOriginIntersection: function() {
                this.points[0] = this.originConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[0] = this.originConnection.getIntersection(this.points[0], this.points[1])
                }
                this.originConnection.saveEndRelative();
                this.updateFromPoints();
                if (this.autoRoute) {
                    this.route({
                        updateFromPoints: false
                    })
                }
            },
            updateDestinationIntersection: function() {
                this.points[this.points.length - 1] = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    this.points[this.points.length - 1] = this.destinationConnection.getIntersection(this.points[this.points.length - 1], this.points[this.points.length - 2])
                }
                this.destinationConnection.saveEndRelative();
                this.updateFromPoints();
                if (this.autoRoute) {
                    this.route({
                        updateFromPoints: false
                    })
                }
            },
            doRoute: function() {
                for (var u = 0, t = this.points.length - 1; u < t; u++) {
                    var A = this.points[u];
                    var z = this.points[u + 1];
                    this.bounds = this.getBounds();
                    this.angles.push(o.angleBetween(A, z));
                    var w = o.addVector(A, {
                        x: this.baseShapeSize / 2,
                        y: this.baseShapeSize / 2
                    });
                    var v = o.addVector(z, {
                        x: this.baseShapeSize / 2,
                        y: this.baseShapeSize / 2
                    });
                    if (u === 0) {
                        this.baseShapeBounds = new MindFusion.Drawing.Rect(A.x - this.baseShapeSize / 2, A.y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize)
                    }
                    if (u === this.points.length - 2) {
                        this.headShapeBounds = new MindFusion.Drawing.Rect(z.x - this.headShapeSize / 2, z.y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize)
                    }
                }
            },
            startDrag: function(t) {
                mflayer.callBaseMethod(r, this, "startDrag", [t]);
                if (t.action === c.Action.Create && this.originConnection != null) {
                    this.originConnection.chooseBestAnchorPoint(t.startPoint);
                    this.points[0] = this.originConnection.anchorPointDetails.point;
                    this.updateFromPoints()
                }
            },
            updateDrag: function(v) {
                var A = v.adjustmentHandle.index;
                var u = v.originalStates.get(this).controlPoints;
                var z = new o(u[A].x, u[A].y);
                var t = z.addVector(v.delta());
                this.invalidate();
                var B = (A === 0 || A === this.points.length - 1);
                if (B) {
                    this.updateTargetConnection(t, A > 0)
                }
                var w = B && this.targetConnection != null && !mflayer.isInstanceOfType(c.DummyNode, this.targetConnection.node);
                this.points[A] = t = w ? this.targetConnection.anchorPointDetails.point : t;
                if (v.action === c.Action.Create) {
                    this.arrangePoints();
                    if (!this.shapeImpl().pointsValid(this)) {
                        this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                    }
                } else {
                    this.shapeImpl().updateRelatedPoints(this, t, v)
                }
                if (this.dynamic && this.shape != c.LinkShape.Cascading && this.points.length > 2 && (A == 1 || A == this.points.length - 2)) {
                    this.updatePosFromOrgAndDest()
                }
                this.updateFromPoints(true, u)
            },
            endDrag: function(t) {
                var u = false;
                var v = t.adjustmentHandle.index;
                var w = t.currentPoint;
                if (v === 0 || v === this.points.length - 1) {
                    if (v === 0) {
                        this.setupOriginConnection(this.targetConnection)
                    } else {
                        if (v === this.points.length - 1) {
                            this.setupDestConnection(this.targetConnection)
                        }
                    }
                    this.originConnection.saveEndRelative();
                    this.destinationConnection.saveEndRelative();
                    this.origin = this.originConnection.node;
                    this.destination = this.destinationConnection.node;
                    if (t.action === c.Action.Create) {
                        if (this.origin == this.destination && !mflayer.isInstanceOfType(c.DummyNode, this.origin)) {
                            this.setLoopShape()
                        } else {
                            this.arrangePoints();
                            if (!this.shapeImpl().pointsValid(this)) {
                                this.shapeImpl().initialize(this, this.getStartPoint(), this.getEndPoint())
                            }
                        }
                    }
                    if (this.autoRoute) {
                        this.route({
                            updateFromPoints: false
                        })
                    }
                }
                this.updateFromPoints()
            },
            allowDrag: function(t) {
                var u = t.adjustmentHandle.index;
                if (u !== 0 && u !== (this.points.length - 1)) {
                    return true
                }
                if (this.targetConnection == null) {
                    return this.parent.allowUnconnectedLinks
                }
                if (!this.targetConnection.node.allowIncomingLinks && u === this.points.length - 1) {
                    return false
                }
                if (!this.parent.allowSelfLoops) {
                    if (u == 0 && this.destination == this.targetConnection.node) {
                        return false
                    }
                    if (u == this.points.length - 1 && this.origin == this.targetConnection.node) {
                        return false
                    }
                }
                return true
            },
            saveLocationState: function() {
                return {
                    controlPoints: p.clone(this.points)
                }
            },
            restoreLocationState: function(t) {
                this.invalidate();
                var v = t.originalStates.get(this);
                if (v != null) {
                    var u = this.points;
                    this.points = v.controlPoints;
                    this.updateFromPoints(true, u)
                }
            },
            updateTargetConnection: function(t, u) {
                var v = this.parent.getNodeAt(t, true, true);
                if (v == null) {
                    v = this.parent.getNearestNode(t, this.parent.autoSnapDistance, (u) ? this.origin : this.destination, true)
                }
                if (v != null) {
                    if (u && !v.allowIncomingLinks || !u && !v.allowOutgoingLinks) {
                        v = null
                    }
                }
                if (v == null && this.parent.allowUnconnectedLinks) {
                    v = this.getDummyNode()
                }
                if (v) {
                    if (this.targetConnection == null || (this.targetConnection != null && this.targetConnection.linkChanges(v, t))) {
                        this.targetConnection = v.createConnectionPoint(this, t, u)
                    }
                    if (this.targetConnection != null) {
                        this.targetConnection.chooseBestAnchorPoint(t)
                    }
                    return
                }
                this.targetConnection = null
            },
            getEditRect: function(t) {
                var u = new MindFusion.Drawing.Size(100, 25 / this.parent.scale);
                return new MindFusion.Drawing.Rect(t.x - u.width / 2, t.y - u.height / 2, u.width, u.height)
            },
            setOrigin: function(t, u) {
                var v = u ? false : true;
                if (this.originConnection != null) {
                    this.originConnection.removeLinkFromNode();
                    this.originConnection = null
                }
                this.origin = t;
                if (this.origin != null) {
                    if (!u) {
                        u = t.getAnchor(this.getEndPoint(), this, false)
                    }
                    this.originConnection = this.origin.createConnectionPoint(this, u.point, false, true);
                    this.originConnection.anchorPointDetails = u;
                    this.points[0] = u.point
                }
                if (v) {
                    this.originConnection.addLinkToNode();
                    if (this.getOriginAnchor() == -1) {
                        this.updateIntersections()
                    }
                    this.shapeImpl().updateFromEndPoints(this, true);
                    this.invalidate()
                }
            },
            getOrigin: function() {
                return this.origin
            },
            setOriginAnchor: function(t) {
                var u = this.origin.getAnchorFromIndex(t);
                if (!u) {
                    return
                }
                this.originConnection.anchorPointDetails = u;
                this.points[0] = u.point;
                this.shapeImpl().updateFromEndPoints(this, true);
                this.invalidate()
            },
            getOriginAnchor: function() {
                if (!this.originConnection.anchorPointDetails) {
                    return -1
                } else {
                    return this.originConnection.anchorPointDetails.index
                }
            },
            setDestination: function(t, u) {
                var v = u ? false : true;
                if (this.destinationConnection != null) {
                    this.destinationConnection.removeLinkFromNode();
                    this.destinationConnection = null
                }
                this.destination = t;
                if (this.destination != null) {
                    if (!u) {
                        u = t.getAnchor(this.getStartPoint(), this, true)
                    }
                    this.destinationConnection = this.destination.createConnectionPoint(this, u.point, true, true);
                    this.destinationConnection.anchorPointDetails = u;
                    this.points[this.points.length - 1] = u.point;
                    this.destinationConnection.saveEndRelative()
                }
                if (v) {
                    this.destinationConnection.addLinkToNode();
                    if (this.getDestinationAnchor() == -1) {
                        this.updateIntersections()
                    }
                    this.shapeImpl().updateFromEndPoints(this, true);
                    this.invalidate()
                }
            },
            getDestination: function() {
                return this.destination
            },
            setDestinationAnchor: function(t) {
                var u = this.destination.getAnchorFromIndex(t, true);
                if (!u) {
                    return
                }
                this.destinationConnection.anchorPointDetails = u;
                this.points[this.points.length - 1] = u.point;
                this.shapeImpl().updateFromEndPoints(this, true);
                this.invalidate()
            },
            getDestinationAnchor: function() {
                if (!this.destinationConnection.anchorPointDetails) {
                    return -1
                } else {
                    return this.destinationConnection.anchorPointDetails.index
                }
            },
            isConnected: function() {
                if (this.origin == null || mflayer.isInstanceOfType(c.DummyNode, this.origin)) {
                    return false
                }
                if (this.destination == null || mflayer.isInstanceOfType(c.DummyNode, this.destination)) {
                    return false
                }
                return true
            },
            isReflexive: function() {
                return this.originConnection != null && this.destinationConnection != null && this.originConnection.sameNode(this.destinationConnection)
            },
            resetLink: function() {
                this.shape = c.LinkShape.Polyline;
                this.points.length = 2;
                this.updateIntersections();
                this.updateFromPoints()
            },
            copyPoints: function(A, v, u, z, C) {
                if (!A) {
                    this.resetLink();
                    return
                }
                this.points = [];
                for (var w = 0, t = A.length; w < t; w++) {
                    var B = A[w];
                    this.points.push(new o(B.x + v, B.y + u))
                }
                if (z) {
                    this.updateIntersections();
                    this.updateFromPoints()
                }
                if (!C) {
                    this.shapeImpl().updateFromRoute(this)
                }
            },
            updatePosFromOrgAndDest: function() {
                if (this.dynamic && this.origin != this.destination) {
                    this.putEndPointsAtNodeBorders(c.Action.Modify, false);
                    if (c.ContainerNode.usingContainerNodes) {
                        var u = c.ContainerNode.getFoldedContainer(this.getOrigin());
                        if (u != null) {
                            this.points[0] = this.originConnection.getLocation();
                            if (this.shape == c.LinkShape.Cascading) {
                                f.alignFirstCascadingSegment(this)
                            }
                        }
                        var t = c.ContainerNode.getFoldedContainer(this.getDestination());
                        if (t != null) {
                            this.points[this.points.length - 1] = this.destinationConnection.getLocation();
                            if (this.shape == c.LinkShape.Cascading) {
                                f.AlignLastCascadingSegment(this)
                            }
                        }
                    }
                } else {
                    this.points[0] = this.originConnection.getLocation();
                    this.points[this.points.length - 1] = this.destinationConnection.getLocation()
                }
                this.shapeImpl().updateFromEndPoints(this, false)
            },
            updateFromPoints: function() {
                var t = true;
                if (arguments.length > 0) {
                    t = arguments[0]
                }
                var u = null;
                if (arguments.length > 1) {
                    u = arguments[1]
                }
                this.angles = [];
                this.doRoute();
                if (t) {
                    if (this.originConnection != null) {
                        this.originConnection.saveEndRelative()
                    }
                    if (this.destinationConnection != null) {
                        this.destinationConnection.saveEndRelative()
                    }
                }
                if (this.baseShape) {
                    if (!this.baseShapeRenderer) {
                        this.baseShapeRenderer = new c.ShapeRenderer(this.baseShape)
                    }
                    this.baseShapeRenderer.updateData(this.baseShapeBounds, this.angles[0] + 90)
                }
                if (this.headShape) {
                    if (!this.headShapeRenderer) {
                        this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                    }
                    this.headShapeRenderer.updateData(this.headShapeBounds, this.angles[this.angles.length - 1] + 90)
                }
                var w = this.getParent();
                if (w && w.getLinkCrossings() != c.LinkCrossings.Straight) {
                    if (u) {
                        var v = this.getPointsBounds(u);
                        v = v.union(this.getBounds());
                        this.resetCrossings(v)
                    } else {
                        this.resetCrossings()
                    }
                }
                this.invalidate()
            },
            updateNodeCollections: function() {
                if (this.originConnection != null) {
                    this.originConnection.addLinkToNode()
                }
                if (this.destinationConnection != null) {
                    this.destinationConnection.addLinkToNode()
                }
            },
            setupOriginConnection: function(t) {
                var u = this.originConnection;
                this.originConnection = t;
                if (u != null) {
                    u.removeLinkFromNode()
                }
                this.originConnection.addLinkToNode()
            },
            setupDestConnection: function(t) {
                var u = this.destinationConnection;
                this.destinationConnection = t;
                if (u != null) {
                    u.removeLinkFromNode()
                }
                this.destinationConnection.addLinkToNode()
            },
            handleAtPoint: function(t) {
                if (!this.parent) {
                    return null
                }
                var w = this.getEffectiveHandlesSize();
                var A = b.getMillimeter(this.parent.measureUnit);
                var v = this.points;
                var z = new e(0, 0, w, w);
                if (this.parent) {
                    z = z.inflate(this.parent.touchThreshold)
                }
                for (var u = 0; u < v.length; ++u) {
                    z.setCenter(v[u]);
                    if (z.containsPoint(t)) {
                        return {
                            item: this,
                            index: u
                        }
                    }
                }
            },
            validateParams: function(u) {
                if (u.length === 0) {
                    return
                }
                this.parent = u[0];
                if (u[1] && mflayer.isInstanceOfType(c.DiagramNode, u[1])) {
                    this.origin = u[1];
                    this.setOrigin(this.origin, this.origin.getAnchor(this.origin.getCenter(), this, false))
                } else {
                    var t = u[1] && mflayer.isInstanceOfType(o, u[1]) ? u[1] : this.points[0];
                    this.originConnection = new c.DummyConnectionPoint(this, false, t);
                    this.origin = this.getDummyNode()
                }
                if (u[2] && mflayer.isInstanceOfType(c.DiagramNode, u[2])) {
                    this.destination = u[2];
                    this.setDestination(this.destination, this.destination.getAnchor(this.destination.getCenter(), this, true))
                } else {
                    var t = u[2] && mflayer.isInstanceOfType(o, u[2]) ? u[2] : this.points[this.points.length - 1];
                    this.destinationConnection = new c.DummyConnectionPoint(this, true, t);
                    this.destination = this.getDummyNode()
                }
                this.updateIntersections();
                this.updateFromPoints();
                this.putEndPointsAtNodeBorders(c.Action.Modify, false)
            },
            setStartPoint: function(t) {
                this.points[0] = t
            },
            getStartPoint: function() {
                return this.points[0].clone()
            },
            setEndPoint: function(t) {
                this.points[this.points.length - 1] = t
            },
            getEndPoint: function() {
                return this.points[this.points.length - 1].clone()
            },
            getHandlePosition: function(t) {
                return this.points[t]
            },
            getBaseType: function() {
                return this.constructor.__baseType.__typeName
            },
            getDummyNode: function() {
                if (this.parent) {
                    return this.parent.dummy
                }
                return new c.DummyNode()
            },
            containsPoint: function(t) {
                var w = this.getBounds();
                var u = -1;
                if (this.parent.linkHitDistance != 0) {
                    u = this.parent.linkHitDistance
                } else {
                    u = c.Utils.getLineHitTest(this.parent.measureUnit)
                }
                var z = u / 2;
                var v = u * 2 / 3;
                if (this.labelFromPoint(t) != null) {
                    return true
                }
                w = c.Utils.inflate(w, z, z);
                if (!w.containsPoint(t)) {
                    return false
                }
                if (this.shapeImpl().containsPoint(this, t, v)) {
                    return true
                }
                if (this.selected && this.handleAtPoint(t)) {
                    return true
                }
                return false
            },
            getBounds: function() {
                return this.getPointsBounds(this.points)
            },
            getPointsBounds: function(A) {
                var D = A[0];
                var C = A[A.length - 1];
                var v = Math.min(D.x, C.x);
                var B = Math.max(D.x, C.x);
                var z = Math.min(D.y, C.y);
                var u = Math.max(D.y, C.y);
                for (var w = 1; w < A.length - 1; ++w) {
                    v = Math.min(v, A[w].x);
                    z = Math.min(z, A[w].y);
                    B = Math.max(B, A[w].x);
                    u = Math.max(u, A[w].y)
                }
                return new MindFusion.Drawing.Rect(v, z, B - v, u - z)
            },
            adjustRepaintBounds: function(z) {
                var A = 0;
                if (this.headShapeRenderer || this.baseShapeRenderer) {
                    A = Math.max(this.headShapeSize, this.baseShapeSize)
                }
                if (this.textSize) {
                    A = Math.max(A, this.textSize.width);
                    A = Math.max(A, this.textSize.height)
                }
                if (this.labels && this.labels.length > 0) {
                    for (var w = 0, t = this.labels.length; w < t; w++) {
                        var u = this.labels[w];
                        var v = u.cachedLayoutSize;
                        if (v) {
                            A = Math.max(A, v.width);
                            A = Math.max(A, v.height)
                        }
                    }
                }
                if (A > 0) {
                    z = z.adjusted(-A, -A, A, A)
                }
                if (this.getShape() == c.LinkShape.Spline) {
                    var C = new MindFusion.Drawing.CardinalSpline(this.points);
                    var B = this.getPointsBounds(C.splinePoints);
                    z = z.union(B)
                }
                return z
            },
            updateText: function() {
                if (!this.parent) {
                    return
                }
                var af = MindFusion.Geometry;
                this.textRenderer.clearLayout();
                this.textRenderer.textAlignment = this.textAlignment;
                this.textSize = this.parent.measureString(this.text, this.getEffectiveFont());
                var V = this.getSegmentCount();
                if (this.textStyle == c.LinkTextStyle.Rotate) {
                    var C = Math.floor(this.points.length / 2 - 1);
                    var B = 1;
                    var ah = C;
                    var ak = 0,
                        ay = 0,
                        Q = 0;
                    if (this.shape != c.LinkShape.Bezier) {
                        if (this.shape == c.LinkShape.Cascading || (this.shape == c.LinkShape.Polyline && V % 2 == 1)) {
                            do {
                                var A = af.cartesianToPolar(this.points[C], this.points[C + 1]);
                                ay = A.a;
                                ak = A.r;
                                if (ak > Q) {
                                    Q = ak;
                                    ah = C
                                }
                                C = C + B;
                                B = -c.Utils.sign(B) * (Math.abs(B) + 1);
                                if (C < 0 || C >= this.points.length - 1) {
                                    break
                                }
                            } while (this.textSize.width > ak);
                            C = ah;
                            x = (this.points[C].x + this.points[C + 1].x) / 2;
                            y = (this.points[C].y + this.points[C + 1].y) / 2
                        } else {
                            C = C + 1;
                            x = this.points[C].x;
                            y = this.points[C].y
                        }
                    } else {
                        if (V % 2 == 1) {
                            C = Math.floor((C + 1) / 4);
                            var ai = c.Utils.getBezierPt(this.points, C, 0.5);
                            x = ai.x;
                            y = ai.y
                        } else {
                            C = Math.floor((C + 1) / 4);
                            var ai = this.points[(C + 1) * 3];
                            x = ai.x;
                            y = ai.y
                        }
                    }
                    if (this.shape != c.LinkShape.Bezier) {
                        if (this.shape == c.LinkShape.Cascading || (this.shape == c.LinkShape.Polyline && V % 2 == 1)) {
                            var ae = this.points[C];
                            var ac = this.points[C + 1];
                            var A = af.cartesianToPolarDegrees(ae, ac);
                            ay = A.a;
                            ak = A.r
                        } else {
                            var I = 0,
                                ap = 0;
                            var A = af.cartesianToPolarDegrees(this.points[C - 1], this.points[C]);
                            ay = A.a;
                            ak = A.r;
                            var A = af.cartesianToPolarDegrees(this.points[C], this.points[C + 1]);
                            ap = A.a;
                            H = A.r;
                            ay = (ay + ap) / 2
                        }
                    } else {
                        if (V % 2 == 1) {
                            var ae = c.Utils.getBezierPt(this.points, C, 0.45);
                            var ac = c.Utils.getBezierPt(this.points, C, 0.55);
                            var A = af.cartesianToPolarDegrees(ae, ac);
                            ay = A.a;
                            ak = A.r
                        } else {
                            var ae = c.Utils.getBezierPt(this.points, C, 0.95);
                            var ac = c.Utils.getBezierPt(this.points, C + 1, 0.05);
                            var A = af.cartesianToPolarDegrees(ae, ac);
                            ay = A.a;
                            ak = A.r
                        }
                    }
                    ay = 180 - ay;
                    if (ay > 90 && ay < 270) {
                        ay -= 180
                    }
                    this.textRenderer.strings.push(this.text);
                    this.textRenderer.angles.push(ay);
                    this.textRenderer.rectangles.push(new e(x, y, this.textSize.width, this.textSize.height))
                } else {
                    if (this.textStyle == c.LinkTextStyle.Center) {
                        if (this.points.length % 2 == 1) {
                            x = this.points[Math.floor(this.points.length / 2)].x;
                            y = this.points[Math.floor(this.points.length / 2)].y
                        } else {
                            x = this.points[this.points.length / 2 - 1].x + this.points[this.points.length / 2].x;
                            y = this.points[this.points.length / 2 - 1].y + this.points[this.points.length / 2].y;
                            x /= 2;
                            y /= 2
                        }
                        this.textRenderer.strings.push(this.text);
                        this.textRenderer.angles.push(0);
                        this.textRenderer.rectangles.push(new e(x, y, this.textSize.width, this.textSize.height))
                    } else {
                        if (this.textStyle == c.LinkTextStyle.OverLongestSegment) {
                            var Y = this.textAlignment;
                            var ag = q.Center;
                            var J = this.getLongestSegment();
                            var F = this.getNearPoint(J).clone();
                            var S = this.getFarPoint(J).clone();
                            var z = Math.abs(F.x - S.x);
                            var w = Math.abs(F.y - S.y);
                            if (z > w * 1.3 && this.textAlignment != q.Center) {
                                if (F.x < S.x && this.textAlignment == q.Near) {
                                    Y = q.Near;
                                    F.y -= this.textSize.height / 2;
                                    F.x += this.headShapeSize;
                                    this.textRenderer.rectangles.push(new e(F.x, F.y, this.textSize.width, this.textSize.height))
                                } else {
                                    if (F.x > S.x && this.textAlignment == q.Far) {
                                        Y = q.Near;
                                        S.y -= this.textSize.height / 2;
                                        S.x += this.headShapeSize;
                                        this.textRenderer.rectangles.push(new e(S.x, S.y, this.textSize.width, this.textSize.height))
                                    } else {
                                        if (F.x < S.x && this.textAlignment == q.Far) {
                                            Y = q.Far;
                                            S.x -= this.headShapeSize;
                                            this.textRenderer.rectangles.push(new e(S.x - this.textSize.width, S.y - this.textSize.height / 2, this.textSize.width, this.textSize.height))
                                        } else {
                                            Y = q.Far;
                                            F.x -= this.headShapeSize;
                                            this.textRenderer.rectangles.push(new e(F.x - this.textSize.width, F.y - this.textSize.height / 2, this.textSize.width, this.textSize.height))
                                        }
                                    }
                                }
                            } else {
                                var v = this.getSegmentCenter(J);
                                v.y -= this.textSize.height / 2;
                                this.textRenderer.rectangles.push(new e(v.x, v.y, this.textSize.width, this.textSize.height))
                            }
                            this.textRenderer.strings.push(this.text);
                            this.textRenderer.angles.push(0);
                            this.textRenderer.textAlignment = Y;
                            this.textRenderer.lineAlignment = ag
                        } else {
                            if (this.textStyle == c.LinkTextStyle.Follow) {
                                this.textRenderer.textAlignment = q.Near;
                                this.textRenderer.lineAlignment = q.Near;
                                var Z = p.clone(this.points);
                                var T = 0;
                                if (this.shape == c.LinkShape.Bezier) {
                                    var D = [];
                                    this.shapeImpl().createElements(this, D);
                                    var ad = c.Utils.getApproximatingContext();
                                    for (var at = 0; at < D.length; at++) {
                                        D[at].addToContext(ad)
                                    }
                                    Z = ad.transformAndGetPoints();
                                    T = 1
                                }
                                if (Z[0].x > Z[Z.length - 1].x) {
                                    for (var at = 0; at < Z.length / 2; at++) {
                                        var aj = Z[at];
                                        Z[at] = Z[Z.length - at - 1];
                                        Z[Z.length - at - 1] = aj
                                    }
                                }
                                var M = this.textSize.height;
                                var R = Z[0];
                                for (var at = T; at < Z.length - 1; at++) {
                                    var an = Z[at];
                                    var aj = Z[at + 1];
                                    var A = af.cartesianToPolarDegrees(aj, an);
                                    var ay = A.a;
                                    var ak = A.r;
                                    var O = 0;
                                    var am = 0;
                                    var H = 0;
                                    if (at < Z.length - 2) {
                                        var av = Z[at + 1];
                                        var aa = Z[at + 2];
                                        var A = af.cartesianToPolarDegrees(av, aa);
                                        am = A.a;
                                        H = A.r;
                                        if (am < ay) {
                                            am += 360
                                        }
                                        O = am - ay
                                    }
                                    var X = 0;
                                    var L = 0;
                                    var A = af.cartesianToPolarDegrees(R, aj);
                                    L = A.a;
                                    X = A.r;
                                    var ar = R;
                                    var aq = aj;
                                    var ao = new o(0, 0);
                                    var al = new o(0, 0);
                                    var u;
                                    if (O < 180) {
                                        al = af.polarToCartesianDegrees(ar, {
                                            a: ay - 90,
                                            r: M
                                        });
                                        ao = af.polarToCartesianDegrees(aq, {
                                            a: ay - 90,
                                            r: M
                                        });
                                        u = X;
                                        R = aj
                                    } else {
                                        al = af.polarToCartesianDegrees(ar, {
                                            a: ay - 90,
                                            r: M
                                        });
                                        var E = (360 - O) / 2;
                                        var W = M / Math.sin(c.Utils.radians(E));
                                        var P = Math.sqrt(Math.pow(W, 2) - Math.pow(M, 2));
                                        if (P > X) {
                                            P = X;
                                            W = Math.sqrt(Math.pow(P, 2) + Math.pow(M, 2))
                                        }
                                        ao = af.polarToCartesianDegrees(aq, {
                                            a: ay - E,
                                            r: W
                                        });
                                        aq = af.polarToCartesianDegrees(aq, {
                                            a: ay,
                                            r: P
                                        });
                                        u = X - P;
                                        if (P > H) {
                                            P = H
                                        }
                                        R = af.polarToCartesianDegrees(aj, {
                                            a: am,
                                            r: P
                                        })
                                    }
                                    this.textRenderer.rectangles.push(new e(al.x, al.y, u, M));
                                    this.textRenderer.angles.push(180 - ay)
                                }
                                var N = this.text;
                                for (var at = 0; at < this.textRenderer.rectangles.length; at++) {
                                    var ax = this.textRenderer.rectangles[at];
                                    var aw = this.fit(N, ax.width, this.getEffectiveFont());
                                    if (aw == 0) {
                                        this.textRenderer.strings.push("");
                                        continue
                                    }
                                    var K = N.substring(0, aw);
                                    N = N.substring(aw);
                                    this.textRenderer.strings.push(K)
                                }
                            } else {
                                if (this.textStyle == c.LinkTextStyle.MiddleSegment) {
                                    if (this.points.length % 2 == 1) {
                                        var ab = Math.floor(this.points.length / 2);
                                        var U = this.points[ab];
                                        var G = this.points[ab - 1];
                                        var au = this.points[ab + 1];
                                        if (af.distance(U, G) > af.distance(U, au)) {
                                            x = (G.x + U.x) / 2;
                                            y = (G.y + U.y) / 2
                                        } else {
                                            x = (au.x + U.x) / 2;
                                            y = (au.y + U.y) / 2
                                        }
                                    } else {
                                        x = this.points[this.points.length / 2 - 1].x + this.points[this.points.length / 2].x;
                                        y = this.points[this.points.length / 2 - 1].y + this.points[this.points.length / 2].y;
                                        x /= 2;
                                        y /= 2
                                    }
                                    this.textRenderer.strings.push(this.text);
                                    this.textRenderer.angles.push(0);
                                    this.textRenderer.rectangles.push(new e(x, y, this.textSize.width, this.textSize.height))
                                } else {
                                    if (this.textStyle == c.LinkTextStyle.MiddleSegmentRotated) {
                                        var C = Math.floor(this.points.length / 2 - 1);
                                        var B = 1;
                                        var ah = C;
                                        var ak = 0,
                                            ay = 0,
                                            Q = 0;
                                        if (this.shape != c.LinkShape.Bezier) {
                                            do {
                                                var A = af.cartesianToPolarDegrees(this.points[C], this.points[C + 1]);
                                                ay = A.a;
                                                ak = A.r;
                                                if (ak > Q) {
                                                    Q = ak;
                                                    ah = C
                                                }
                                                C = C + B;
                                                B = -c.Utils.sign(B) * (Math.abs(B) + 1);
                                                if (C < 0 || C >= this.points.length - 1) {
                                                    break
                                                }
                                            } while (this.textSize.width > ak);
                                            C = ah;
                                            x = (this.points[C].x + this.points[C + 1].x) / 2;
                                            y = (this.points[C].y + this.points[C + 1].y) / 2
                                        } else {
                                            if (V % 2 == 1) {
                                                C = Math.floor((C + 1) / 4);
                                                var ai = c.Utils.getBezierPt(this.points, C, 0.5);
                                                x = ai.x;
                                                y = ai.y
                                            } else {
                                                C = Math.floor((C + 1) / 4);
                                                var ai = this.points[(C + 1) * 3];
                                                x = ai.x;
                                                y = ai.y
                                            }
                                        }
                                        if (this.shape != c.LinkShape.Bezier) {
                                            var ae = this.points[C];
                                            var ac = this.points[C + 1];
                                            var A = af.cartesianToPolarDegrees(ae, ac);
                                            ay = A.a;
                                            ak = A.r
                                        } else {
                                            if (V % 2 == 1) {
                                                var ae = c.Utils.getBezierPt(this.points, C, 0.45);
                                                var ac = c.Utils.getBezierPt(this.points, C, 0.55);
                                                var A = af.cartesianToPolarDegrees(ae, ac);
                                                ay = A.a;
                                                ak = A.r
                                            } else {
                                                var ae = c.Utils.getBezierPt(this.points, C, 0.95);
                                                var ac = c.Utils.getBezierPt(this.points, C + 1, 0.05);
                                                var A = af.cartesianToPolarDegrees(ae, ac);
                                                ay = A.a;
                                                ak = A.r
                                            }
                                        }
                                        ay = 180 - ay;
                                        if (ay > 90 && ay < 270) {
                                            ay -= 180
                                        }
                                        this.textRenderer.strings.push(this.text);
                                        this.textRenderer.angles.push(ay);
                                        this.textRenderer.rectangles.push(new e(x, y, this.textSize.width, this.textSize.height))
                                    }
                                }
                            }
                        }
                    }
                }
            },
            intersects: function(t) {
                var u = this.getBounds();
                if (!u.intersectsWith(t)) {
                    return false
                }
                if (t.contains(u)) {
                    return true
                }
                return MindFusion.Geometry.polylineIntersectsRect(this.points, t)
            },
            onShapeLoaded: function() {
                this.graphicsContainer.invalidParent = this
            },
            updateCanvasElements: function() {
                var w = this.graphicsContainer.content = [];
                if (this.baseShape && this.baseShape.isDummy() && !c.Shape.loadFromLibPending) {
                    this.baseShape = c.Shape.fromId(this.baseShape.id);
                    if (this.baseShapeRenderer) {
                        this.baseShapeRenderer.setShape(this.baseShape)
                    }
                }
                if (this.headShape && this.headShape.isDummy() && !c.Shape.loadFromLibPending) {
                    this.headShape = c.Shape.fromId(this.headShape.id);
                    if (this.headShapeRenderer) {
                        this.headShapeRenderer.setShape(this.headShape)
                    }
                }
                var A = this.getEffectiveStrokeThickness();
                var D = this.getEffectiveStrokeDashStyle();
                var C = this.getEffectiveStroke();
                this.shapeImpl().createElements(this, w);
                if (this.baseShape) {
                    if (!this.baseShapeRenderer) {
                        this.baseShapeRenderer = new c.ShapeRenderer(this.baseShape)
                    }
                    this.baseShapeRenderer.updateArrowHeadData(this.baseShapeBounds, this.points[0].clone(), this.nextToFirstDifferent(this.points));
                    this.baseShapeRenderer.strokeThickness = this.getEffectiveHeadStrokeThickness();
                    this.baseShapeRenderer.outlineBrush = this.getEffectiveBaseBrush();
                    this.baseShapeRenderer.outlinePen = this.getEffectiveHeadStroke();
                    this.baseShapeRenderer.decorationPen = this.getEffectiveHeadStroke();
                    this.baseShapeRenderer.strokeDashStyle = this.getEffectiveHeadStrokeDashStyle();
                    w.push(this.baseShapeRenderer)
                }
                if (this.headShape) {
                    if (!this.headShapeRenderer) {
                        this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                    }
                    this.headShapeRenderer.updateArrowHeadData(this.headShapeBounds, this.points[this.points.length - 1].clone(), this.nextToLastDifferent(this.points));
                    this.headShapeRenderer.strokeThickness = this.getEffectiveHeadStrokeThickness();
                    this.headShapeRenderer.outlineBrush = this.getEffectiveHeadBrush();
                    this.headShapeRenderer.outlinePen = this.getEffectiveHeadStroke();
                    this.headShapeRenderer.decorationPen = this.getEffectiveHeadStroke();
                    this.headShapeRenderer.strokeDashStyle = this.getEffectiveHeadStrokeDashStyle();
                    w.push(this.headShapeRenderer)
                }
                this.textRenderer.font = this.getEffectiveFont();
                this.textRenderer.pen = this.getEffectiveTextColor();
                this.textRenderer.stroke = this.getEffectiveTextStroke();
                this.textRenderer.strokeThickness = this.getEffectiveStrokeThickness();
                this.updateText();
                w.push(this.textRenderer);
                if (this.labels) {
                    for (var v = 0, t = this.labels.length; v < t; v++) {
                        var B = this.labels[v];
                        B.text.font = B.font != undefined ? B.font : this.getEffectiveFont();
                        B.text.pen = B.textColor != undefined ? B.textColor : this.getEffectiveTextColor();
                        B.text.stroke = B.textColor != undefined ? B.textColor : this.getEffectiveTextStroke();
                        B.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                        B.getLayoutRect()
                    }
                    this.parent.updateLabelLayout();
                    var u = b.getMillimeter(this.parent.measureUnit);
                    for (var v = 0, t = this.labels.length; v < t; v++) {
                        var B = this.labels[v];
                        if (B.brush) {
                            var z = B.cachedLayoutRect.inflate(u);
                            z.brush = z.pen = B.brush;
                            w.push(z)
                        }
                        w.push(B.text)
                    }
                }
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            drawHandles: function(A) {
                var v = this.parent;
                A.fillStyle = c.Utils.getBrush(A, v.handleBrush, v.getBounds());
                A.strokeStyle = "black";
                if (A.setLineDash) {
                    A.setLineDash([])
                }
                A.lineWidth = 1 / A._mf_scale;
                var z = this.getEffectiveHandlesSize();
                var u = z / 2;
                for (var w = 0; w < this.points.length; w++) {
                    var t = this.points[w];
                    if (w % 3 > 0 || this.shape != c.LinkShape.Bezier) {
                        A.fillRect(t.x - u, t.y - u, z, z);
                        A.strokeRect(t.x - u, t.y - u, z, z)
                    } else {
                        c.HandleUtils.drawCircle(A, t, u)
                    }
                }
            },
            setBaseShape: function(t) {
                if (typeof t == "string") {
                    t = c.Shape.fromId(t)
                }
                if (this.baseShape != t) {
                    this.baseShape = t;
                    if (this.baseShapeRenderer) {
                        if (this.baseShape) {
                            this.baseShapeRenderer.setShape(this.baseShape);
                            this.baseShapeRenderer.outlineBrush = this.getEffectiveBaseBrush();
                            this.baseShapeRenderer.outlinePen = this.getEffectiveHeadStroke()
                        } else {
                            this.baseShapeRenderer = null;
                            delete this.baseShapeRenderer
                        }
                    }
                    this.invalidate()
                }
            },
            getBaseShape: function() {
                return this.baseShape
            },
            setBaseShapeSize: function(t) {
                if (t != this.baseShapeSize) {
                    this.baseShapeSize = t;
                    var u = this.points[0];
                    this.baseShapeBounds = new MindFusion.Drawing.Rect(u.x - this.baseShapeSize / 2, u.y - this.baseShapeSize / 2, this.baseShapeSize, this.baseShapeSize);
                    this.invalidate()
                }
            },
            getBaseShapeSize: function() {
                return this.baseShapeSize
            },
            setHeadShape: function(t) {
                if (typeof t == "string") {
                    t = c.Shape.fromId(t)
                }
                if (this.headShape != t) {
                    this.headShape = t;
                    if (this.headShapeRenderer) {
                        if (this.headShape) {
                            this.headShapeRenderer.setShape(this.headShape);
                            this.headShapeRenderer.outlineBrush = this.getEffectiveHeadBrush();
                            this.headShapeRenderer.outlinePen = this.getEffectiveHeadStroke()
                        } else {
                            this.headShapeRenderer = null;
                            delete this.headShapeRenderer
                        }
                    }
                    this.invalidate()
                }
            },
            getHeadShape: function() {
                return this.headShape
            },
            setHeadShapeSize: function(t) {
                if (t != this.headShapeSize) {
                    this.headShapeSize = t;
                    var u = this.points[this.points.length - 1];
                    this.headShapeBounds = new MindFusion.Drawing.Rect(u.x - this.headShapeSize / 2, u.y - this.headShapeSize / 2, this.headShapeSize, this.headShapeSize);
                    this.invalidate()
                }
            },
            getHeadShapeSize: function() {
                return this.headShapeSize
            },
            setBaseBrush: function(t) {
                if (this.baseBrush != t) {
                    this.baseBrush = t;
                    if (this.baseShape) {
                        if (!this.baseShapeRenderer) {
                            this.baseShapeRenderer = new c.ShapeRenderer(this.baseShape)
                        }
                        this.baseShapeRenderer.outlineBrush = t;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getBaseBrush: function() {
                return this.baseBrush
            },
            getEffectiveBaseBrush: function() {
                if (this.baseBrush) {
                    return this.baseBrush
                }
                return this.getEffectiveBrush()
            },
            setHeadBrush: function(t) {
                if (this.headBrush != t) {
                    this.headBrush = t;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.outlineBrush = t;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadBrush: function() {
                return this.headBrush
            },
            getEffectiveHeadBrush: function() {
                if (this.headBrush) {
                    return this.headBrush
                }
                return this.getEffectiveBrush()
            },
            setHeadStroke: function(t) {
                if (this.headStroke != t) {
                    this.headStroke = t;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.outlinePen = t;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStroke: function() {
                return this.headStroke
            },
            getEffectiveHeadStroke: function() {
                if (this.headStroke) {
                    return this.headStroke
                }
                return this.getEffectiveStroke()
            },
            setHeadStrokeThickness: function(t) {
                if (this.headStrokeThickness != t) {
                    this.headStrokeThickness = t;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.strokeThickness = t;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStrokeThickness: function() {
                return this.headStrokeThickness
            },
            getEffectiveHeadStrokeThickness: function() {
                if (this.headStrokeThickness) {
                    return this.headStrokeThickness
                }
                return this.getEffectiveStrokeThickness()
            },
            setHeadStrokeDashStyle: function(t) {
                if (this.headStrokeDashStyle != t) {
                    this.headStrokeDashStyle = t;
                    if (this.headShape) {
                        if (!this.headShapeRenderer) {
                            this.headShapeRenderer = new c.ShapeRenderer(this.headShape)
                        }
                        this.headShapeRenderer.strokeDashStyle = t;
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getHeadStrokeDashStyle: function() {
                return this.headStrokeDashStyle
            },
            getEffectiveHeadStrokeDashStyle: function() {
                if (this.headStrokeDashStyle != null) {
                    return this.headStrokeDashStyle
                }
                return this.getEffectiveStrokeDashStyle()
            },
            setPoints: function(t, u) {
                this.copyPoints(t, 0, 0, false, u);
                this.updateFromPoints(false)
            },
            setLoopShape: function() {
                var u = this.origin.bounds.topMiddle();
                var t = b.getMillimeter(this.parent.measureUnit) * 8;
                this.shape = c.LinkShape.Bezier;
                this.points = [u, u.newWithOffset(-t, -1.5 * t), u.newWithOffset(+t, -1.5 * t), u.clone()];
                this.updateFromPoints()
            },
            route: function(t) {
                if (this.parent.linkRouter) {
                    this.invalidate();
                    this.parent.linkRouter.route(this);
                    this.finalizeRoute(t)
                }
            },
            finalizeRoute: function(t) {
                if (!(t && t.updateFromPoints === false)) {
                    this.updateFromPoints(false)
                }
            },
            getAutoRoute: function() {
                return this.autoRoute
            },
            setAutoRoute: function(t) {
                this.autoRoute = t;
                if (t) {
                    this.route()
                }
            },
            getDynamic: function() {
                return this.dynamic
            },
            setDynamic: function(t) {
                if (this.dynamic !== t) {
                    this.dynamic = t;
                    this.setDiagramDirty()
                }
            },
            putEndPointsAtNodeBorders: function(u, w) {
                var v = this.originConnection.getInitialPoint();
                var t = this.destinationConnection.getInitialPoint();
                if (!this.originConnection.nodesIntersect(this.destinationConnection)) {
                    v = this.originConnection.getIntersection(v, u == c.Action.Create || w ? t : this.points[1]);
                    t = this.destinationConnection.getIntersection(t, u == c.Action.Create || w ? v : this.points[this.points.length - 2])
                }
                this.originConnection.alignEndPointToBorder(v);
                this.destinationConnection.alignEndPointToBorder(t);
                this.points[0] = this.originConnection.anchorPointDetails.point;
                this.points[this.points.length - 1] = this.destinationConnection.anchorPointDetails.point;
                this.originConnection.saveEndRelative(false);
                this.destinationConnection.saveEndRelative(false)
            },
            nextToLastDifferent: function(v) {
                var u = v[v.length - 1];
                for (var t = v.length - 2; t >= 0; --t) {
                    if (!c.Utils.pointEqualEpsilon(v[t], u)) {
                        return v[t].clone()
                    }
                }
                return u.clone()
            },
            nextToFirstDifferent: function(v) {
                var u = v[0];
                for (var t = 1, w = v.length; t < w; ++t) {
                    if (!c.Utils.pointEqualEpsilon(v[t], u)) {
                        return v[t].clone()
                    }
                }
                return u.clone()
            },
            collapse: function(t) {
                if (this.parent.expandOnIncoming) {
                    if (this.origin) {
                        this.origin.collapse(t)
                    }
                } else {
                    if (this.destination) {
                        this.destination.collapse(t)
                    }
                }
                t.add(this);
                this.setVisible(false);
                if (this.selected && this.parent) {
                    this.parent.selection.removeItem(this)
                }
            },
            setOriginIndex: function(t) {
                this.originConnection.setRow(t, true)
            },
            getOriginIndex: function() {
                return this.originConnection.row
            },
            setDestinationIndex: function(t) {
                this.destinationConnection.setRow(t, true)
            },
            getDestinationIndex: function() {
                return this.destinationConnection.row
            },
            fixRowConnections: function() {
                var u = this.getOriginIndex();
                var t = this.getDestinationIndex();
                if (u !== undefined && u > -1) {
                    this.updateOriginIntersection();
                    if (this.points.length > 2) {
                        this.cascadeStartHorizontal = true;
                        f.alignFirstCascadingSegment(this)
                    }
                }
                if (t !== undefined && t > -1) {
                    this.updateDestinationIntersection();
                    if (this.points.length > 2) {
                        f.alignLastCascadingSegment(this)
                    }
                }
            },
            resolveInheritedStyle: function(t, v) {
                var u = v.styles["std:DiagramLink"];
                if (u) {
                    if (t.apply(u)) {
                        return u
                    }
                }
                return mflayer.callBaseMethod(r, this, "resolveInheritedStyle", [t, v])
            },
            getSegmentCount: function() {
                if (this.shape == c.LinkShape.Bezier) {
                    return (this.points.length - 1) / 3
                } else {
                    return this.points.length - 1
                }
            },
            setSegmentCount: function(u) {
                var v = this.getStartPoint();
                var t = this.getEndPoint();
                if (this.shape == c.LinkShape.Bezier) {
                    this.points.length = u * 3 + 1
                } else {
                    this.points.length = u + 1
                }
                this.points[0] = v;
                this.points[this.points.length - 1] = t;
                this.arrangePoints()
            },
            arrangePoints: function() {
                var u = this.getStartPoint();
                var w = this.getEndPoint();
                var F = (w.x - u.x) / (this.points.length - 1);
                var E = (w.y - u.y) / (this.points.length - 1);
                for (var A = 0; A < this.points.length; A++) {
                    this.points[A] = new o(u.x + F * A, u.y + E * A)
                }
                if (this.shape == c.LinkShape.Cascading) {
                    var C = this.getSegmentCount();
                    var D = Math.floor(C / 2);
                    var v = Math.floor(C / 2);
                    this.cascadeStartHorizontal = Math.abs(F) > Math.abs(E);
                    if (this.cascadeStartHorizontal && C % 2 != 0) {
                        D++
                    }
                    if (!this.cascadeStartHorizontal && C % 2 != 0) {
                        v++
                    }
                    var z = (w.x - u.x) / D;
                    var B = (w.y - u.y) / v;
                    var t = this.cascadeStartHorizontal;
                    for (var A = 1; A < this.points.length; A++) {
                        if (t) {
                            this.points[A].x = this.points[A - 1].x + z;
                            this.points[A].y = this.points[A - 1].y
                        } else {
                            this.points[A].x = this.points[A - 1].x;
                            this.points[A].y = this.points[A - 1].y + B
                        }
                        t = !t
                    }
                }
                this.updateFromPoints()
            },
            getPolyLine: function(t) {
                if (this.shape == c.LinkShape.Bezier) {
                    return c.Utils.approximateBezier(this.points, t)
                }
                return this.points
            },
            segmentToPolyline: function(u) {
                var t = [];
                if (this.shape != c.LinkShape.Bezier) {
                    t.push(this.points[u]);
                    t.push(this.points[u + 1])
                } else {
                    t = c.Utils.approximateBezier(this.points.slice(0), 30, u * 3)
                }
                return t
            },
            getLength: function(t) {
                if (t == undefined) {
                    t = this.getPolyLine(20)
                }
                var z = 0;
                for (var v = 0; v < t.length - 1; ++v) {
                    var w = t[v];
                    var u = t[v + 1];
                    z += w.distance(u)
                }
                return z
            },
            pointAlongLength: function(v, z) {
                if (z == undefined) {
                    z = this.getPolyLine(20)
                }
                var t = v * this.getLength(z);
                var E = 0;
                for (var w = 0; w < z.length - 1; ++w) {
                    var C = z[w];
                    var B = z[w + 1];
                    var u = C.distance(B);
                    if (E + u >= t) {
                        var F = (B.x - C.x) / u;
                        var D = (B.y - C.y) / u;
                        var A = t - E;
                        return new o(C.x + F * A, C.y + D * A)
                    }
                    E += u
                }
                return z[0]
            },
            getTopLevel: function() {
                if (!c.ContainerNode.usingContainerNodes) {
                    return true
                }
                if (this.origin != null && this.origin.getTopLevel()) {
                    return true
                }
                if (this.destination != null && this.destination.getTopLevel()) {
                    return true
                }
                return mflayer.callBaseMethod(r, this, "getTopLevel", [])
            },
            addLabel: function(u) {
                var t = new c.LinkLabel(this, u);
                if (this.labels == undefined) {
                    this.labels = []
                }
                this.labels.push(t);
                this.invalidate();
                return t
            },
            removeLabel: function(t) {
                if (t != undefined && this.labels != undefined) {
                    p.remove(this.labels, t)
                }
                this.invalidate()
            },
            labelFromPoint: function(t) {
                if (this.labels == undefined) {
                    return null
                }
                for (var v = 0, u = this.labels.length; v < u; v++) {
                    if (this.labels[v].getLayoutRect().containsPoint(t)) {
                        return this.labels[v]
                    }
                }
                return null
            },
            getObjectToEdit: function(t, v) {
                if (v && (mflayer.isInstanceOfType(c.LinkLabel, v))) {
                    return v
                }
                var u = this.labelFromPoint(t);
                if (u != null) {
                    return u
                }
                return this
            },
            createEditArgs: function(t, u) {
                return new c.LinkEventArgs({
                    link: this,
                    oldText: t,
                    newText: u
                })
            },
            crossedLinksToInvalidate: function(B) {
                var u = this.getParent();
                var w = u.getZOrder();
                var A = undefined;
                for (var t = 0; t < w.length; t++) {
                    var v = w[t].item;
                    if (v == this) {
                        A = t;
                        break
                    }
                }
                if (A === undefined) {
                    A = w.length
                }
                return u.getLinkCrossings() == c.LinkCrossings.Arcs ? u.getLinksFromZ(B, A) : u.getLinksFromZ(!B, A)
            },
            resetCrossings: function(z) {
                var w = this.getParent();
                if (w == null || w.getLinkCrossings() == c.LinkCrossings.Straight) {
                    return
                }
                if (!z) {
                    z = this.getBounds()
                }
                this._mf_linkCrossings = undefined;
                var t;
                if (w.cachedZOrder == null) {
                    t = w.links
                } else {
                    t = this.crossedLinksToInvalidate(false)
                }
                for (var u = 0; u < t.length; u++) {
                    var A = t[u];
                    var v = A.getBounds();
                    if (v.intersectsWith(z)) {
                        A._mf_linkCrossings = undefined
                    }
                }
            },
            getCrossings: function() {
                var w = MindFusion.Geometry.getEllipseIntr;
                var H = this.getParent();
                var T = b.getMillimeter(H.measureUnit);
                var P = H.getCrossingRadius();
                var N = this.getBounds();
                var ab = [];
                var aa = this._mf_linkCrossings;
                if (aa == null) {
                    this._mf_linkCrossings = aa = [];
                    var t = this.crossedLinksToInvalidate(true);
                    var E = this.getSegmentCount();
                    for (var z = 0; z < E; ++z) {
                        var G = this.points[z];
                        var D = this.points[z + 1];
                        if (!G.equals(D)) {
                            for (var R = 0; R < t.length; ++R) {
                                var C = t[R];
                                if (!C.getVisible() || C.getShape() == c.LinkShape.Bezier) {
                                    continue
                                }
                                var v = C.getBounds();
                                if (!v.intersectsWith(N)) {
                                    continue
                                }
                                var U = C.getSegmentCount();
                                for (var X = 0; X < U; ++X) {
                                    var S = C.points[X];
                                    var Q = C.points[X + 1];
                                    if (S.equals(Q)) {
                                        continue
                                    }
                                    var F = c.Utils.getSegmentIntersection(G, D, S, Q);
                                    if (F && G.distance(F) > P && D.distance(F) > P && S.distance(F) > P && Q.distance(F) > P) {
                                        var u = {
                                            location: F,
                                            radius: P
                                        };
                                        ab.push(u)
                                    }
                                }
                            }
                            ab.sort(s(G))
                        }
                        var W = s(G);
                        var Z = aa[z];
                        if (!Z) {
                            Z = aa[z] = []
                        }
                        Z.push({
                            location: G,
                            radius: 0
                        });
                        for (var B = 0; B < ab.length; ++B) {
                            var A = ab[B];
                            var M = A.location;
                            P = A.radius;
                            var O = e.fromLTRB(M.x - P, M.y - P, M.x + P, M.y + P);
                            var J = w(O, G, M);
                            var I = w(O, D, M);
                            var Y = {
                                location: J,
                                radius: P
                            };
                            var V = {
                                location: I,
                                radius: P
                            };
                            if (W(Y, V) < 0) {
                                Z.push(Y);
                                Z.push(V)
                            } else {
                                Z.push(V);
                                Z.push(Y)
                            }
                        }
                        Z.push({
                            location: D,
                            radius: 0
                        });
                        for (var R = 1; R < Z.length - 2;) {
                            var L = Z[R];
                            var K = Z[R + 1];
                            if (W(L, K) > 0 || L.location.distance(K.location) < T / 2) {
                                p.removeAt(Z, R);
                                p.removeAt(Z, R)
                            } else {
                                R++
                            }
                        }
                        ab.length = 0
                    }
                }
                return aa
            },
            getLongestSegment: function() {
                var w = 0;
                var u = 0;
                var t = this.getSegmentCount();
                for (var v = 0; v < t; ++v) {
                    var z = this.getSegmentLength(v);
                    if (z > u) {
                        u = z;
                        w = v
                    }
                }
                return w
            },
            getSegmentLength: function(w) {
                var F = MindFusion.Geometry;
                switch (this.shape) {
                    case c.LinkShape.Polyline:
                    case c.LinkShape.Cascading:
                        return F.distance(this.points[w], this.points[w + 1]);
                    case c.LinkShape.Bezier:
                        var u = w * 3;
                        var t = [];
                        t.push(this.points[u++]);
                        t.push(this.points[u++]);
                        t.push(this.points[u++]);
                        t.push(this.points[u]);
                        var v = c.Utils.approximateBezier(t, 30, 0);
                        var z = 0;
                        for (var E = 0; E < v.length - 1; ++E) {
                            var B = v[E];
                            var A = v[E + 1];
                            var D = B.x - A.x;
                            var C = B.y - A.y;
                            z += Math.sqrt(D * D + C * C)
                        }
                        return z
                }
                return 0
            },
            getSegmentCenter: function(B) {
                switch (this.shape) {
                    case c.LinkShape.Bezier:
                        var A = B * 3;
                        var O = this.points[0 + A].x;
                        var z = this.points[0 + A].y;
                        var N = this.points[1 + A].x;
                        var w = this.points[1 + A].y;
                        var M = this.points[2 + A].x;
                        var v = this.points[2 + A].y;
                        var L = this.points[3 + A].x;
                        var u = this.points[3 + A].y;
                        var J = 0.5;
                        var I = (1 - J) * (1 - J) * (1 - J);
                        var H = 3 * J * (1 - J) * (1 - J);
                        var G = 3 * J * J * (1 - J);
                        var D = J * J * J;
                        var E = I * O + H * N + G * M + D * L;
                        var K = I * z + H * w + G * v + D * u;
                        return new o(E, K);
                    default:
                        var F = this.points[B];
                        var C = this.points[B + 1];
                        return new o((F.x + C.x) / 2, (F.y + C.y) / 2)
                }
            },
            getNearPoint: function(t) {
                if (this.shape == c.LinkShape.Bezier) {
                    return this.points[t * 3]
                }
                return this.points[t]
            },
            getFarPoint: function(t) {
                if (this.shape == c.LinkShape.Bezier) {
                    return this.points[t * 3 + 3]
                }
                return this.points[t + 1]
            },
            fit: function(B, v, u) {
                if (B.length == 0) {
                    return 0
                }
                var z = 0;
                var A = B[z];
                var w = new e(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
                var t = 0;
                while (true) {
                    t += this.parent.measureString(A, u, w).width;
                    if (t > v) {
                        return Math.max(0, z)
                    }
                    z++;
                    if (z < B.length) {
                        A = B[z]
                    } else {
                        return z
                    }
                }
            },
            updateAnimation: function(u, t) {
                this.setHeadShapeSize(u.getFromValue() + (u.getToValue() - u.getFromValue()) * t)
            },
            saveState: function() {
                var t = mflayer.callBaseMethod(r, this, "saveState", []);
                t.origin = this.origin;
                t.originConnection = this.originConnection.clone(this, this.origin);
                t.destination = this.destination;
                t.destinationConnection = this.destinationConnection.clone(this, this.destination);
                t.points = p.clone(this.points);
                t.shape = this.shape;
                t.baseShapeSize = this.baseShapeSize;
                t.headShapeSize = this.headShapeSize;
                t.baseShape = this.baseShape;
                t.headShape = this.headShape;
                t.baseBrush = this.baseBrush;
                t.headBrush = this.headBrush;
                t.dynamic = this.dynamic;
                t.autoRoute = this.autoRoute;
                t.labels = this.labels;
                return t
            },
            restoreState: function(t) {
                mflayer.callBaseMethod(r, this, "restoreState", [t]);
                this.originConnection.removeLinkFromNode();
                this.originConnection = t.originConnection.clone(this, t.origin);
                this.originConnection.addLinkToNode();
                this.origin = t.origin;
                this.destinationConnection.removeLinkFromNode();
                this.destinationConnection = t.destinationConnection.clone(this, t.destination);
                this.destinationConnection.addLinkToNode();
                this.destination = t.destination;
                this.setPoints(t.points, true);
                this.updateFromPoints(false);
                this.setShape(t.shape);
                this.baseShapeSize = t.baseShapeSize;
                this.headShapeSize = t.headShapeSize;
                this.setBaseShape(t.baseShape);
                this.setBaseBrush(t.baseBrush);
                this.setHeadShape(t.headShape);
                this.setHeadBrush(t.headBrush);
                this.dynamic = t.dynamic;
                this.autoRoute = t.autoRoute;
                this.labels = t.labels
            },
            init: function() {
                if (!c.DiagramLinkBuilder) {
                    c.DiagramLinkBuilder = new MindFusion.Builder(r.prototype, null, this)
                } else {
                    c.DiagramLinkBuilder.setInstance(this)
                }
                return c.DiagramLinkBuilder
            },
            defaultPoint: new o(0, 0)
        };
        var j = {
            initialize: function(z, A, t) {
                var w = z.points = [A];
                var u = 3;
                for (var v = 1; v < 3; ++v) {
                    w[v] = new o(A.x + v * (t.x - A.x) / u, A.y + v * (t.y - A.y) / u)
                }
                z.points.push(t)
            },
            createElements: function(z, w) {
                var B = z.points;
                if (B.length < 4) {
                    return a.createElements(z, w)
                }
                var C = z.getEffectiveStroke();
                var A = z.getEffectiveStrokeThickness();
                var D = z.getEffectiveStrokeDashStyle();
                for (var v = 1, u = B.length; v < u; v += 3) {
                    var t = MindFusion.Drawing.Bezier.fromPoints(B, v - 1);
                    t.pen = C;
                    t.strokeThickness = A;
                    t.strokeDashStyle = D;
                    t.shadow = z.createShadow();
                    w.push(t)
                }
            },
            containsPoint: function(v, t, u) {
                var w = c.Utils.approximateBezier(v.points, 16);
                return c.Utils.distToPolyline(t, w, w.length) < u
            },
            updateRelatedPoints: function(A, t, v) {
                var z = A.points;
                if (z.length < 4) {
                    return
                }
                var u = v.originalStates.get(A).controlPoints;
                var w = v.adjustmentHandle.index;
                if (z.length == u.length) {
                    if ((w + 1) % 3 == 0 && w < z.length - 3) {
                        z[w + 2] = c.Utils.symmetricPoint(z[w], z[w + 1])
                    }
                    if ((w - 1) % 3 == 0 && w > 3) {
                        z[w - 2] = c.Utils.symmetricPoint(z[w], z[w - 1])
                    }
                    if ((w % 3 == 0) && w > 0 && w < z.length - 1) {
                        var B = v.delta();
                        z[w - 1] = o.addVector(u[w - 1], B);
                        z[w + 1] = o.addVector(u[w + 1], B)
                    }
                }
            },
            updateFromEndPoints: function(u, t) {
                u.updateFromPoints(t)
            },
            updateFromRoute: function(C) {
                var A = C.points;
                var B = [];
                var t, w, v, u;
                B.push(A[0]);
                var z = 0;
                while (z < A.length - 2) {
                    v = A[z + 1];
                    B.push(v);
                    B.push(v);
                    if (z != A.length - 3) {
                        u = A[z + 2];
                        t = new o((v.x + u.x) / 2, (v.y + u.y) / 2);
                        B.push(t)
                    } else {
                        B.push(A[z + 2])
                    }
                    z += 1
                }
                if (B.length == 1) {
                    B = [];
                    w = A[0];
                    v = A[A.length - 1];
                    t = new o((w.x + v.x) / 2, (w.y + v.y) / 2);
                    B[0] = w;
                    B[1] = t;
                    B[2] = t.clone();
                    B[3] = v
                }
                C.points = B
            },
            pointsValid: function(t) {
                return (t.points.length - 1) % 3 == 0
            },
            resetSelfLoopPoints: function(A, z) {
                var w = A.origin.bounds.topMiddle();
                var v = b.getMillimeter(A.parent.measureUnit) * 8;
                if (z) {
                    A.points = [w, w.newWithOffset(-v, -1.5 * v), w.newWithOffset(+v, -1.5 * v), w.clone()]
                } else {
                    var u = A.points;
                    u[0] = w;
                    u[u.length - 1] = w.clone();
                    for (var t = 0; t < u.length / 2 - 1; ++t) {
                        u[1 + t] = w.newWithOffset(-v, -1.5 * v);
                        u[u.length - 2 - t] = w.newWithOffset(+v, -1.5 * v)
                    }
                    if (u.length % 2 == 1) {
                        u[u.length / 2] = w.newWithOffset(0, -1.8 * v)
                    }
                }
                A.updateFromPoints()
            }
        };
        var a = {
            initialize: function(u, v, t) {
                u.points = [v, t]
            },
            createElements: function(A, w) {
                var t = A.getParent();
                if (t && (t.getRoundedLinks() || t.getLinkCrossings() != c.LinkCrossings.Straight)) {
                    var z = new d(A);
                    w.push(z);
                    return
                }
                var F = A.getEffectiveStroke();
                var B = A.getEffectiveStrokeThickness();
                var H = A.getEffectiveStrokeDashStyle();
                var D = A.points;
                for (var v = 0, u = D.length - 1; v < u; v++) {
                    var E = D[v];
                    var C = D[v + 1];
                    var G = new MindFusion.Drawing.Line(E.x, E.y, C.x, C.y);
                    G.setPen(F);
                    G.strokeThickness = B;
                    G.strokeDashStyle = H;
                    G.shadow = A.createShadow();
                    w.push(G)
                }
            },
            containsPoint: function(v, t, u) {
                return c.Utils.distToPolyline(t, v.points, v.points.length) < u
            },
            updateRelatedPoints: function(v, t, u) {},
            updateFromEndPoints: function(u, t) {
                u.updateFromPoints(t)
            },
            updateFromRoute: function(t) {},
            pointsValid: function(t) {
                return true
            },
            resetSelfLoopPoints: function(u, t) {
                j.resetSelfLoopPoints(u, t)
            }
        };
        var f = {
            initialize: function(u, v, t) {
                if (u.points.length < 3) {
                    p.insert(u.points, 1, new MindFusion.Drawing.Point(0, 0))
                }
                this.arrangeCascadingSegments(u, v, t)
            },
            createElements: function(u, t) {
                a.createElements(u, t)
            },
            containsPoint: function(v, t, u) {
                return a.containsPoint(v, t, u)
            },
            updateRelatedPoints: function(B, u, w) {
                var A = B.points;
                if (A.length < 3) {
                    return
                }
                var C = w.currentPoint;
                var z = w.adjustmentHandle.index;
                var v = A[A.length - 1].x - A[0].x;
                var t = A[A.length - 1].y - A[0].y;
                if (w.action === c.Action.Create && (z == 0 || z == A.length - 1) && ((B.cascadeStartHorizontal && Math.abs(v) < Math.abs(t)) || (!B.cascadeStartHorizontal && Math.abs(v) > Math.abs(t)))) {
                    B.cascadeStartHorizontal = Math.abs(v) > Math.abs(t);
                    this.arrangeCascadingSegments(B, A[0], A[A.length - 1])
                } else {
                    this.alignCascadingSegments(B, z)
                }
            },
            arrangeCascadingSegments: function(A, u, v) {
                A.cascadeStartHorizontal = Math.abs(u.x - v.x) > Math.abs(u.y - v.y);
                var B = A.points = [u, u, v, v];
                var z = B.length;
                var E = v.x - u.x;
                var C = v.y - u.y;
                var t, D;
                for (var w = 1; w < z - 1; ++w) {
                    if (A.cascadeStartHorizontal) {
                        if (w % 2 != 0) {
                            t = E / (z / 2);
                            D = 0
                        } else {
                            t = 0;
                            D = C / ((z - 1) / 2)
                        }
                    } else {
                        if (w % 2 != 0) {
                            t = 0;
                            D = C / (z / 2)
                        } else {
                            t = E / ((z - 1) / 2);
                            D = 0
                        }
                    }
                    B[w] = new o(B[w - 1].x + t, B[w - 1].y + D)
                }
                w--;
                if ((A.cascadeStartHorizontal && (w % 2 != 0)) || (!A.cascadeStartHorizontal && !(w % 2 != 0))) {
                    B[z - 2] = new o(B[z - 1].x, B[z - 2].y)
                } else {
                    B[z - 2] = new o(B[z - 2].x, B[z - 1].y)
                }
            },
            alignCascadingSegments: function(w, v) {
                var u = w.points;
                var z = v - 1;
                var t = v + 1;
                if ((w.cascadeStartHorizontal && v % 2 != 0) || (!w.cascadeStartHorizontal && !(v % 2 != 0))) {
                    if (z == 0) {
                        u[v] = new o(u[v].x, u[z].y)
                    }
                    if (t == u.length - 1) {
                        u[v] = new o(u[t].x, u[v].y)
                    }
                    if (z >= 0 && z < u.length) {
                        u[z] = new o(u[z].x, u[v].y)
                    }
                    if (t >= 0 && t < u.length) {
                        u[t] = new o(u[v].x, u[t].y)
                    }
                } else {
                    if (z == 0) {
                        u[v] = new o(u[z].x, u[v].y)
                    }
                    if (t == u.length - 1) {
                        u[v] = new o(u[v].x, u[t].y)
                    }
                    if (z >= 0 && z < u.length) {
                        u[z] = new o(u[v].x, u[z].y)
                    }
                    if (t >= 0 && t < u.length) {
                        u[t] = new o(u[t].x, u[v].y)
                    }
                }
            },
            updateFromEndPoints: function(u, t) {
                this.alignFirstCascadingSegment(u);
                this.alignLastCascadingSegment(u);
                u.updateFromPoints(t)
            },
            alignFirstCascadingSegment: function(w) {
                var u = w.points;
                var v = u[1].x;
                var t = u[1].y;
                if (w.cascadeStartHorizontal) {
                    t = u[0].y
                } else {
                    v = u[0].x
                }
                u[1] = new o(v, t)
            },
            alignLastCascadingSegment: function(v) {
                var t = v.points;
                var z = t.length;
                var w = t[z - 2].x;
                var u = t[z - 2].y;
                if (z % 2 != 0) {
                    if (v.cascadeStartHorizontal) {
                        w = t[z - 1].x
                    } else {
                        u = t[z - 1].y
                    }
                } else {
                    if (v.cascadeStartHorizontal) {
                        u = t[z - 1].y
                    } else {
                        w = t[z - 1].x
                    }
                }
                t[z - 2] = new o(w, u)
            },
            updateFromRoute: function(u) {
                var t = u.points;
                u.cascadeStartHorizontal = t[0].y == t[1].y
            },
            pointsValid: function(t) {
                if (t.points.length < 3) {
                    return false
                }
                return true
            },
            resetSelfLoopPoints: function(A, z) {
                var v = A.points;
                if (z && v.length % 2 == 0) {
                    A.setSegmentCount(3)
                }
                var B = A.origin.bounds;
                var t = B.width;
                v[0] = A.origin.getTopIntr(1 / 3);
                v[v.length - 1] = A.origin.getTopIntr(2 / 3);
                for (var u = 0; u < v.length / 2 - 1; ++u) {
                    v[1 + u] = new o(v[0].x, v[0].y - t / 3);
                    v[v.length - 2 - u] = new o(v[v.length - 1].x, v[0].y - t / 3)
                }
                if (v.length % 2 == 1) {
                    v[v.length / 2] = new o(v[v.length - 1].x, v[0].y - t / 3)
                }
                A.cascadeStartHorizontal = false;
                A.updateFromPoints()
            }
        };
        var h = {
            initialize: function(u, v, t) {
                u.points = [v, t]
            },
            createElements: function(v, u) {
                var z = v.getEffectiveStroke();
                var t = v.getEffectiveStrokeThickness();
                var w = v.getEffectiveStrokeDashStyle();
                var A = new MindFusion.Drawing.CardinalSpline(v.points);
                A.pen = z;
                A.strokeThickness = t;
                A.strokeDashStyle = w;
                A.shadow = v.createShadow();
                u.push(A)
            },
            getCurvePoints: function(M) {
                var z = 0.5;
                var D = 16;
                var u = [],
                    N = [],
                    B, A, w, H, v, F, J, I, G, E, K, C, L;
                u = M.slice(0);
                u.unshift(M[1]);
                u.unshift(M[0]);
                u.push(M[M.length - 2]);
                u.push(M[M.length - 1]);
                for (L = 2; L < (u.length - 4); L += 2) {
                    for (C = 0; C <= D; C++) {
                        w = (u[L + 2] - u[L - 2]) * z;
                        H = (u[L + 4] - u[L]) * z;
                        v = (u[L + 3] - u[L - 1]) * z;
                        F = (u[L + 5] - u[L + 1]) * z;
                        K = C / D;
                        J = 2 * Math.pow(K, 3) - 3 * Math.pow(K, 2) + 1;
                        I = -(2 * Math.pow(K, 3)) + 3 * Math.pow(K, 2);
                        G = Math.pow(K, 3) - 2 * Math.pow(K, 2) + K;
                        E = Math.pow(K, 3) - Math.pow(K, 2);
                        B = J * u[L] + I * u[L + 2] + G * w + E * H;
                        A = J * u[L + 1] + I * u[L + 3] + G * v + E * F;
                        N.push(B);
                        N.push(A)
                    }
                }
                return N
            },
            containsPoint: function(v, t, u) {
                return c.Utils.distToPolyline(t, v.points, v.points.length) < u
            },
            updateRelatedPoints: function(v, t, u) {},
            updateFromEndPoints: function(u, t) {
                u.updateFromPoints(t)
            },
            updateFromRoute: function(t) {},
            pointsValid: function(t) {
                return true
            },
            resetSelfLoopPoints: function(u, t) {
                j.resetSelfLoopPoints(u, t)
            }
        };
        var d = function(t) {
            this.link = t
        };
        d.prototype = {
            draw: function(t, u) {
                var v = this.link;
                var z = v.getParent();
                var C = v.getEffectiveStroke();
                var w = v.getEffectiveStrokeThickness();
                var D = v.getEffectiveStrokeDashStyle();
                var B = v.points;
                if (B.length < 2) {
                    return
                }
                var A = v.createShadow();
                if (A && u != false) {
                    t.save();
                    A.apply(t)
                }
                t.strokeStyle = C;
                t.lineWidth = (w ? w : 1) / t._mf_scale;
                g.apply(t, D);
                this.drawLink(t);
                if (A && u != false) {
                    t.restore()
                }
            },
            drawShadow: function(u) {
                var v = this.link;
                var t = v.getEffectiveStrokeThickness();
                var w = v.getEffectiveStrokeDashStyle();
                var z = v.createShadow();
                if (z) {
                    u.save();
                    z.apply(u);
                    u.strokeStyle = z.color;
                    u.lineWidth = (t ? t : 1) / u._mf_scale;
                    g.apply(u, w);
                    this.drawLink(u);
                    u.restore()
                }
            },
            drawLink: function(u) {
                var z = this.link;
                var w = z.getParent();
                var v = z.points;
                if (v.length < 2) {
                    return
                }
                var t = w ? w.getLinkCrossings() : c.LinkCrossings.Straight;
                if (t == c.LinkCrossings.Straight) {
                    if (z.parent.getRoundedLinks()) {
                        this.drawRoundedPolyline(u, v, w.getRoundedLinksRadius(), true)
                    } else {
                        this.drawLines(u, v)
                    }
                } else {
                    this.drawWithCrossings(u, z, v, w.getRoundedLinksRadius())
                }
            },
            drawLines: function(v, w) {
                v.beginPath();
                v.moveTo(w[0].x, w[0].y);
                for (var u = 1, t = w.length; u < t; u++) {
                    var z = w[u];
                    v.lineTo(z.x, z.y)
                }
                v.stroke()
            },
            drawRoundedPolyline: function(u, T, w, H) {
                var B = MindFusion.Geometry;
                if (w < 0.00001) {
                    this.drawLines(u, T);
                    return T[T.length - 1]
                }
                if (T.length <= 2) {
                    this.drawLines(u, T);
                    return T[T.length - 1]
                }
                var M = T[0];
                if (H) {
                    u.beginPath();
                    u.moveTo(M.x, M.y)
                }
                var Z, F, D, O;
                for (var U = 0; U < T.length - 2; U++) {
                    Z = T[U + 1];
                    F = T[U];
                    D = T[U + 1];
                    O = T[U + 2];
                    var X = false;
                    while (Math.abs(D.x - O.x) + Math.abs(D.y - O.y) < 0.00001) {
                        U++;
                        if (U >= T.length - 2) {
                            X = true;
                            break
                        }
                        O = T[U + 2]
                    }
                    if (X) {
                        continue
                    }
                    var S = B.cartesianToPolarDegrees(Z, F);
                    var ad = S.a;
                    var V = S.r;
                    var P = B.cartesianToPolarDegrees(Z, O);
                    var ac = P.a;
                    var R = P.r;
                    while (ad < 0) {
                        ad += 360
                    }
                    while (ac < 0) {
                        ac += 360
                    }
                    if (ac < ad) {
                        ac += 360
                    }
                    var ab = ac - ad;
                    if (ab == 0 || ab == 180) {
                        continue
                    }
                    var L = false;
                    if (ab > 180) {
                        var Y = ad;
                        ad = ac;
                        ac = Y;
                        Y = V;
                        V = R;
                        R = Y;
                        ab = ac - ad;
                        while (ab < 0) {
                            ab += 360
                        }
                        L = true
                    }
                    var E = w;
                    var N = Math.sin(B.degreeToRadian(ab / 2));
                    var A = Math.sin(B.degreeToRadian(90 - ab / 2));
                    var C = A * E / N;
                    var W = Math.min(V, R);
                    if (C > Math.min(W / 3, 10)) {
                        C = Math.min(W / 3, 10);
                        E = N * C / A
                    }
                    var v = B.polarToCartesianDegrees(Z, {
                        a: ad,
                        r: C
                    });
                    var t = B.polarToCartesianDegrees(Z, {
                        a: ac,
                        r: C
                    });
                    var Q = Math.sqrt(Math.pow(C, 2) + Math.pow(E, 2));
                    var aa = B.polarToCartesianDegrees(Z, {
                        a: ad + ab / 2,
                        r: Q
                    });
                    var K = B.cartesianToPolarDegrees(aa, v);
                    iKa = K.a;
                    iKr = K.r;
                    var J = B.cartesianToPolarDegrees(aa, t);
                    iLa = J.a;
                    iLr = J.r;
                    while (Math.abs(iLa - iKa) > 180) {
                        if (iLa < iKa) {
                            iLa += 360
                        } else {
                            iKa += 360
                        }
                    }
                    if (iLa < iKa) {
                        var Y = iLa;
                        iLa = iKa;
                        iKa = Y
                    }
                    if (L) {
                        var Y = v;
                        v = t;
                        t = Y
                    }
                    u.lineTo(v.x, v.y);
                    if (E > 0) {
                        var z = 360 - iKa;
                        var I = -(iLa - iKa);
                        if (!L) {
                            z = z + I;
                            I = -I
                        }
                        u.arc(aa.x, aa.y, E, B.degreeToRadian(z), B.degreeToRadian(z + I), I < 0)
                    }
                    M = t
                }
                if (H) {
                    var G = T[T.length - 1];
                    u.lineTo(G.x, G.y);
                    u.stroke()
                }
                return M
            },
            drawWithCrossings: function(w, D, V, z) {
                var O = D.getCrossings();
                if (!O || O.length == 0) {
                    this.drawLines(w, V);
                    return
                }
                var C = MindFusion.Geometry;
                w.beginPath();
                w.moveTo(V[0].x, V[0].y);
                var P = null;
                var G = D.getSegmentCount();
                var K = D.getParent();
                var L = false;
                for (var W = 0; W < G; ++W) {
                    var t = O[W];
                    if (t.length > 0) {
                        for (var U = 0; U < t.length - 1; ++U) {
                            var T = t[U].radius;
                            var I = t[U].location;
                            var F = t[U + 1].location;
                            if (P) {
                                I = P
                            }
                            if (L) {
                                w.moveTo(I.x, I.y);
                                L = false
                            }
                            P = null;
                            if (U % 2 == 0) {
                                if (K.getRoundedLinks()) {
                                    if (U == t.length - 2 && W != G - 1) {
                                        var A = W + 2;
                                        var R = V[A];
                                        while (Math.abs(R.x - F.x) + Math.abs(R.y - F.y) < 0.00001) {
                                            A++;
                                            if (A == V.length) {
                                                break
                                            }
                                            R = V[A]
                                        }
                                        if (A == V.length) {
                                            w.lineTo(F.x, F.y)
                                        } else {
                                            var ac = O[A - 1];
                                            if (ac.length > 2) {
                                                R = ac[1].location
                                            }
                                            var Q = [I, F, R];
                                            P = this.drawRoundedPolyline(w, Q, z, false)
                                        }
                                    } else {
                                        w.lineTo(F.x, F.y)
                                    }
                                } else {
                                    w.lineTo(F.x, F.y)
                                }
                            } else {
                                if (K.getLinkCrossings() == c.LinkCrossings.Arcs) {
                                    var aa = I.distance(F) / 2;
                                    var ab = C.cartesianToPolarDegrees(I, F);
                                    var Z = ab.a;
                                    var E = ab.r;
                                    var Y = [C.polarToCartesianDegrees(I, {
                                        a: Z,
                                        r: T
                                    }), C.polarToCartesianDegrees(I, {
                                        a: Z,
                                        r: 2 * aa - T
                                    })];
                                    var S = [I, C.polarToCartesianDegrees(I, {
                                        a: Z,
                                        r: 2 * aa - 2 * T
                                    })];
                                    var H = [C.polarToCartesianDegrees(I, {
                                        a: Z,
                                        r: 2 * T
                                    }), F];
                                    var X = Z;
                                    if (X < 90) {
                                        X += 180
                                    }
                                    var N = 0 * 90;
                                    if (Z < 90) {
                                        N = 90 - N
                                    }
                                    var B = 180 - X - N;
                                    var M = -90;
                                    if (Z < 90) {
                                        B += M;
                                        M = -M
                                    }
                                    w.arc(Y[0].x, Y[0].y, T, C.degreeToRadian(B), C.degreeToRadian(B + M), M < 0);
                                    var v = C.polarToCartesianDegrees(Y[0], {
                                        a: X - 90,
                                        r: T
                                    });
                                    var u = C.polarToCartesianDegrees(Y[1], {
                                        a: X - 90,
                                        r: T
                                    });
                                    w.lineTo(u.x, u.y);
                                    N = 1 * 90;
                                    if (Z < 90) {
                                        N = 90 - N
                                    }
                                    B = 180 - X - N;
                                    M = -90;
                                    if (Z < 90) {
                                        B += M;
                                        M = -M
                                    }
                                    w.arc(Y[1].x, Y[1].y, T, C.degreeToRadian(B), C.degreeToRadian(B + M), M < 0)
                                } else {
                                    L = true
                                }
                            }
                        }
                    } else {
                        w.lineTo(V[W + 1].x, V[W + 1].y)
                    }
                }
                var J = V[V.length - 1];
                w.lineTo(J.x, J.y);
                w.stroke()
            }
        };
        r.With = function(t) {
            if (!c.DiagramLinkBuilder) {
                c.DiagramLinkBuilder = new MindFusion.Builder(r.prototype, t)
            } else {
                c.DiagramLinkBuilder.setInstance(null)
            }
            return c.DiagramLinkBuilder
        };
        c.DiagramLinkBuilder = null;
        var n = [j, a, f, h];
        var s = function(t) {
            return function(v, u) {
                var B = v.location;
                var z = u.location;
                if (B.equals(z)) {
                    return 0
                }
                var w = (t.x - B.x) * (t.x - B.x);
                w += (t.y - B.y) * (t.y - B.y);
                var A = (t.x - z.x) * (t.x - z.x);
                A += (t.y - z.y) * (t.y - z.y);
                if (w == A) {
                    return 0
                }
                return (w < A) ? -1 : 1
            }
        };
        MindFusion.registerClass(r, "MindFusion.Diagramming.DiagramLink", c.DiagramItem)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.DoNothingBehavior = function(c) {
            mflayer.initializeBase(a, this, [c])
        };
        a.prototype = {
            setMouseCursor: function(c, d) {
                this.currentCursor = MindFusion.Controls.MouseCursors.Default;
                return this.currentCursor
            },
            createController: function(c) {
                return null
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.DoNothingBehavior", b.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Controls.MouseCursors;
        var b = a.DrawLinksBehavior = function(d) {
            mflayer.initializeBase(b, this, [d])
        };
        b.prototype = {
            setMouseCursor: function(d, e) {
                var f = this.diagram.selection.handleAtPoint(d);
                if (f) {
                    return this.setCurrentCursor(c.Move)
                }
                var h = this.diagram.getHandleAt(d);
                if (h) {
                    return this.setModfCursor(d, h)
                }
                var g = this.diagram.getNodeAt(d, true, true);
                if (g != null && g.acceptLinks(true)) {
                    return this.setCurrentCursor(c.Pointer)
                }
                return this.setCurrentCursor(c.Default)
            },
            createController: function(j) {
                var e = mflayer.callBaseMethod(b, this, "createController", [j]);
                if (e) {
                    return e
                }
                var f = this.diagram;
                var d = f.getNodeAt(j.pointerPosition, true, true);
                if (d != null && d.acceptLinks(true) || d == null && f.allowUnconnectedLinks) {
                    var g = this.createLink(d, j.pointerPosition);
                    var h = {
                        item: g,
                        index: g.points.length - 1
                    };
                    return new a.CreateLinkController(f, g)
                }
                return new a.CreateSelectionController(f.selection)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.DrawLinksBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Controls.MouseCursors;
        var b = a.DrawNodesBehavior = function(e, d) {
            mflayer.initializeBase(b, this, [e]);
            this.nodeConstructor = d
        };
        b.prototype = {
            setMouseCursor: function(d, e) {
                var f = this.diagram.selection.handleAtPoint(d);
                if (f) {
                    return this.setCurrentCursor(c.Move)
                }
                var g = this.diagram.getHandleAt(d);
                if (g) {
                    return this.setModfCursor(d, g)
                }
                return this.setCurrentCursor(c.Default)
            },
            createNode: function() {
                return this.nodeConstructor(this.diagram)
            },
            createController: function(l) {
                var e = mflayer.callBaseMethod(b, this, "createController", [l]);
                if (e) {
                    return e
                }
                var g = this.diagram;
                var d = g.getAlignToGrid() ? g.getGridSizeX() : 1;
                var j = g.getAlignToGrid() ? g.getGridSizeY() : 1;
                var k = this.createNode();
                var f = g.alignResize(k, l.pointerPosition, a.AdjustmentHandles.ResizeTopLeft);
                k.setBounds(new MindFusion.Drawing.Rect(f.x, f.y, d, j));
                e = new a.CreateNodeController(g, k);
                e.convertToShape = this.convertToShape;
                return e
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.DrawNodesBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.DummyNode = function(c) {
            mflayer.initializeBase(b, this, [c])
        };
        b.prototype = {
            considerBounds: function() {
                return false
            },
            getIntersection: function(c, d) {
                return c
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.DummyNode", a.DiagramNode)
    })(MindFusion.Diagramming);
    (function(a) {
        var j = a.ItemEventArgs = function(p) {
            mflayer.initializeBase(j, this);
            if (p.sender) {
                this.sender = p.sender
            }
            if (p.bounds) {
                this.bounds = p.bounds
            }
            if (p.mousePosition) {
                this.mousePosition = p.mousePosition
            }
            if (p.mouseButton !== undefined) {
                this.mouseButton = p.mouseButton
            }
            if (p.adjustmentHandle !== undefined) {
                this.adjustmentHandle = p.adjustmentHandle
            }
            if (p.newText !== undefined) {
                this.newText = p.newText
            }
            if (p.oldText !== undefined) {
                this.oldText = p.oldText
            }
            if (p.context !== undefined) {
                this.context = p.context
            }
            if (p.item !== undefined) {
                this.item = p.item
            }
        };
        j.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getMouseButton: function() {
                return this.mouseButton
            },
            getAdjustmentHandle: function() {
                return this.adjustmentHandle
            },
            setAdjustmentHandle: function(p) {
                this.adjustmentHandle = p
            },
            getNewText: function() {
                return this.newText
            },
            getOldText: function() {
                return this.oldText
            },
            getContext: function() {
                return this.context
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(p) {
                this.handled = p
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(p) {
                this.cancel = p
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            },
            getItem: function() {
                return this.item
            }
        };
        MindFusion.registerClass(j, "MindFusion.Diagramming.ItemEventArgs", MindFusion.CancelEventArgs);
        var g = a.NodeEventArgs = function(p) {
            mflayer.initializeBase(g, this, [p]);
            if (p.node) {
                this.node = p.node
            }
            if (p.container !== undefined) {
                this.container = p.container
            }
            if (p.hyperlink) {
                this.hyperlink = p.hyperlink
            }
        };
        g.prototype = {
            getNode: function() {
                return this.node
            },
            getContainer: function() {
                return this.container
            },
            getHyperlink: function() {
                return this.hyperlink
            }
        };
        MindFusion.registerClass(g, "MindFusion.Diagramming.NodeEventArgs", j);
        var o = a.LinkEventArgs = function(p) {
            mflayer.initializeBase(o, this, [p]);
            if (p.link) {
                this.link = p.link
            }
            if (p.label) {
                this.label = p.label
            }
        };
        o.prototype = {
            getLink: function() {
                return this.link
            },
            getLabel: function() {
                return this.label
            }
        };
        MindFusion.registerClass(o, "MindFusion.Diagramming.LinkEventArgs", j);
        var b = a.ComponentEventArgs = function(p) {
            mflayer.initializeBase(b, this, [p]);
            if (p.component) {
                this.component = p.component
            }
        };
        b.prototype = {
            getComponent: function() {
                return this.component
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ComponentEventArgs", g);
        var l = a.SelectionEventArgs = function(p) {
            mflayer.initializeBase(l, this);
            if (p.sender) {
                this.sender = p.sender
            }
            if (p.mousePosition) {
                this.mousePosition = p.mousePosition
            }
            if (p.adjustmentHandle !== undefined) {
                this.adjustmentHandle = p.adjustmentHandle
            }
        };
        l.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getAdjustmentHandle: function() {
                return this.adjustmentHandle
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(p) {
                this.cancel = p
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            }
        };
        MindFusion.registerClass(l, "MindFusion.Diagramming.SelectionEventArgs", MindFusion.CancelEventArgs);
        var d = a.DiagramEventArgs = function(p) {
            mflayer.initializeBase(d, this);
            if (p.sender) {
                this.sender = p.sender
            }
            if (p.mousePosition) {
                this.mousePosition = p.mousePosition
            }
            if (p.mouseButton !== undefined) {
                this.mouseButton = p.mouseButton
            }
        };
        d.prototype = {
            getMousePosition: function() {
                return this.mousePosition
            },
            getMouseButton: function() {
                return this.mouseButton
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.DiagramEventArgs", MindFusion.EventArgs);
        var n = a.InplaceEditEventArgs = function(p) {
            mflayer.initializeBase(n, this);
            if (p.item) {
                this.item = p.item
            }
            if (p.control) {
                this.control = p.control
            }
            if (p.bounds) {
                this.bounds = p.bounds
            }
        };
        n.prototype = {
            getItem: function() {
                return this.item
            },
            getControl: function() {
                return this.control
            },
            setControl: function(p) {
                this.control = p
            },
            getBounds: function() {
                return this.bounds
            }
        };
        MindFusion.registerClass(n, "MindFusion.Diagramming.InplaceEditEventArgs", MindFusion.EventArgs);
        var e = a.CellEventArgs = function(p) {
            mflayer.initializeBase(e, this);
            if (p.sender) {
                this.sender = p.sender
            }
            if (p.node) {
                this.node = p.node
            }
            if (p.cell) {
                this.cell = p.cell
            }
            if (p.column !== undefined) {
                this.column = p.column
            }
            if (p.row !== undefined) {
                this.row = p.row
            }
            if (p.newText !== undefined) {
                this.newText = p.newText
            }
            if (p.oldText !== undefined) {
                this.oldText = p.oldText
            }
            if (p.context !== undefined) {
                this.context = p.context
            }
            if (p.mouseButton !== undefined) {
                this.mouseButton = p.mouseButton
            }
            if (p.mousePosition !== undefined) {
                this.mousePosition = p.mousePosition
            }
        };
        e.prototype = {
            getCell: function() {
                return this.cell
            },
            getMouseButton: function() {
                return this.mouseButton
            },
            getNewText: function() {
                return this.newText
            },
            getOldText: function() {
                return this.oldText
            },
            getContext: function() {
                return this.context
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(p) {
                this.handled = p
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(p) {
                this.cancel = p
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.CellEventArgs", MindFusion.CancelEventArgs);
        var h = a.CellValidationEventArgs = function(p) {
            mflayer.initializeBase(h, this, [p]);
            this.cancelDrag = false
        };
        h.prototype = {
            cancelDrag: function() {
                this.cancelDrag = true
            },
            shouldCancelDrag: function() {
                return this.cancelDrag
            }
        };
        MindFusion.registerClass(h, "MindFusion.Diagramming.CellValidationEventArgs", MindFusion.Diagramming.CellEventArgs);
        var f = a.SerializeTagEventArgs = function(p) {
            mflayer.initializeBase(f, this);
            if (p.item !== undefined) {
                this.item = p.item
            }
            if (p.tag !== undefined) {
                this.tag = p.tag
            }
            if (p.element !== undefined) {
                this.element = p.element
            }
            if (p.context !== undefined) {
                this.context = p.context
            }
            if (p.propertyName !== undefined) {
                this.propertyName = p.propertyName
            }
            this.handled = false
        };
        f.prototype = {
            getObject: function() {
                return this.item
            },
            getTag: function() {
                return this.tag
            },
            setTag: function(p) {
                this.tag = p
            },
            getElement: function() {
                return this.element
            },
            getContext: function() {
                return this.context
            },
            getPropertyName: function() {
                return this.propertyName
            },
            getHandled: function() {
                return this.handled
            },
            setHandled: function(p) {
                this.handled = p
            }
        };
        MindFusion.registerClass(f, "MindFusion.Diagramming.SerializeTagEventArgs", MindFusion.EventArgs);
        var k = a.HeaderEventArgs = function(p) {
            mflayer.initializeBase(k, this);
            this.header = p
        };
        k.prototype = {
            getHeader: function() {
                return this.header
            }
        };
        MindFusion.registerClass(k, "MindFusion.Diagramming.HeaderEventArgs", MindFusion.EventArgs);
        var c = a.HeaderResizeEventArgs = function(q, p) {
            mflayer.initializeBase(c, this, [q]);
            this.horizontal = p
        };
        c.prototype = {
            getHorizontal: function() {
                return this.horizontal
            },
            getCancel: function() {
                return this.cancel
            },
            setCancel: function(p) {
                this.cancel = p
            },
            cancelDrag: function() {
                this.shouldCancel = true
            },
            shouldCancelDrag: function() {
                return this.shouldCancel
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.HeaderResizeEventArgs", MindFusion.Diagramming.HeaderEventArgs)
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Events = {
        initializeLink: "initializeLink",
        initializeNode: "initializeNode",
        linkClicked: "linkClicked",
        linkCreated: "linkCreated",
        linkDeleted: "linkDeleted",
        linkDoubleClicked: "linkDoubleClicked",
        linkModified: "linkModified",
        linkPointed: "linkPointed",
        linkTextEdited: "linkTextEdited",
        nodeClicked: "nodeClicked",
        nodeCreated: "nodeCreated",
        nodeDeleted: "nodeDeleted",
        nodeDoubleClicked: "nodeDoubleClicked",
        nodeModified: "nodeModified",
        nodePointed: "nodePointed",
        nodeTextEdited: "nodeTextEdited",
        linkCreating: "linkCreating",
        linkDeleting: "linkDeleting",
        linkModifying: "linkModifying",
        nodeCreating: "nodeCreating",
        nodeDeleting: "nodeDeleting",
        nodeModifying: "nodeModifying",
        containerChildAdded: "containerChildAdded",
        containerChildAdding: "containerChildAdding",
        containerChildRemoving: "containerChildRemoving",
        containerChildRemoved: "containerChildRemoved",
        containerFolded: "containerFolded",
        containerUnfolded: "containerUnfolded",
        treeExpanded: "treeExpanded",
        treeCollapsed: "treeCollapsed",
        selectionModifying: "selectionModifying",
        repaint: "repaint",
        sizeChanged: "sizeChanged",
        nodeSelected: "nodeSelected",
        nodeDeselected: "nodeDeselected",
        linkSelected: "linkSelected",
        linkDeselected: "linkDeselected",
        controlLoaded: "controlLoaded",
        hitTestAdjustmentHandles: "hitTestAdjustmentHandles",
        drawAdjustmentHandles: "drawAdjustmentHandles",
        clicked: "clicked",
        enterInplaceEditMode: "enterInplaceEditMode",
        leaveInplaceEditMode: "leaveInplaceEditMode",
        createEditControl: "createEditControl",
        cellTextEdited: "cellTextEdited",
        laneGridCellTextEdited: "laneGridCellTextEdited",
        serializeTag: "serializeTag",
        deserializeTag: "deserializeTag",
        tableColumnResizing: "tableColumnResizing",
        tableColumnResized: "tableColumnResized",
        tableRowResizing: "tableRowResizing",
        tableRowResized: "tableRowResized",
        nodePasted: "nodePasted",
        linkPasted: "linkPasted",
        headerStartResizing: "headerStartResizing",
        headerResized: "headerResized",
        itemAdded: "itemAdded",
        itemRemoved: "itemRemoved",
        animatedLayoutCompleted: "animatedLayoutCompleted",
        hyperlinkClicked: "hyperlinkClicked"
    };
    (function(a) {
        var d = MindFusion.Drawing.GraphicsUnit;
        var b = MindFusion.Drawing.Rect;
        var c = a.ExpandButton = function(e) {
            mflayer.initializeBase(c, this, [e]);
            this.updateContent();
            this.updateLocation()
        };
        c.prototype = {
            updateLocation: function() {
                var e = this.getRect();
                this.x = e.x;
                this.y = e.y
            },
            onClick: function(f) {
                if (!this.hitTest(f)) {
                    return
                }
                if (this.node.parent != null) {
                    this.node.parent.startTotalChange()
                }
                var e = this.node;
                if (e.expanded) {
                    e.collapse();
                    e.parent.raiseTreeCollapsed(e)
                } else {
                    e.expand();
                    e.parent.raiseTreeExpanded(e)
                }
                if (this.node.parent != null) {
                    this.node.parent.commitCompositeOperation()
                }
            },
            hitTest: function(e) {
                return this.getRect().containsPoint(e)
            },
            getRect: function() {
                var f = this.node;
                var e = f.getRotatedBounds();
                var g = d.getMillimeter(f.parent.measureUnit);
                var h = e.center();
                return b.fromLTRB(e.right() + g, h.y - 2 * g, e.right() + 5 * g, h.y + 2 * g)
            },
            getRotatedRect: function() {
                var f = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var j = [];
                    j.push(f.topLeft());
                    j.push(f.topRight());
                    j.push(f.bottomRight());
                    j.push(f.bottomLeft());
                    a.Utils.rotatePointsAt(j, a.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var e = Math.min(j[0].x, Math.min(j[1].x, Math.min(j[2].x, j[3].x)));
                    var k = Math.min(j[0].y, Math.min(j[1].y, Math.min(j[2].y, j[3].y)));
                    var h = Math.max(j[0].x, Math.max(j[1].x, Math.max(j[2].x, j[3].x)));
                    var g = Math.max(j[0].y, Math.max(j[1].y, Math.max(j[2].y, j[3].y)));
                    return b.fromLTRB(e, k, h, g)
                }
                return f
            },
            drawMinus: function(f, g) {
                f.brush = "white";
                this.content = [f];
                var h = f.y + f.height / 2;
                var e = new MindFusion.Drawing.Line(f.x + g, h, f.right() - g, h);
                this.content.push(e)
            },
            drawPlus: function(g, h) {
                this.drawMinus(g, h);
                var e = g.x + g.width / 2;
                var f = new MindFusion.Drawing.Line(e, g.y + h, e, g.bottom() - h);
                this.content.push(f)
            },
            updateContent: function() {
                var f = d.getMillimeter(this.node.parent.measureUnit);
                var e = this.getRect();
                e.x = e.y = 0;
                if (this.node.expanded) {
                    this.drawMinus(e, f)
                } else {
                    this.drawPlus(e, f)
                }
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.ExpandButton", a.Manipulator)
    })(MindFusion.Diagramming);
    (function(b) {
        var c = MindFusion.Drawing.Rect;
        var a = b.Factory = function(d) {
            this.diagram = d
        };
        a.prototype.createShapeNode = function() {
            var d = new b.ShapeNode(this.diagram);
            if (arguments.length == 1) {
                d.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    d.setBounds(c.fromArgs(arguments))
                }
            }
            this.diagram.addItem(d);
            return d
        };
        a.prototype.createTableNode = function() {
            var d = new b.TableNode(this.diagram);
            if (arguments.length == 1) {
                d.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    d.setBounds(c.fromArgs(arguments))
                }
            }
            this.diagram.addItem(d);
            return d
        };
        a.prototype.createContainerNode = function() {
            var d = new b.ContainerNode(this.diagram);
            if (arguments.length == 1) {
                d.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    d.setBounds(c.fromArgs(arguments))
                }
            }
            this.diagram.addItem(d);
            return d
        };
        a.prototype.createSvgNode = function() {
            var d = new b.SvgNode(this.diagram);
            if (arguments.length == 1) {
                d.setBounds(arguments[0])
            } else {
                if (arguments.length == 4) {
                    d.setBounds(c.fromArgs(arguments))
                }
            }
            this.diagram.addItem(d);
            return d
        };
        a.prototype.createDiagramLink = function(e, d) {
            var f = new b.DiagramLink(this.diagram, e, d);
            this.diagram.addItem(f);
            return f
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Factory")
    })(MindFusion.Diagramming);
    (function(a) {
        var f = MindFusion.Drawing.GraphicsUnit;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Ellipse;
        var e = MindFusion.Drawing.Line;
        var b = a.Folder = function(g) {
            mflayer.initializeBase(b, this, [g]);
            this.updateContent();
            this.updateLocation()
        };
        b.prototype = {
            updateLocation: function() {
                var g = this.getRect();
                this.x = g.x;
                this.y = g.y
            },
            onClick: function(h) {
                if (!this.hitTest(h)) {
                    return
                }
                var g = this.node;
                if (g.parent.getUndoEnabled()) {
                    g.parent.undoManager.startComposite();
                    g.parent.undoManager.executeCommand(new a.FoldContainerCommand(this, g));
                    g.parent.undoManager.endComposite()
                } else {
                    g.setFolded(!g.getFolded())
                }
                if (g.getFolded()) {
                    g.raiseFolded(g)
                } else {
                    g.raiseUnfolded(g)
                }
            },
            hitTest: function(g) {
                return this.getRotatedRect().containsPoint(g) && a.Utils.pointInPolygon(g, this.getOutline())
            },
            getRect: function() {
                var j = this.node;
                var l = f.getMillimeter(j.parent.measureUnit);
                var g = j.getCaptionHeight();
                if (j.getFoldIconSize() != null) {
                    g = j.getFoldIconSize()
                }
                var k = l;
                if (k > g / 4) {
                    k = g / 4
                }
                var h = j.bounds.clone();
                h.height = g;
                h.x = h.right() - g;
                h.width = g;
                h = h.inflate(-k, -k);
                return h
            },
            getRotatedRect: function() {
                var h = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var l = [];
                    l.push(h.topLeft());
                    l.push(h.topRight());
                    l.push(h.bottomRight());
                    l.push(h.bottomLeft());
                    a.Utils.rotatePointsAt(l, a.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var g = Math.min(l[0].x, Math.min(l[1].x, Math.min(l[2].x, l[3].x)));
                    var n = Math.min(l[0].y, Math.min(l[1].y, Math.min(l[2].y, l[3].y)));
                    var k = Math.max(l[0].x, Math.max(l[1].x, Math.max(l[2].x, l[3].x)));
                    var j = Math.max(l[0].y, Math.max(l[1].y, Math.max(l[2].y, l[3].y)));
                    return c.fromLTRB(g, n, k, j)
                }
                return h
            },
            getOutline: function() {
                var g = this.getRect();
                var h = [];
                h.push(g.topLeft());
                h.push(g.topRight());
                h.push(g.bottomRight());
                h.push(g.bottomLeft());
                a.Utils.rotatePointsAt(h, a.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                return h
            },
            updateContent: function() {
                var k = this.node;
                var l = f.getMillimeter(k.parent.measureUnit);
                var g = 3 * l / 4;
                var z = this.getRect();
                z.x = z.y = 0;
                var h = new d(z);
                h.pen = "lightgray";
                h.brush = "white";
                this.content = [h];
                var j = z.width / 5;
                var n = z.x + z.width / 2;
                var A = z.y + z.height / 2 - j / 2;
                var s = l / 2;
                var v = j - s;
                var w = A + s;
                var u = z.y + z.height / 2 + j / 2;
                var r = u - s;
                if (!k.folded) {
                    var t = new e(n, A, n - j, A + j);
                    t.pen = "lightgray";
                    this.content.push(t);
                    var q = new e(n, A, n + j, A + j);
                    q.pen = "lightgray";
                    this.content.push(q);
                    if (v > 0) {
                        var p = new e(n, w, n - v, w + v);
                        p.pen = "lightgray";
                        this.content.push(p);
                        var o = new e(n, w, n + v, w + v);
                        o.pen = "lightgray";
                        this.content.push(o)
                    }
                } else {
                    var t = new e(n, u, n - j, u - j);
                    t.pen = "lightgray";
                    this.content.push(t);
                    var q = new e(n, u, n + j, u - j);
                    q.pen = "lightgray";
                    this.content.push(q);
                    if (v > 0) {
                        var p = new e(n, r, n - v, r - v);
                        p.pen = "lightgray";
                        this.content.push(p);
                        var o = new e(n, r, n + v, r - v);
                        o.pen = "lightgray";
                        this.content.push(o)
                    }
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.Folder", a.Manipulator)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = MindFusion.Drawing.GraphicsUnit;
        var h = MindFusion.Drawing.Point;
        var d = MindFusion.Drawing.Rect;
        var c = MindFusion.Drawing.Matrix;
        var j = MindFusion.Diagramming.EffectPhase;
        var l = b.FreeFormNode = function(n) {
            mflayer.initializeBase(l, this, [n]);
            this.points = [];
            this.path = new MindFusion.Drawing.Path();
            this.shapeRenderer = {
                node: this,
                getOutline: function() {
                    return this.node.path
                }
            };
            this.text.fitInBounds = true;
            this.text.textAlignment = b.Alignment.Center;
            this.text.lineAlignment = b.Alignment.Center
        };
        l.prototype = {
            getClosed: function() {
                return this.closed
            },
            setClosed: function(n) {
                if (this.closed != n) {
                    this.closed = n;
                    this.invalidate()
                }
            },
            getPoints: function() {
                return this.points
            },
            setPoints: function(n) {
                if (this.points != n) {
                    this.points = n;
                    this.updateFromPoints()
                }
            },
            clone: function() {
                var n = mflayer.callBaseMethod(l, this, "clone", []);
                n.closed = this.closed;
                n.points = g(this.points);
                n.updatePathFromPoints();
                return n
            },
            toJson: function() {
                var n = mflayer.callBaseMethod(l, this, "toJson", []);
                n.closed = this.closed;
                n.points = f(this.points);
                return n
            },
            fromJson: function(n) {
                mflayer.callBaseMethod(l, this, "fromJson", [n]);
                this.closed = n.closed;
                this.points = k(n.points);
                this.updatePathFromPoints()
            },
            loadFromXml: function(o, n) {
                mflayer.callBaseMethod(l, this, "loadFromXml", [o, n]);
                this.closed = n.readBool("Closed", o);
                this.points = k(n.readString("Points", o));
                this.updatePathFromPoints()
            },
            saveToXml: function(o, n) {
                mflayer.callBaseMethod(l, this, "saveToXml", [o, n]);
                n.writeBool(this.closed, "Closed", o);
                n.writeString(f(this.points), "Points", o)
            },
            updateCanvasElements: function() {
                var p = this.graphicsContainer.content = [];
                var o = this.bounds;
                var n = this.getEffectiveBrush();
                if (this.closed) {
                    var q = {
                        brush: n,
                        phase: j.BeforeFill
                    };
                    this.applyEffects(p, q);
                    if (q.brush) {
                        n = q.brush
                    }
                }
                if (this.closed) {
                    this.path.brush = n
                } else {
                    this.path.brush = null
                }
                this.path.pen = this.getEffectiveStroke();
                this.path.strokeThickness = 1;
                this.path.strokeDashStyle = this.getEffectiveStrokeDashStyle();
                this.path.shadow = this.createShadow();
                p.push(this.path);
                if (this.closed) {
                    this.applyEffects(p, {
                        phase: j.AfterFill
                    })
                }
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.setBounds(o, (this.rotateText) ? this.rotationAngle : 0);
                p.push(this.text);
                this.addManipulatorVisuals(p);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            startDrag: function(v) {
                if (v.action == b.Action.Create) {
                    var w = v.startPoint.clone();
                    this.points.push(w);
                    this.path.moveTo(w.x, w.y)
                }
                if (v.action == b.Action.Modify && mflayer.isInstanceOfType(b.FreeFormHandle, v.adjustmentHandle)) {
                    var o = v.adjustmentHandle;
                    var s = Math.min(this.bounds.width / 6, Math.min(this.bounds.height / 6, this.parent.freeFormAttractDistance));
                    this.attractedPoints = [];
                    var n = this.points[o.index];
                    for (var q = -1; q <= 1; q += 2) {
                        for (var r = o.index + q; true; r += q) {
                            var t = r % this.points.length;
                            if (t < 0) {
                                t = this.points.length + t
                            }
                            if (t == o.index) {
                                this.attractedPoints = [];
                                break
                            }
                            var z = this.points[t];
                            var u = h.distance(n, z);
                            if (u > s) {
                                break
                            }
                            this.attractedPoints[t] = u
                        }
                    }
                }
                mflayer.callBaseMethod(l, this, "startDrag", [v])
            },
            updateDrag: function(u) {
                if (u.action == b.Action.Create) {
                    var B = this.points[this.points.length - 1];
                    var s = u.currentPoint;
                    if (!B.equals(s)) {
                        var w = s.clone();
                        this.points.push(w);
                        this.path.lineTo(w.x, w.y);
                        this.updateFromPoints(false, false)
                    }
                    return
                }
                if (u.action == b.Action.Modify && mflayer.isInstanceOfType(b.FreeFormHandle, u.adjustmentHandle)) {
                    var n = u.originalStates.get(this);
                    var q = n.originalPoints;
                    var o = u.adjustmentHandle;
                    var r = o.index;
                    var D = u.currentPoint.x - q[r].x;
                    var C = u.currentPoint.y - q[r].y;
                    for (var p = 0; p < this.attractedPoints.length; p++) {
                        var A = this.attractedPoints[p];
                        if (A === undefined) {
                            continue
                        }
                        var z = q[p].clone();
                        var t = a.convert(A, a.Millimeter, this.parent.measureUnit);
                        t = Math.max(t / 2, 1);
                        z.x += D / (t * t);
                        z.y += C / (t * t);
                        this.points[p] = z
                    }
                    this.points[r] = u.currentPoint.clone();
                    if (!this.outlineBounds().equals(this.bounds)) {
                        this.updateFromPoints(true, false)
                    }
                    this.updatePathFromPoints();
                    this.invalidate();
                    return
                }
                mflayer.callBaseMethod(l, this, "updateDrag", [u])
            },
            endDrag: function(n) {
                mflayer.callBaseMethod(l, this, "endDrag", [n]);
                if (n.action == b.Action.Create) {
                    if (h.distance(n.currentPoint, this.points[0]) < this.parent.autoCloseDistance) {
                        this.closed = true;
                        this.path.close();
                        this.invalidate()
                    }
                }
            },
            saveLocationState: function() {
                var n = mflayer.callBaseMethod(l, this, "saveLocationState", []);
                n.originalPoints = this.points.slice();
                return n
            },
            restoreLocationState: function(n) {
                this.invalidate();
                var o = n.originalStates.get(this);
                if (o != null) {
                    if (mflayer.isInstanceOfType(b.FreeFormHandle, n.adjustmentHandle)) {
                        this.points = o.originalPoints.slice();
                        this.updateFromPoints(false, true)
                    }
                }
                mflayer.callBaseMethod(l, this, "restoreLocationState", [n])
            },
            outlineBounds: function(p) {
                if (p === undefined) {
                    p = this.points
                }
                var q = null;
                for (var o = 0; o < p.length; o++) {
                    var n = p[o];
                    if (q == null) {
                        q = new d(n.x, n.y, 0, 0)
                    } else {
                        q = e(q, n)
                    }
                }
                return q != null ? q : d.empty
            },
            updateFromPoints: function(n, o) {
                if (n === undefined) {
                    n = true
                }
                if (o === undefined) {
                    o = true
                }
                this.updateFlag = true;
                this.setBounds(this.outlineBounds(), n);
                this.updateFlag = false;
                if (o) {
                    this.updatePathFromPoints()
                }
            },
            updatePathFromPoints: function() {
                this.path = new MindFusion.Drawing.Path();
                for (var o = 0; o < this.points.length; o++) {
                    var n = this.points[o];
                    if (o == 0) {
                        this.path.moveTo(n.x, n.y)
                    } else {
                        this.path.lineTo(n.x, n.y)
                    }
                }
                if (this.closed) {
                    this.path.close()
                }
            },
            onUpdateBounds: function() {
                mflayer.callBaseMethod(l, this, "onUpdateBounds", []);
                if (this.updateFlag) {
                    return
                }
                var o = this.outlineBounds();
                if (o.equals(this.bounds)) {
                    return
                }
                var n = this.bounds.width;
                var p = this.bounds.height;
                var s = a.getMillimeter(this.parent.measureUnit);
                if (n > s && p > s) {
                    if (n != o.width || p != o.height) {
                        var r = new c();
                        r.scaleAtCenter(n / o.width, p / o.height, this.bounds);
                        r.transformPoints(this.points)
                    }
                    var q = new c();
                    o = this.outlineBounds();
                    q.translate(this.bounds.x - o.x, this.bounds.y - o.y);
                    q.transformPoints(this.points);
                    this.updatePathFromPoints()
                }
            },
            handleAtPoint: function(n) {
                var o = this.nearestPointIndex(n, 4 * a.getMillimeter(this.parent.measureUnit));
                if (o !== null) {
                    return new b.FreeFormHandle(this, o)
                }
                return mflayer.callBaseMethod(l, this, "handleAtPoint", [n])
            },
            nearestPointIndex: function(n, q) {
                var o = Number.MAX_VALUE;
                var t = null;
                for (var p = 0; p < this.points.length; p++) {
                    var r = this.points[p];
                    if (Math.abs(r.x - n.x) > q || Math.abs(r.y - n.y) > q) {
                        continue
                    }
                    var s = h.distance(n, r);
                    if (s < o) {
                        t = p;
                        o = s
                    }
                }
                return t
            },
            containsPoint: function(n) {
                return b.ShapeNode.prototype.containsPoint.apply(this, [n])
            },
            drawHandles: function(q) {
                mflayer.callBaseMethod(l, this, "drawHandles", [q]);
                var o = this.getEffectiveHandlesSize();
                q.save();
                q.lineWidth = 1 / q._mf_scale;
                q.strokeStyle = "black";
                q.fillStyle = "yellow";
                for (var p = 0; p < this.points.length; p++) {
                    var n = this.points[p];
                    q.beginPath();
                    q.arc(n.x, n.y, o / 4, 0, 2 * Math.PI);
                    q.fill();
                    q.stroke()
                }
                q.restore()
            },
            getOutline: function() {
                return g(this.points)
            },
            getNearestBorderPoint: function(n) {
                return mflayer.callBaseMethod(l, this, "getNearestBorderPoint", [n])
            },
            resolveInheritedStyle: function(o, p) {
                var n = p.styles["std:FreeFormNode"];
                if (n) {
                    if (o.apply(n)) {
                        return n
                    }
                }
                return mflayer.callBaseMethod(l, this, "resolveInheritedStyle", [o, p])
            },
            saveState: function() {
                var n = mflayer.callBaseMethod(l, this, "saveState", []);
                n.closed = this.closed;
                n.points = g(this.points);
                return n
            },
            restoreState: function(n) {
                this.updateFlag = true;
                mflayer.callBaseMethod(l, this, "restoreState", [n]);
                this.updateFlag = false;
                this.closed = n.closed;
                this.points = g(n.points);
                this.updatePathFromPoints()
            },
            standardShapeReplacement: function(r, u) {
                var B = this.getBounds();
                var z = null;
                var v = Number.MAX_VALUE;
                var A = 20 * a.getMillimeter(this.parent.measureUnit);
                var C = new b.ShapeNode(this.parent);
                C.setBounds(B);
                for (var t = 0; t < r.length; t++) {
                    var w = r[t];
                    C.setShape(w);
                    var n = C.getOutline();
                    var s = 0;
                    for (var q = 0; q < this.points.length; q++) {
                        var D = this.points[q];
                        var o = b.Utils.distToPolyline(D, n, n.length);
                        s += o
                    }
                    s /= this.points.length;
                    if (s < v) {
                        z = w;
                        v = s
                    }
                }
                C.setShape(v < A ? z : u);
                return C
            },
            init: function() {
                if (!b.FreeFormNodeBuilder) {
                    b.FreeFormNodeBuilder = new MindFusion.Builder(l.prototype, null, this)
                } else {
                    b.FreeFormNodeBuilder.setInstance(this)
                }
                return b.FreeFormNodeBuilder
            }
        };
        l.With = function(n) {
            if (!b.FreeFormNodeBuilder) {
                b.FreeFormNodeBuilder = new MindFusion.Builder(l.prototype, n)
            } else {
                b.FreeFormNodeBuilder.setInstance(null)
            }
            return b.FreeFormNodeBuilder
        };
        b.FreeFormNodeBuilder = null;
        MindFusion.registerClass(l, "MindFusion.Diagramming.FreeFormNode", b.DiagramNode);
        b.FreeFormHandle = function(o, n) {
            this.item = o;
            this.index = n
        };
        MindFusion.registerClass(b.FreeFormHandle, "MindFusion.Diagramming.FreeFormHandle");

        function e(o, n) {
            if (o.containsPoint(n)) {
                return o
            }
            return d.fromLTRB(Math.min(o.left(), n.x), Math.min(o.top(), n.y), Math.max(o.right(), n.x), Math.max(o.bottom(), n.y))
        }

        function g(o) {
            var p = [];
            for (var n = 0; n < o.length; n++) {
                p[n] = o[n].clone()
            }
            return p
        }

        function f(o) {
            var p = "";
            for (var n = 0; n < o.length; n++) {
                if (n > 0) {
                    p += ","
                }
                p += o[n].x.toString();
                p += ",";
                p += o[n].y.toString()
            }
            return p
        }

        function k(t) {
            var r = [];
            var s = t.split(",");
            for (var p = 0; p < s.length; p += 2) {
                var o = s[p];
                var q = s[p + 1];
                var n = new h(Number(o), Number(q));
                r.push(n)
            }
            return r
        }
    })(MindFusion.Diagramming);
    (function(b) {
        var c = MindFusion.Drawing.Point;
        var d = MindFusion.Drawing.GraphicsUnit;
        var a = b.HandleUtils = {
            pointInHandle: function(l, t) {
                var k = b.AdjustmentHandles;
                var z = b.HandlesStyle;
                var g = t.getBounds();
                var f = t.getRotationAngle();
                var r = t.getHandlesStyle();
                var n = t.getEnabledHandles();
                var u = t.getParent();
                var h = t.getEffectiveHandlesSize();
                var v = u.touchThreshold;
                if (v === undefined) {
                    v = 0
                }
                if (f) {
                    l = b.Utils.rotatePointAt(l, g.center(), -f)
                }
                if (r == z.MoveOnly || r == z.InvisibleMove) {
                    return g.containsPoint(l) && (n & k.Move) != 0 ? {
                        item: t,
                        index: 8
                    } : null
                }
                var q = d.getMillimeter(u.measureUnit);
                if (r == z.SquareHandles || r == z.HatchHandles || r == z.EasyMove || r == z.RoundAndSquare || r == z.RoundAndSquare2) {
                    var A = a.getHandlePositions(g, q);
                    if (r == z.EasyMove && (l.distance(A[8]) < 1.5 * h)) {
                        return null
                    }
                    for (var p = 0; p < 10; ++p) {
                        if (Math.abs(A[p].x - l.x) <= (h / 2 + v) && Math.abs(A[p].y - l.y) <= (h / 2 + v) && (n & (1 << p)) != 0) {
                            return {
                                item: t,
                                index: p
                            }
                        }
                    }
                    if (r == z.EasyMove && g.containsPoint(l) && (n & k.Move) != 0) {
                        return {
                            item: t,
                            index: 8
                        }
                    }
                    g = g.inflate(h / 2);
                    if (r == z.HatchHandles && g.containsPoint(l) && (n & k.Move) != 0) {
                        g = g.inflate(-h);
                        return !g.containsPoint(l) ? {
                            item: t,
                            index: 8
                        } : null
                    }
                } else {
                    var o = a.getHandlePositions(g, q);
                    for (var p = 0; p < 4; ++p) {
                        if (Math.abs(o[p].x - l.x) <= (h / 2) && Math.abs(o[p].y - l.y) <= (h / 2) && (n & (1 << p)) != 0) {
                            return {
                                item: t,
                                index: p
                            }
                        }
                    }
                    var j = q / 2;
                    g = g.inflate(j);
                    if (g.containsPoint(l)) {
                        g = g.inflate(-j);
                        if (Math.abs(g.top() - l.y) <= (h / 2) && (n & k.ResizeTopCenter) != 0) {
                            return {
                                item: t,
                                index: 4
                            }
                        }
                        if (Math.abs(g.right() - l.x) <= (h / 2) && (n & k.ResizeMiddleRight) != 0) {
                            return {
                                item: t,
                                index: 5
                            }
                        }
                        if (Math.abs(g.bottom() - l.y) <= (h / 2) && (n & k.ResizeBottomCenter) != 0) {
                            return {
                                item: t,
                                index: 6
                            }
                        }
                        if (Math.abs(g.left() - l.x) <= (h / 2) && (n & k.ResizeMiddleLeft) != 0) {
                            return {
                                item: t,
                                index: 7
                            }
                        }
                    }
                    var e = o[9];
                    if (Math.abs(e.x - l.x) <= (h / 2) && Math.abs(e.y - l.y) <= (h / 2) && (n & k.Rotate) != 0) {
                        return {
                            item: t,
                            index: 9
                        }
                    }
                    var s = g.clone();
                    var w = t.getCaptionHeight ? t.getCaptionHeight() : 0;
                    if (w != 0) {
                        s.height = w
                    } else {
                        s = s.inflate(-h * 2)
                    }
                    if ((s.width < q || s.height < q) && g.containsPoint(l)) {
                        s = s.inflate(h)
                    }
                    if (s.containsPoint(l) && (n & k.Move) != 0) {
                        return {
                            item: t,
                            index: 8
                        }
                    }
                }
                return null
            },
            drawAdjustmentHandles: function(f, p) {
                var n = b.AdjustmentHandles;
                var g = b.HandlesStyle;
                var k = p.getParent();
                var l = p.getHandlesStyle();
                var h = p.getBounds();
                var q = p.getEffectiveHandlesSize();
                var j = d.getMillimeter(k.measureUnit);
                if (f.setLineDash) {
                    f.setLineDash([])
                }
                if (l == g.Invisible || l == g.InvisibleMove) {
                    return
                }
                if (l == g.SquareHandles || l == g.SquareHandles2 || l == g.EasyMove) {
                    a.drawSquareHandles(f, p);
                    return
                }
                if (l == g.RoundAndSquare || l == g.RoundAndSquare2) {
                    a.drawRoundAndSquareHandles(f, p);
                    return
                }
                var e = h.center();
                if (l == g.DashFrame) {
                    a.drawDashFrame(f, h, j);
                    if ((p.getEnabledHandles() & n.Rotate) != 0) {
                        a.drawRotationHandle(f, p)
                    }
                    return
                }
                if (l == g.HatchFrame) {
                    a.drawHatchFrame(f, h, a.getHatchFill(), q);
                    if ((p.getEnabledHandles() & n.Rotate) != 0) {
                        a.drawRotationHandle(f, p)
                    }
                    return
                }
                if (l == g.HatchHandles || l == g.HatchHandles2 || l == g.HatchHandles3 || l == g.MoveOnly) {
                    var o = l == g.HatchHandles3 || l == g.MoveOnly ? a.getPatternFill() : a.getHatchFill();
                    a.drawHatchFrame(f, h, o, q);
                    if (l == g.MoveOnly) {
                        return
                    }
                    a.drawSquareHandles(f, p);
                    return
                }
            },
            drawSquareHandles: function(j, v) {
                var s = b.AdjustmentHandles;
                var k = b.HandlesStyle;
                var e = v.getBounds();
                var o = v.getParent();
                var r = o.getShowDisabledHandles();
                var f = e.center();
                var z = v.getEffectiveHandlesSize();
                var u = z / 2;
                var g = v.getHandlesStyle();
                var w = v.getEnabledHandles();
                var l = d.getMillimeter(o.measureUnit);
                var q = a.getHandlePositions(e, l);
                j.fillStyle = b.Utils.getBrush(j, o.handleBrush, o.getBounds());
                j.strokeStyle = "black";
                j.lineWidth = 1 / j._mf_scale;
                if ((w & s.Rotate) != 0) {
                    a.drawRotationHandle(j, v)
                }
                for (var p = 0; p < 9; p++) {
                    var n = (w & (1 << p)) == 0;
                    if (n && !r) {
                        continue
                    }
                    var t = q[p];
                    if (p == 8) {
                        if (g == k.EasyMove) {
                            a.drawCircle(j, t, z);
                            continue
                        }
                        if (g != k.SquareHandles) {
                            continue
                        }
                    }
                    j.fillRect(t.x - u, t.y - u, z, z);
                    j.strokeRect(t.x - u, t.y - u, z, z)
                }
            },
            drawRoundAndSquareHandles: function(g, t) {
                var q = b.AdjustmentHandles;
                var e = t.getBounds();
                var l = t.getParent();
                var p = l.getShowDisabledHandles();
                var f = e.center();
                var v = t.getEffectiveHandlesSize();
                var s = v / 2;
                var u = t.getEnabledHandles();
                var j = d.getMillimeter(l.measureUnit);
                var o = a.getHandlePositions(e, j);
                g.fillStyle = b.Utils.getBrush(g, l.handleBrush, l.getBounds());
                g.strokeStyle = "black";
                g.lineWidth = 1 / g._mf_scale;
                if ((u & q.Rotate) != 0) {
                    a.drawRotationHandle(g, t)
                }
                for (var n = 0; n < 9; n++) {
                    var k = (u & (1 << n)) == 0;
                    if (k && !p) {
                        continue
                    }
                    var r = o[n];
                    if (n < 4) {
                        a.drawCircle(g, r, s * 1.2)
                    } else {
                        g.fillRect(r.x - s, r.y - s, v, v);
                        g.strokeRect(r.x - s, r.y - s, v, v)
                    }
                }
            },
            drawDashFrame: function(e, f, h) {
                e.lineWidth = 1 / e._mf_scale;
                if (e.setLineDash) {
                    e.strokeStyle = "white";
                    e.strokeRect(f.x, f.y, f.width, f.height);
                    var g = e.getLineDash();
                    e.setLineDash([2 * h]);
                    e.strokeStyle = "black";
                    e.strokeRect(f.x, f.y, f.width, f.height);
                    e.setLineDash(g)
                } else {
                    e.strokeStyle = "lightgray";
                    e.beginPath();
                    a.drawDashedLine(e, f.topLeft(), f.topRight(), 2 * h);
                    a.drawDashedLine(e, f.topRight(), f.bottomRight(), 2 * h);
                    a.drawDashedLine(e, f.bottomRight(), f.bottomLeft(), 2 * h);
                    a.drawDashedLine(e, f.bottomLeft(), f.topLeft(), 2 * h);
                    e.stroke()
                }
            },
            drawDashedLine: function(e, n, l, g) {
                var j = Math.floor(n.distance(l) / g);
                var p = (l.x - n.x) / j;
                var o = (l.y - n.y) / j;
                e.moveTo(n.x, n.y);
                var k = n.x,
                    h = n.y;
                for (var f = 0; f < j; f++) {
                    k += p;
                    h += o;
                    if (f % 2 == 0) {
                        e.moveTo(k, h)
                    } else {
                        e.lineTo(k, h)
                    }
                }
                if (f % 2 == 0) {
                    e.moveTo(l.x, l.y)
                } else {
                    e.lineTo(l.x, l.y)
                }
            },
            drawHatchFrame: function(f, g, j, e) {
                var k = f._mf_scale;
                f.save();
                f.scale(1 / k, 1 / k);
                var h = f.createPattern(j, "repeat");
                f.strokeStyle = h;
                f.lineWidth = k * e / 2;
                f.strokeRect(k * g.x, k * g.y, k * g.width, k * g.height);
                f.restore()
            },
            drawRotationHandle: function(g, n) {
                var j = n.getParent();
                var h = d.getMillimeter(j.measureUnit);
                var e = n.getBounds();
                var o = e.topLeft();
                var f = e.center();
                var l = new c(f.x, o.y - 6 * h);
                var k = 1.4 * n.getEffectiveHandlesSize() / 2;
                g.lineWidth = 1 / g._mf_scale;
                g.strokeStyle = "lightgray";
                g.beginPath();
                a.drawDashedLine(g, l, e.topMiddle(), h);
                g.stroke();
                g.fillStyle = b.Utils.getBrush(g, j.handleBrush, j.getBounds());
                g.strokeStyle = "black";
                a.drawCircle(g, l, k)
            },
            getHandlePositions: function(j, k) {
                var g = j.topLeft();
                var h = j.bottomRight();
                var e = j.center();
                var f = [];
                f.push(g);
                f.push(j.topRight());
                f.push(h);
                f.push(j.bottomLeft());
                f.push(new c(e.x, g.y));
                f.push(new c(h.x, e.y));
                f.push(new c(e.x, h.y));
                f.push(new c(g.x, e.y));
                f.push(e);
                f.push(new c(e.x, g.y - 6 * k));
                return f
            },
            drawCircle: function(g, f, e) {
                g.beginPath();
                g.arc(f.x, f.y, e, 0, 2 * Math.PI, false);
                g.closePath();
                g.fill();
                g.stroke()
            },
            getHatchFill: function() {
                if (!a.hatchFill) {
                    a.hatchFill = a.createPattern([1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1])
                }
                return a.hatchFill
            },
            getPatternFill: function() {
                if (!a.patternFill) {
                    a.patternFill = a.createPattern([1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1])
                }
                return a.patternFill
            },
            createPattern: function(n) {
                var k = document.createElement("canvas");
                k.width = 8;
                k.height = 8;
                var g = k.getContext("2d");
                g.fillStyle = "rgb(255,255,255)";
                g.fillRect(0, 0, 8, 8);
                var h = g.createImageData(1, 1);
                var j = h.data;
                j[0] = 0;
                j[1] = 0;
                j[2] = 0;
                j[3] = 255;
                for (var l = 0; l < 8; l++) {
                    for (var e = 0; e < 8; e++) {
                        var f = 8 * l + e;
                        if (n[f]) {
                            g.putImageData(h, e, l)
                        }
                    }
                }
                return k
            },
            hatchFill: null,
            patternFill: null
        }
    })(MindFusion.Diagramming);
    (function(c) {
        var a = MindFusion.Collections.ArrayList;
        var g = MindFusion.Collections.Dictionary;
        var f = MindFusion.Collections.Set;
        var d = MindFusion.Drawing.Rect;
        var e = MindFusion.Drawing.Point;
        var b = c.LayoutUtils = {
            arrange: function(l, p, o) {
                var n = p.toGraph(l.requiresSimpleGraph, l.keepGroupLayout, l.requiresHierarchyInfo);
                n._mf_mm = p.millimeter();
                n.layoutArea = p.getBounds();
                if (l.requiresHierarchyInfo) {
                    b.collectHierarchyInfo(n)
                }
                b.linkRouter = p.linkRouter;
                if (!b.linkRouter && p.parent) {
                    b.linkRouter = p.parent.linkRouter
                }
                var k = l.requiresConnectedGraph ? n.getConnectedComponents() : [n];
                var j = l.margins + p.bounds.x;
                var h = l.margins + p.bounds.y;
                if (p.captionHeight !== undefined) {
                    h += p.captionHeight
                }
                a.forEach(k, function(r) {
                    var s = MindFusion.Graphs.MultipleGraphsPlacement;
                    var t = b.prepareLayout(r);
                    r._mf_mm = n._mf_mm;
                    if (l.arrange(r) === $skipLayout) {
                        return
                    }
                    var q = o != undefined ? b.applyAnimatedLayout(r, l, j, h, t, p, o, n) : b.applyLayout(r, l, j, h, t, p);
                    if (l.multipleGraphsPlacement == s.Horizontal) {
                        j += q.width + l.margins
                    } else {
                        h += q.height + l.margins
                    }
                });
                if (!o) {
                    b.completeLayout(n, l)
                }
            },
            completeLayout: function(k, h) {
                k.$selfLoops.forEach(function(l) {
                    l.setLoopShape()
                });
                var j = h.routeRepeatingLinks ? [] : null;
                k.$repeatingLinks.forEach(function(n, l) {
                    l.forEach(function(o) {
                        o.shape = n.shape;
                        o.resetLink();
                        if (j) {
                            j.push(o)
                        }
                    })
                });
                if (j && j.length > 0 && b.linkRouter) {
                    b.linkRouter.routeLinks(j)
                }
            },
            prepareLayout: function(j) {
                var h = new g();
                j.edges.forEach(function(o) {
                    var n = o.owner;
                    if (n) {
                        var k = n.getOriginAnchor();
                        var l = n.getDestinationAnchor();
                        h.set(n, {
                            originAnchor: k,
                            destinationAnchor: l
                        })
                    }
                });
                return {
                    anchoring: h
                }
            },
            applyAnimatedLayout: function(q, n, t, s, k, o, l, p) {
                var h = b.getGraphBounds(q, o.bounds);
                var r = [];
                q.vertices.forEach(function(z) {
                    var A = {
                        animationType: l.animationType,
                        duration: l.duration,
                        easingType: l.easingType
                    };
                    if (z.owner) {
                        if (n.keepGroupLayout) {
                            var D = z.x - z.width / 2;
                            var C = z.y - z.height / 2;
                            if (!(n.isStatic && n.isStatic())) {
                                var u = z.owner.bounds;
                                A.fromValue = new e(u.x, u.y);
                                A.toValue = new e(D + t - h.x, C + s - h.y);
                                if (A.fromValue.x != A.toValue.x || A.fromValue.y != A.toValue.y) {
                                    r.push(new MindFusion.Animations.Animation(z, A, function(E, F) {
                                        var G = E.item.owner;
                                        var H = E.getFromValue();
                                        var v = E.getToValue();
                                        G.move(H.x + (v.x - H.x) * F, H.y + (v.y - H.y) * F, true, true)
                                    }))
                                }
                            } else {
                                var u = z.owner.bounds;
                                A.fromValue = new e(u.x, u.y);
                                A.toValue = new e(D, C);
                                if (A.fromValue.x != A.toValue.x || A.fromValue.y != A.toValue.y) {
                                    r.push(new MindFusion.Animations.Animation(z, A, function(E, F) {
                                        var G = E.item.owner;
                                        var H = E.getFromValue();
                                        var v = E.getToValue();
                                        G.move(H.x + (v.x - H.x) * F, H.y + (v.y - H.y) * F, true, true)
                                    }))
                                }
                            }
                        } else {
                            var w = n.requiresHierarchyInfo ? false : true;
                            var B = z.owner.getMasterNode();
                            if (!(n.isStatic && n.isStatic())) {
                                var u = z.owner.bounds;
                                A.fromValue = new e(u.x + u.width / 2 - (t - h.x), u.y + u.height / 2 - (s - h.y));
                                A.toValue = new e(z.x, z.y);
                                if (A.fromValue.x != A.toValue.x || A.fromValue.y != A.toValue.y || (B != null && b.shouldMoveWithMaster(q.vertices, B, new e(B.bounds.x + B.bounds.width / 2 - (t - h.x), B.bounds.y + B.bounds.height / 2 - (s - h.y))))) {
                                    r.push(new MindFusion.Animations.Animation(z.owner, A, function(E, F) {
                                        var G = E.item;
                                        var H = E.getFromValue();
                                        var v = E.getToValue();
                                        z.x = H.x + (v.x - H.x) * F;
                                        z.y = H.y + (v.y - H.y) * F;
                                        G.setCenterAndSize(z, t - h.x, s - h.y, true, w)
                                    }))
                                }
                            } else {
                                var u = z.owner.bounds;
                                A.fromValue = new e(u.x + u.width / 2, u.y + u.height / 2);
                                A.toValue = new e(z.x, z.y);
                                if (A.fromValue.x != A.toValue.x || A.fromValue.y != A.toValue.y || (B != null && b.shouldMoveWithMaster(q.vertices, B, new e(B.bounds.x + B.bounds.width / 2, B.bounds.y + B.bounds.height / 2)))) {
                                    r.push(new MindFusion.Animations.Animation(z, A, function(E, F) {
                                        var H = E.item.owner;
                                        var G = E.item;
                                        var I = E.getFromValue();
                                        var v = E.getToValue();
                                        z.x = I.x + (v.x - I.x) * F;
                                        z.y = I.y + (v.y - I.y) * F;
                                        H.setCenterAndSize(G, 0, 0, true, w)
                                    }))
                                }
                            }
                        }
                    }
                });
                var j = r.length;
                a.forEach(r, function(u) {
                    u.addEventListener("animationComplete", function(v, w) {
                        j--;
                        if (j == 0) {
                            if (!n.setsLinkPoints) {
                                b.resetLinks(o.links)
                            } else {
                                q.edges.forEach(function(A) {
                                    var z = A.owner;
                                    if (z) {
                                        if (n.requiresCascadingLinks && n.requiresCascadingLinks()) {
                                            z.setShape(c.LinkShape.Cascading)
                                        }
                                        if (!(n.isStatic && n.isStatic())) {
                                            z.copyPoints(A.points, t - h.x, s - h.y, !n.setsLinkEndPoints)
                                        } else {
                                            z.copyPoints(A.points, 0, 0, !n.setsLinkEndPoints)
                                        }
                                        if (n.setsLinkEndPoints) {
                                            z.updateFromPoints()
                                        }
                                        z.fixRowConnections()
                                    }
                                })
                            }
                            q.edges.forEach(function(B) {
                                var A = B.owner;
                                if (A) {
                                    if (n.anchoring == MindFusion.Graphs.Anchoring.Reassign) {
                                        var C = A.origin.getNearestAnchor(A.points[0], A, false);
                                        var D = A.destination.getNearestAnchor(A.points[A.points.length - 1], A, true);
                                        A.setOriginAnchor(C.index);
                                        A.setDestinationAnchor(D.index)
                                    } else {
                                        if (n.anchoring == MindFusion.Graphs.Anchoring.Keep) {
                                            if (k && k.anchoring) {
                                                var z = k.anchoring.get(A);
                                                if (z) {
                                                    if (z.originAnchor || z.originAnchor === 0) {
                                                        A.setOriginAnchor(z.originAnchor)
                                                    }
                                                    if (z.destinationAnchor || z.destinationAnchor === 0) {
                                                        A.setDestinationAnchor(z.destinationAnchor)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                            b.completeLayout(p, n);
                            if (o.arrangeAnimatedComplete) {
                                o.arrangeAnimatedComplete(n)
                            }
                            if (o.raiseAnimatedLayoutCompleted) {
                                o.raiseAnimatedLayoutCompleted()
                            } else {
                                if (o.parent && o.parent.raiseAnimatedLayoutCompleted) {
                                    o.parent.raiseAnimatedLayoutCompleted(o)
                                }
                            }
                        }
                    });
                    window.setTimeout(function() {
                        u.start()
                    }, 10)
                });
                return h
            },
            shouldMoveWithMaster: function(j, k, h) {
                var l = null;
                j.forEach(function(n) {
                    if (n.owner == k) {
                        l = n
                    }
                });
                return l != null && (h.x != l.x || h.y != l.y)
            },
            applyLayout: function(o, l, j, h, p, n) {
                var k = b.getGraphBounds(o, n.bounds);
                o.vertices.forEach(function(r) {
                    if (r.owner) {
                        if (l.keepGroupLayout) {
                            var t = r.x - r.width / 2;
                            var s = r.y - r.height / 2;
                            if (!(l.isStatic && l.isStatic())) {
                                r.owner.move(t + j - k.x, s + h - k.y, true, true)
                            } else {
                                r.owner.move(t, s, true, true)
                            }
                        } else {
                            var q = l.requiresHierarchyInfo ? false : true;
                            if (!(l.isStatic && l.isStatic())) {
                                r.owner.setCenterAndSize(r, j - k.x, h - k.y, true, q)
                            } else {
                                r.owner.setCenterAndSize(r, 0, 0, true, q)
                            }
                        }
                    }
                });
                if (!l.setsLinkPoints) {
                    b.resetLinks(n.links)
                } else {
                    o.edges.forEach(function(r) {
                        var q = r.owner;
                        if (q) {
                            if (l.requiresCascadingLinks && l.requiresCascadingLinks()) {
                                q.setShape(c.LinkShape.Cascading)
                            }
                            if (!(l.isStatic && l.isStatic())) {
                                q.copyPoints(r.points, j - k.x, h - k.y, !l.setsLinkEndPoints)
                            } else {
                                q.copyPoints(r.points, 0, 0, !l.setsLinkEndPoints)
                            }
                            if (l.setsLinkEndPoints) {
                                q.updateFromPoints()
                            }
                            q.fixRowConnections()
                        }
                    })
                }
                o.edges.forEach(function(s) {
                    var r = s.owner;
                    if (r) {
                        if (l.anchoring == MindFusion.Graphs.Anchoring.Reassign) {
                            var u = r.origin.getNearestAnchor(r.points[0], r, false);
                            var v = r.destination.getNearestAnchor(r.points[r.points.length - 1], r, true);
                            r.setOriginAnchor(u.index);
                            r.setDestinationAnchor(v.index)
                        } else {
                            if (l.anchoring == MindFusion.Graphs.Anchoring.Keep) {
                                if (p && p.anchoring) {
                                    var q = p.anchoring.get(r);
                                    if (q) {
                                        if (q.originAnchor || q.originAnchor === 0) {
                                            r.setOriginAnchor(q.originAnchor)
                                        }
                                        if (q.destinationAnchor || q.destinationAnchor === 0) {
                                            r.setDestinationAnchor(q.destinationAnchor)
                                        }
                                    }
                                }
                            } else {
                                if (l.anchoring == MindFusion.Graphs.Anchoring.Custom) {
                                    var t = l.selectAnchorPoints(r);
                                    r.setOriginAnchor(t.origin);
                                    r.setDestinationAnchor(t.destination)
                                }
                            }
                        }
                    }
                });
                return k
            },
            toGraph: function(h, o, q, j, t, k) {
                var s = new MindFusion.Graphs.Graph();
                var l = s.$selfLoops = new a();
                var r = s.$repeatingLinks = new g();
                if (q) {
                    j.forEach(function(u) {
                        var v = s.createVertex(u.getBounds(), u);
                        v.debugId = u.getText();
                        v.weight = u.getWeight();
                        u.vertex = v
                    });
                    return s
                }
                var n = new g();
                var p = new g();
                c.LayoutUtils.buildNodeMap(j, n, p, o, k);
                n.forEach(function(v) {
                    var u = b.getUnionBounds(n.get(v));
                    if (mflayer.isInstanceOfType(c.ContainerNode, v) && v.getFolded()) {
                        u = v.bounds.clone()
                    }
                    var w = s.createVertex(u, v);
                    w.debugId = v.getText();
                    w.weight = v.getWeight();
                    v.vertex = w
                });
                a.forEach(t, function(z) {
                    if (z.isFrozen()) {
                        return
                    }
                    if (!p.contains(z.origin)) {
                        return
                    }
                    if (!p.contains(z.destination)) {
                        return
                    }
                    var v = p.get(z.origin);
                    var A = p.get(z.destination);
                    if (h) {
                        if (z.origin == z.destination) {
                            l.push(z)
                        }
                        if (v == A) {
                            return
                        }
                    }
                    var u;
                    if (h && (u = v.vertex.getCommonEdge(A.vertex)) != null) {
                        if (v.vertex == u.origin) {
                            if (!r.contains(u.owner)) {
                                r.set(u.owner, new a())
                            }
                            r.get(u.owner).push(z);
                            return
                        }
                    }
                    if (z.origin != z.destination && v == A) {
                        return
                    }
                    var w = s.createEdge(v.vertex, A.vertex, z);
                    w.debugId = z.getText()
                });
                return s
            },
            getAbsoluteNodeMaster: function(o, n, j) {
                var l = o;
                var p = l.getLayoutMaster(n);
                var h = new a();
                h.push(l);
                while (p != null && p != j) {
                    l = p;
                    if (h.contains(l)) {
                        var k = false;
                        a.forEach(h, function(q) {
                            if (q.isFrozen()) {
                                k = true;
                                return $break
                            }
                        });
                        if (k) {
                            throw new Error("Layouts that preserve grouping cannot operate on diagrams with cyclic groups which contain or have related to them nodes that are ignored.")
                        }
                        return o
                    }
                    h.push(l);
                    p = l.getLayoutMaster(n)
                }
                return l
            },
            collectGroup: function(k, l, h, j) {
                l.add(k);
                h.push(k);
                if (j) {
                    a.forEach(k.getAttachedNodes(), function(n) {
                        if (n.isFrozen()) {
                            return
                        }
                        b.collectGroup(n, l, h, j)
                    })
                }
                if (k.children) {
                    a.forEach(k.children, function(n) {
                        if (n.isFrozen()) {
                            return
                        }
                        b.collectGroup(n, l, h, j)
                    })
                }
            },
            buildNodeMap: function(k, l, n, o, j) {
                var h = new a();
                a.forEach(k, function(q) {
                    if (h.contains(q)) {
                        return
                    }
                    var p = b.getAbsoluteNodeMaster(q, o, j);
                    if (p.isFrozen()) {
                        return
                    }
                    var r = new f();
                    b.collectGroup(p, r, h, o);
                    l.set(p, r);
                    r.forEach(function(s) {
                        n.set(s, p)
                    })
                })
            },
            getUnionBounds: function(h) {
                if (h.getCount() == 0) {
                    return d.empty
                }
                var j = null;
                h.forEach(function(k) {
                    j = k.bounds.union(j)
                });
                return j
            },
            resetLinks: function(h) {
                a.forEach(h, function(j) {
                    j.resetLink()
                })
            },
            getGraphBounds: function(k, h) {
                if (k.vertices.length == 0) {
                    return h
                }
                var j = null;
                k.vertices.forEach(function(l) {
                    j = d.fromVertex(l).union(j)
                });
                k.edges.forEach(function(l) {
                    if (l.points) {
                        j = d.boundingRect(l.points).union(j)
                    }
                });
                return j
            },
            collectHierarchyInfo: function(h) {
                h.vertices.forEach(function(k) {
                    var j = k.owner;
                    if (mflayer.isInstanceOfType(c.ContainerNode, j)) {
                        k.headerSize = j.getCaptionHeight()
                    }
                    var l = j.getLayoutMaster(true);
                    if (l) {
                        var n = l.vertex;
                        k.master = n;
                        if (n.subordinates == null) {
                            n.subordinates = []
                        }
                        n.subordinates.push(k)
                    }
                })
            }
        }
    })(MindFusion.Diagramming);
    (function(a) {
        var d = MindFusion.Drawing.Rect;
        var g = MindFusion.Drawing.Point;
        var e = MindFusion.Drawing.Thickness;
        var f = MindFusion.Drawing.Text;
        var c = MindFusion.Diagramming.RelativeToLink;
        var b = a.LinkLabel = function(h, j) {
            this.link = h;
            this.text = new MindFusion.Drawing.Text(j || "", new d(0, 0, 1, 1));
            this.text.baseline = "top";
            this.text.padding = new e(0, 0, 0, 0);
            this.horizontalAlign = a.Alignment.Center;
            this.verticalAlign = a.Alignment.Far;
            this.relativeTo = c.LinkLength;
            this.index = 0;
            this.horizontalOffset = 0.5;
            this.verticalOffset = 0;
            this.margin = new e(2, 2, 2, 2);
            this.enableWrap = false;
            this.maxWidth = Number.MAX_VALUE;
            this.cachedLayoutRect = d.empty;
            this.autoArrange = false
        };
        b.prototype = {
            fromJson: function(h) {
                this.text = new MindFusion.Drawing.Text(h.text || "", new d(0, 0, 1, 1));
                this.text.baseline = "top";
                this.text.padding = new e(0, 0, 0, 0);
                this.relativeTo = h.relativeTo;
                this.index = h.index;
                this.horizontalOffset = h.horizontalOffset;
                this.verticalOffset = h.verticalOffset;
                if (typeof h.margin == "number") {
                    this.margin = new e(h.margin, h.margin, h.margin, h.margin)
                } else {
                    this.margin = e.copy(h.margin)
                }
                this.horizontalAlign = h.horizontalAlign;
                this.verticalAlign = h.verticalAlign;
                this.enableWrap = h.enableWrap;
                if (h.maxWidth) {
                    this.maxWidth = h.maxWidth
                }
                if (h.font) {
                    this.setFont(Font.copy(h.font))
                }
                if (h.textColor) {
                    this.setTextColor(h.textColor)
                }
                this.setAutoArrange(h.autoArrange);
                if (h.brush != undefined) {
                    this.setBrush(h.brush)
                }
            },
            toJson: function() {
                var h = {
                    text: this.text.text,
                    relativeTo: this.relativeTo,
                    index: this.index,
                    horizontalOffset: this.horizontalOffset,
                    verticalOffset: this.verticalOffset,
                    margin: this.margin,
                    horizontalAlign: this.horizontalAlign,
                    verticalAlign: this.verticalAlign,
                    enableWrap: this.enableWrap,
                    maxWidth: this.maxWidth == Number.MAX_VALUE ? undefined : this.maxWidth,
                    autoArrange: this.autoArrange,
                    font: this.font,
                    textColor: this.textColor,
                    brush: this.brush
                };
                return h
            },
            saveToXml: function(j, h) {
                j.setAttribute("Version", "2");
                h.writeString(this.getText(), "Text", j);
                h.writeInt(this.relativeTo, "RelativeTo", j);
                h.writeInt(this.index, "Index", j);
                h.writeFloat(this.horizontalOffset, "HorizontalOffset", j);
                h.writeFloat(this.verticalOffset, "VerticalOffset", j);
                h.writeThickness(this.margin, "Margin", j);
                h.writeInt(this.horizontalAlign, "HorizontalAlign", j);
                h.writeInt(this.verticalAlign, "VerticalAlign", j);
                h.writeBool(this.enableWrap, "EnableWrap", j);
                h.writeFloat(this.maxWidth, "MaxWidth", j);
                h.writeBrush(this.textColor, "TextBrush", j);
                h.writeBrush(this.brush, "Brush", j);
                h.writeFont(this.font, "Font", j);
                h.writeBool(this.autoArrange, "AutoArrange", j)
            },
            loadFromXml: function(j, h) {
                this.setText(h.readString("Text", j));
                this.relativeTo = h.readInt("RelativeTo", j);
                this.index = h.readInt("Index", j);
                this.horizontalOffset = h.readFloat("HorizontalOffset", j);
                this.verticalOffset = h.readFloat("VerticalOffset", j);
                this.margin = h.readThickness("Margin", j);
                this.horizontalAlign = h.readInt("HorizontalAlign", j);
                this.verticalAlign = h.readInt("VerticalAlign", j);
                this.enableWrap = h.readBool("EnableWrap", j);
                this.maxWidth = h.readFloat("MaxWidth", j);
                this.textColor = h.readBrush("TextBrush", j);
                this.brush = h.readBrush("Brush", j);
                this.font = h.readFont("Font", j);
                this.autoArrange = h.readBool("AutoArrange", j)
            },
            clone: function() {
                var h = new this.constructor(this.link);
                h.text = this.text.clone();
                h.relativeTo = this.relativeTo;
                h.index = this.index;
                h.horizontalOffset = this.horizontalOffset;
                h.verticalOffset = this.verticalOffset;
                h.margin = e.copy(this.margin);
                h.horizontalAlign = this.horizontalAlign;
                h.verticalAlign = this.verticalAlign;
                h.enableWrap = this.enableWrap;
                h.maxWidth = this.maxWidth;
                h.autoArrange = this.autoArrange;
                h.font = (this.font) ? Font.copy(this.font) : undefined, h.brush = this.brush;
                h.textColor = this.textColor;
                return h
            },
            setSegmentPosition: function(k, j, h) {
                this.relativeTo = c.Segment;
                this.index = k;
                this.horizontalOffset = j;
                this.verticalOffset = h;
                this.invalidate()
            },
            setControlPointPosition: function(k, j, h) {
                this.relativeTo = c.ControlPoint;
                this.index = k;
                this.horizontalOffset = j;
                this.verticalOffset = h;
                this.invalidate()
            },
            setLinkLengthPosition: function(h) {
                this.relativeTo = c.LinkLength;
                this.horizontalOffset = h;
                this.invalidate()
            },
            getLayoutRect: function() {
                if (this.cachedLayoutRect != d.empty) {
                    return this.cachedLayoutRect
                }
                var j = this.getPivotPoint();
                var k = (this.font != undefined) ? this.font : this.link.getEffectiveFont();
                var n = this.link.parent.measureString(this.text.text, k, new d(0, 0, Number.MAX_VALUE, 1));
                if (this.enableWrap && this.maxWidth != Number.MAX_VALUE) {
                    n = this.link.parent.measureString(this.text.text, k, new d(0, 0, this.maxWidth, n.height));
                    n.width = f.getMinWidth(this.text.text, this.text.font, this.link.parent.context, this.link.parent.scale);
                    this.text.fitInBounds = true
                }
                n.width += this.text.padding.width();
                n.height += this.text.padding.height();
                var l = /\r|\n/.exec(this.text.text);
                if (l) {
                    this.text.fitInBounds = true
                }
                var h = 0;
                switch (this.horizontalAlign) {
                    case a.Alignment.Near:
                        h = j.x + this.margin.left;
                        break;
                    case a.Alignment.Center:
                        h = j.x - n.width / 2;
                        break;
                    case a.Alignment.Far:
                        h = j.x - n.width - this.margin.right;
                        break
                }
                var o = 0;
                switch (this.verticalAlign) {
                    case a.Alignment.Near:
                        o = j.y + this.margin.top;
                        break;
                    case a.Alignment.Center:
                        o = j.y - n.height / 2;
                        break;
                    case a.Alignment.Far:
                        o = j.y - n.height - this.margin.bottom;
                        break
                }
                this.cachedLayoutRect = new d(h, o, n.width, n.height);
                this.cachedLayoutSize = this.cachedLayoutRect.getSize();
                this.text.setBounds(this.cachedLayoutRect, 0);
                return this.cachedLayoutRect
            },
            getPivotPoint: function() {
                switch (this.relativeTo) {
                    case c.Segment:
                        var k = this.index;
                        if (k < 0) {
                            k = Math.max(0, this.link.getSegmentCount() + k)
                        } else {
                            k = Math.min(k, this.link.getSegmentCount() - 1)
                        }
                        var j = this.link.segmentToPolyline(k);
                        var l = this.pointAlongLength(0.5, j);
                        return new g(l.x + this.horizontalOffset, l.y + this.verticalOffset);
                    case c.ControlPoint:
                        var h = this.index;
                        if (h < 0) {
                            h = Math.max(0, this.link.points.length + h)
                        } else {
                            h = Math.min(h, this.link.points.length - 1)
                        }
                        var l = this.link.points[h];
                        return new g(l.x + this.horizontalOffset, l.y + this.verticalOffset);
                    case c.LinkLength:
                        return this.pointAlongLength(this.horizontalOffset);
                    default:
                        return new g()
                }
            },
            pointAlongLength: function(k, n) {
                if (n == undefined) {
                    n = this.link.getPolyLine(20)
                }
                var h = k * this.getLength(n);
                var s = 0;
                for (var l = 0; l < n.length - 1; ++l) {
                    var q = n[l];
                    var p = n[l + 1];
                    var j = q.distance(p);
                    if (s + j > h) {
                        var t = (p.x - q.x) / j;
                        var r = (p.y - q.y) / j;
                        var o = h - s;
                        return new g(q.x + t * o, q.y + r * o)
                    }
                    s += j
                }
                return n[0]
            },
            getLength: function(h) {
                var n = 0;
                for (var k = 0; k < h.length - 1; ++k) {
                    var l = h[k];
                    var j = h[k + 1];
                    n += l.distance(j)
                }
                return n
            },
            invalidateLayout: function() {
                this.cachedLayoutRect = d.empty
            },
            invalidate: function(h) {
                var j = this.link;
                if (j && this.cachedLayoutRect != d.empty) {
                    j.requestRepaint(this.cachedLayoutRect)
                }
                if (j && j.parent && j.parent.labelsAutoArrange) {
                    j.parent.invalidateLabelLayout(j.getRepaintBounds())
                } else {
                    this.cachedLayoutRect = d.empty
                }
                if (!h && j) {
                    j.invalidate(false)
                }
            },
            updateRect: function(h) {
                this.cachedLayoutRect.setLocation(new g(h.x - this.cachedLayoutRect.width / 2, h.y - this.cachedLayoutRect.height / 2));
                this.text.setBounds(this.cachedLayoutRect, 0);
                return this.cachedLayoutRect
            },
            getTextToEdit: function() {
                return this.text.text
            },
            getEditRect: function() {
                return this.getLayoutRect()
            },
            setEditedText: function(h) {
                this.setText(h)
            },
            createEditArgs: function(h, j) {
                return new a.LinkEventArgs({
                    link: this.link,
                    oldText: h,
                    newText: j,
                    label: this
                })
            },
            getDiagramItem: function() {
                return this.link
            },
            getAutoArrange: function() {
                return this.autoArrange
            },
            setAutoArrange: function(h) {
                if (this.autoArrange != h) {
                    this.autoArrange = h;
                    if (this.autoArrange == true) {
                        this.link.parent.labelsAutoArrange = true
                    }
                    this.invalidate()
                }
            },
            setTextColor: function(h) {
                this.textColor = h;
                this.text.pen = h;
                this.invalidate()
            },
            getTextColor: function() {
                return this.textColor
            },
            setFont: function(h) {
                this.font = h;
                this.text.font = h;
                this.invalidate()
            },
            getFont: function() {
                return this.font
            },
            setText: function(h) {
                if (this.text.text != h) {
                    this.text.text = h;
                    this.invalidate()
                }
            },
            getText: function() {
                return this.text.text
            },
            setHorizontalAlign: function(h) {
                if (this.horizontalAlign != h) {
                    this.horizontalAlign = h;
                    this.invalidate()
                }
            },
            getHorizontalAlign: function() {
                return this.horizontalAlign
            },
            setVerticalAlign: function(h) {
                if (this.verticalAlign != h) {
                    this.verticalAlign = h;
                    this.invalidate()
                }
            },
            getVerticalAlign: function() {
                return this.verticalAlign
            },
            setMargin: function(h) {
                if (this.margin != h) {
                    this.margin = h;
                    this.invalidate()
                }
            },
            getMargin: function() {
                return this.margin
            },
            setBrush: function(h) {
                if (this.brush !== h) {
                    this.brush = h;
                    if (this.link && this.link.parent) {
                        this.link.parent.invalidate()
                    }
                }
            },
            getBrush: function() {
                return this.brush
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.LinkLabel")
    })(MindFusion.Diagramming);
    (function(b) {
        var c = MindFusion.Controls.MouseCursors;
        var a = b.LinkNodesBehavior = function(f, d, e) {
            mflayer.initializeBase(a, this, [f]);
            this.nodeConstructor = d;
            this.linkConstructor = e || function(j, h, g) {
                return new b.DiagramLink(j, h, g)
            }
        };
        a.prototype = {
            setMouseCursor: function(d, e) {
                var f = this.diagram.selection.handleAtPoint(d);
                if (f) {
                    return this.setModfCursor(d, f)
                }
                var h = this.diagram.getHandleAt(d);
                if (h) {
                    return this.setModfCursor(d, h)
                }
                var g = this.diagram.getNodeAt(d, true, true);
                if (g != null && g.acceptLinks(true)) {
                    return this.setCurrentCursor(c.Pointer)
                }
                return this.setCurrentCursor(c.Default)
            },
            createNode: function() {
                return this.nodeConstructor(this.diagram)
            },
            createLink: function(e, d) {
                var f = this.linkConstructor(this.diagram, e, d);
                f.originConnection.chooseBestAnchorPoint(d);
                return f
            },
            createController: function(d) {
                var j = mflayer.callBaseMethod(a, this, "createController", [d]);
                if (j) {
                    return j
                }
                var k = null;
                var f = this.diagram.getNodeAt(d.pointerPosition, true, true);
                if (f != null && f.acceptLinks(true)) {
                    var n = this.createLink(f, d.pointerPosition);
                    k = {
                        item: n,
                        index: n.points.length - 1
                    };
                    j = new b.CreateLinkController(this.diagram, n)
                } else {
                    var o = this.diagram.getAlignToGrid() ? this.diagram.getGridSizeX() : 1;
                    var g = this.diagram.getAlignToGrid() ? this.diagram.getGridSizeY() : 1;
                    var e = this.createNode();
                    var l = this.diagram.alignResize(e, d.pointerPosition, b.AdjustmentHandles.ResizeTopLeft);
                    e.setBounds(new MindFusion.Drawing.Rect(l.x, l.y, o, g));
                    k = {
                        item: e,
                        index: 2
                    };
                    j = new b.CreateNodeController(this.diagram, e);
                    j.convertToShape = this.convertToShape
                }
                return j
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.LinkNodesBehavior", b.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(c) {
        var e = MindFusion.Drawing.GraphicsUnit;
        var b = MindFusion.Drawing.Matrix;
        var a = MindFusion.Collections.ArrayList;
        var d = c.LinkTextRenderer = function(f) {
            mflayer.initializeBase(d, this);
            this.type = this.constructor.__typeName;
            this.link = f;
            this.clearLayout();
            this.transform = new b();
            this.textAlignment = c.Alignment.Near;
            this.lineAlignment = c.Alignment.Near
        };
        d.prototype = {
            getType: function() {
                return this.type
            },
            clone: function() {
                var f = new d(this.link);
                f.transform = this.transform.clone();
                f.textAlignment = this.textAlignment;
                f.lineAlignment = this.lineAlignment;
                return f
            },
            processText: function(f, k) {
                var n = MindFusion.Diagramming.Utils;
                var g = this.ignoreTransform ? 1 : f._mf_scale;
                f.font = this.font.toString(g);
                f.fillStyle = this.pen;
                if (this.stroke) {
                    f.strokeStyle = n.getBrush(f, this.stroke, this.bounds, true)
                }
                f.textAlign = "left";
                if (this.textAlignment == c.Alignment.Center) {
                    f.textAlign = "center"
                } else {
                    if (this.textAlignment == c.Alignment.Far) {
                        f.textAlign = "right"
                    }
                }
                f.textBaseline = "top";
                for (var l = 0; l < this.strings.length; ++l) {
                    var j = this.strings[l];
                    if (j.length == 0) {
                        continue
                    }
                    var o = false;
                    var h = this.angles[l];
                    var q = this.rectangles[l].clone();
                    if (!this.ignoreTransform) {
                        if (f._mf_transform) {
                            q = f._mf_transform.transformRect(q)
                        }
                        f.setTransform(1, 0, 0, 1, 0, 0);
                        f.lineWidth = f.lineWidth * g
                    }
                    if (h && h !== 0) {
                        var p = new b();
                        p.translate(q.x, q.y);
                        p.rotate(h);
                        p.translate(-q.x, -q.y);
                        f.transform.apply(f, p.matrix())
                    }
                    if (this.link.textStyle == c.LinkTextStyle.OverLongestSegment) {
                        var r = this.link.parent;
                        f.fillStyle = r ? n.getBrush(f, r.getEffectiveBackBrush(), q) : "white";
                        var s = q.getSize();
                        s.width += e.getMillimeter(r.measureUnit);
                        s.height += e.getMillimeter(r.measureUnit);
                        if (this.textAlignment == c.Alignment.Center) {
                            f.fillRect(q.x - s.width / 2, q.y, s.width, s.height)
                        } else {
                            if (this.textAlignment == c.Alignment.Far) {
                                f.fillRect(q.x - s.width, q.y, s.width, s.height)
                            } else {
                                f.fillRect(q.x, q.y, q.width, q.height)
                            }
                        }
                        f.fillStyle = this.pen;
                        k(j, q.x, q.y, f, g, h)
                    } else {
                        k(j, q.x, q.y, f, g, h)
                    }
                }
            },
            draw: function(f) {
                f.save();
                this.processText(f, this.drawText.bind(this));
                f.restore()
            },
            drawText: function(q, o, l, h, j) {
                var s = q.split("\n");
                var n = s.length;
                var p = this.font.size * j;
                for (var k = 0; k < n; k++) {
                    if (s[k]) {
                        var g = l + p * k;
                        if (this.stroke) {
                            h.strokeText(s[k], o, g)
                        }
                        h.fillText(s[k], o, g);
                        if (this.font.underline) {
                            g += p * 1.05;
                            var f = h.measureText(s[k]);
                            var r = MindFusion.Drawing.Text.prototype.drawUnderline;
                            r.call(this, h, o, g, f.width)
                        }
                    }
                }
            },
            clearLayout: function() {
                this.rectangles = new a();
                this.angles = new a();
                this.strings = new a()
            },
            createSvgElement: function(j) {
                var g = j.createElementNS("http://www.w3.org/2000/svg", "g");
                var f = {
                    transform: function() {},
                    setTransform: function() {},
                    fillRect: function() {}
                };
                var h = this.font.size;
                this.processText(f, function(q, k, r, n, p, o) {
                    var l = j.createElementNS("http://www.w3.org/2000/svg", "text");
                    l.setAttribute("stroke", "none");
                    l.setAttribute("fill", this.pen);
                    l.setAttribute("style", "font: " + n.font);
                    l.setAttribute("x", k);
                    l.setAttribute("y", r + h);
                    l.setAttribute("transform", "rotate(" + o + " " + k + " " + r + ")");
                    l.textContent = q;
                    g.appendChild(l)
                });
                return g
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.LinkTextRenderer")
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.MagnifyBehavior = function(d, c) {
            mflayer.initializeBase(b, this, [d])
        };
        b.prototype = {
            onMouseDown: function(c) {
                this.diagram.invalidate()
            },
            onMouseMove: function(c) {
                this.diagram.invalidate()
            },
            onMouseUp: function(c) {
                this.diagram.invalidate()
            },
            createController: function(c) {
                return new a.MagnifyController(this.diagram)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.MagnifyBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = MindFusion.Diagramming.ModifierKeyActions;
        var a = b.ModifierKeyActions = function(d, c) {
            mflayer.initializeBase(a, this);
            this.control = b.ModifierKeyAction.Select;
            this.shift = b.ModifierKeyAction.OverrideBehavior;
            this.alt = b.ModifierKeyAction.Pan
        };
        a.prototype = {
            getControl: function() {
                return this.control
            },
            setControl: function(c) {
                this.control = c
            },
            getShift: function() {
                return this.shift
            },
            setShift: function(c) {
                this.shift = c
            },
            getAlt: function() {
                return this.alt
            },
            setAlt: function(c) {
                this.alt = c
            },
            getKeys: function(c, d) {
                if ((this.control == c) && (d.ctrlKey)) {
                    return true
                }
                if ((this.shift == c) && (d.shiftKey)) {
                    return true
                }
                if ((this.alt == c) && (d.altKey)) {
                    return true
                }
                return false
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.ModifierKeyActions")
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Controls.MouseCursors;
        var b = a.ModifyBehavior = function(d) {
            mflayer.initializeBase(b, this, [d])
        };
        b.prototype = {
            setMouseCursor: function(d, e) {
                var f = this.diagram.selection.handleAtPoint(d);
                if (f) {
                    if (mflayer.isInstanceOfType(a.DiagramNode, f.item) && f.index < 8) {
                        return this.setCurrentCursor(this.getResizeCursor(f.index))
                    } else {
                        return this.setCurrentCursor(c.Move)
                    }
                }
                var g = this.diagram.getHandleAt(d);
                if (g) {
                    return this.setModfCursor(d, g)
                }
                return this.setCurrentCursor(c.Default)
            },
            createController: function(e) {
                var d = mflayer.callBaseMethod(b, this, "createController", [e]);
                if (d) {
                    return d
                }
                return new a.CreateSelectionController(this.diagram.selection)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ModifyBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(d) {
        var b = MindFusion.Collections.ArrayList;
        var e = MindFusion.Drawing.Rect;
        var a = MindFusion.Drawing.Size;
        var g = MindFusion.Drawing.GraphicsUnit;
        var h = MindFusion.Drawing.Font;
        var f = MindFusion.Drawing.Point;
        var c = d.NodeListView = function(j) {
            mflayer.initializeBase(c, this, [j]);
            this.bounds = new e(0, 0, j.width, j.height);
            this.measureUnit = MindFusion.Drawing.GraphicsUnit.Pixel;
            this.enabled = true;
            this.items = [];
            this.boxes = [];
            this.captions = [];
            this.padding = 5;
            this.iconSize = new a(24, 24);
            this.defaultNodeSize = new a(24, 24);
            this.captionFont = new MindFusion.Drawing.Font("sans-serif", 12);
            this.defaultShape = "Rectangle";
            this.preventDefaultTouch = true;
            this.eventHandlers = mflayer.eventHandlerList();
            this.orientation = d.Orientation.Vertical;
            this.shapeLibraryLocation = "";
            this.updateLayoutDelegate = mflayer.createDelegate(this, this.updateLayout)
        };
        c.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(c, this, "initialize");
                var j = this.get_element();
                mflayer.addHandlers(j, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                this.mouseMoveDelegate = mflayer.createDelegate(this, this.onMouseMove);
                mflayer.addHandlers(document, {
                    mousemove: this.mouseMoveDelegate
                });
                this.viewMouseMoveDelegate = mflayer.createDelegate(this, this.onViewMouseMove);
                mflayer.addHandlers(j, {
                    mousemove: this.viewMouseMoveDelegate
                });
                this.viewMouseOutDelegate = mflayer.createDelegate(this, this.onViewMouseOut);
                mflayer.addHandlers(j, {
                    mouseout: this.viewMouseOutDelegate
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                });
                j.addEventListener("touchstart", mflayer.createDelegate(this, this.onTouchStart), false);
                j.addEventListener("touchmove", mflayer.createDelegate(this, this.onTouchMove), false);
                j.addEventListener("touchend", mflayer.createDelegate(this, this.onTouchEnd), false);
                j.addEventListener("touchcancel", mflayer.createDelegate(this, this.onTouchEnd), false);
                this.raiseEvent(d.Events.controlLoaded)
            },
            dispose: function() {
                mflayer.removeHandler(document, "mousemove", this.mouseMoveDelegate);
                mflayer.removeHandler(document, "mouseup", this.mouseUpDelegate);
                mflayer.callBaseMethod(c, this, "dispose")
            },
            registerForSubmit: function(l) {
                var k = document.getElementById(l);
                if (k) {
                    var j = k.form;
                    if (j) {
                        j.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: l
                        })))
                    }
                }
            },
            preparePostback: function(k, j) {
                var l = document.getElementById(j.id);
                if (l) {
                    l.value = d.Utils.escapeHtml(this.toJson())
                }
            },
            fromJson: function(l) {
                this.clearAll();
                if (l > "") {
                    var p = mflayer.fromJson(l);
                    if (!this.json && p.shapeLibraryLocation != null && p.shapeLibraryLocation != "") {
                        this.setShapeLibraryLocation(p.shapeLibraryLocation);
                        this.json = l;
                        return
                    }
                    if (p.iconSize != null) {
                        if (p.iconSize.width == 0 && p.iconSize.height == 0) {
                            this.iconSize = null
                        } else {
                            this.iconSize = p.iconSize
                        }
                    }
                    if (p.defaultNodeSize != null) {
                        if (p.defaultNodeSize.width == 0 && p.defaultNodeSize.height == 0) {
                            this.defaultNodeSize = null
                        } else {
                            this.defaultNodeSize = p.defaultNodeSize
                        }
                    }
                    this.padding = p.padding;
                    this.setEnabled(p.enabled);
                    this.setMeasureUnit(p.measureUnit);
                    if (p.backColor !== undefined) {
                        this.setBackColor(p.backColor)
                    }
                    if (p.orientation !== undefined) {
                        this.setOrientation(p.orientation)
                    }
                    if (p.minVisibleFontSize !== undefined) {
                        this.minVisibleFontSize = p.minVisibleFontSize
                    }
                    this.prepareScriptEvent(d.Events.controlLoaded, p.controlLoadedScript);
                    this.prepareScriptEvent(d.Events.nodeSelected, p.nodeSelectedScript);
                    if (p.autoClasses) {
                        for (var q in p.autoClasses) {
                            var n = mflayer.fromJson(p.autoClasses[q]);
                            d.CompositeNode.classFromTemplate(q, n)
                        }
                    }
                    if (p.items instanceof Object) {
                        for (var k = 0; k < p.items.length; k++) {
                            if (p.items[k]) {
                                var o = this.loadItem(p.items[k], k);
                                var j = "";
                                if (p.captions instanceof Object) {
                                    j = p.captions[k] || ""
                                }
                                this.addNode(o, j)
                            }
                        }
                    }
                }
                this.raiseEvent(d.Events.controlLoaded);
                this.invalidate()
            },
            loadItem: function(n, j) {
                var k = mflayer.parseType(n.__type || n.type);
                if (!k) {
                    return null
                }
                if (mflayer.inheritsFrom(k, d.DiagramNode)) {
                    var l = new k(this);
                    l.fromJson(n);
                    return l
                }
            },
            toJson: function() {
                var l = this.get_element().parentNode;
                var k = mflayer.getBounds(l);
                var j = {
                    id: this.get_element().id,
                    width: k.width,
                    height: k.height,
                    items: this.serializeItems(),
                    captions: this.serializeCaptions(),
                    iconSize: this.iconSize == null ? new a(0, 0) : this.iconSize,
                    defaultNodeSize: this.defaultNodeSize == null ? new a(0, 0) : this.defaultNodeSize,
                    enabled: this.enabled,
                    measureUnit: this.measureUnit,
                    padding: this.padding,
                    orientation: this.orientation,
                    minVisibleFontSize: this.minVisibleFontSize
                };
                return mflayer.toJson(j)
            },
            serializeItems: function() {
                var j = [];
                for (var o = 0, k = this.items.length; o < k; o++) {
                    var n = this.items[o].toJson();
                    j.push(n)
                }
                return j
            },
            serializeCaptions: function() {
                var j = [];
                for (var n = 0, k = this.captions.length; n < k; n++) {
                    var o = this.captions[n].text;
                    j.push(o)
                }
                return j
            },
            raiseEvent: function(j, k) {
                var l = mflayer.getHandler(this, j);
                if (l != null) {
                    l(this, k)
                }
            },
            clearAll: function() {
                this.items = [];
                this.elements = [];
                this.captions = [];
                this.updateSize()
            },
            repaint: function() {
                this.get_element().width = this.get_element().width;
                this.context.save();
                var k = new MindFusion.Drawing.Matrix();
                k.scale(this.scale, this.scale);
                this.context._mf_transform = k;
                this.context.transform.apply(this.context, k.matrix());
                this.context.lineWidth = 1 / this.scale;
                this.context._mf_scale = this.scale;
                this.context._mf_minVisibleFontSize = this.minVisibleFontSize;
                for (var n = 0, j = this.elements.length; n < j; n++) {
                    this.elements[n].draw(this.context)
                }
                this.context.restore();
                if (this.repaintId) {
                    clearTimeout(this.repaintId);
                    this.repaintId = null
                }
            },
            updateCanvasSize: function() {
                var o = 0;
                if (this.captions.length > 0) {
                    for (var n = 0, j = this.captions.length; n < j; n++) {
                        var q = this.brth(this.measureString(this.captions[n].text, this.captionFont));
                        o = Math.max(o, q)
                    }
                }
                var p = this.brth(mflayer.getBounds(this.get_element().parentNode));
                var q = (this.brth(this.getItemsSize()) + o + this.padding * 3) * this.scale;
                var k = Math.max(q, p) - 2;
                this.brth(this.get_element(), k);
                for (var n = 0, j = this.boxes.length; n < j; n++) {
                    this.brth(this.boxes[n], k)
                }
                this.updateSize()
            },
            invalidateLayout: function() {
                if (!this.updateLayoutId) {
                    this.updateLayoutId = setTimeout(this.updateLayoutDelegate, 20)
                }
            },
            updateLayout: function() {
                var t = new a(0, 0);
                for (var p = 0, o = this.items.length; p < o; p++) {
                    var w = this.iconSize != null ? this.iconSize : this.items[p].getRotatedBounds().getSize();
                    this.items[p].removeCanvasElements();
                    this.removeElement(this.boxes[p]);
                    this.removeElement(this.items[p].text);
                    var s = e.fromPositionAndSize(this.listCoords(this.padding + (this.len(t) + p * this.padding * 2), this.padding), w);
                    if (this.iconSize != null) {
                        this.items[p].setBounds(s)
                    } else {
                        this.items[p].getBounds().setLocation(s.topLeft())
                    }
                    var n = this.items[p].getRotationAngle();
                    if (n != 0) {
                        var k = this.items[p].getBounds();
                        var j = MindFusion.Diagramming.Utils.rotateRect(k, k.center(), n);
                        var v = j.x - s.x;
                        var u = j.y - s.y;
                        var r = new f(s.x - v, s.y - u);
                        this.items[p].getBounds().setLocation(r)
                    }
                    var q = e.fromPositionAndSize(this.listCoords(this.padding + (this.len(t) + p * this.padding * 2), this.brth(w) + this.padding * 2), this.listSize(this.len(w), this.brth(this.get_element()) - (this.brth(w) + this.padding)));
                    this.captions[p].setBounds(q);
                    var s = e.fromPositionAndSize(this.listCoords((this.len(t) + p * this.padding * 2), 0), this.listSize(this.len(w) + this.padding * 2, this.brth(this.get_element())));
                    this.boxes[p].x = s.x;
                    this.boxes[p].y = s.y;
                    this.boxes[p].width = s.width;
                    this.boxes[p].height = s.height;
                    this.items[p].addCanvasElements();
                    this.addElement(this.boxes[p]);
                    this.addElement(this.items[p].text);
                    t.width += w.width;
                    t.height += w.height
                }
                this.updateCanvasSize();
                if (this.updateLayoutId) {
                    clearTimeout(this.updateLayoutId);
                    this.updateLayoutId = null
                }
            },
            updateSize: function() {
                var j = (this.iconSize != null) ? this.items.length * this.scale * (this.len(this.iconSize) + 2 * this.padding) : this.scale * (this.len(this.getItemsSize()) + this.items.length * 2 * this.padding);
                this.len(this.get_element(), j);
                this.invalidate()
            },
            getItemsSize: function() {
                var n = new a(0, 0);
                for (var k = 0, j = this.items.length; k < j; k++) {
                    var o = this.items[k].getRotatedBounds();
                    n.height += o.height;
                    n.width += o.width
                }
                return n
            },
            addNode: function(l, j) {
                if (l != undefined) {
                    b.add(this.items, l);
                    l.parent = this;
                    l.addCanvasElements();
                    var k = new e();
                    k.brush = {
                        type: "SolidBrush",
                        color: "transparent"
                    };
                    k.pen = "transparent";
                    this.boxes.push(k);
                    this.addElement(k);
                    var n = l.text.clone();
                    n.text = (j != undefined) ? j : "";
                    n.font = this.captionFont;
                    if (this.orientation == d.Orientation.Horizontal) {
                        n.textAlignment = d.Alignment.Center;
                        n.lineAlignment = d.Alignment.Near
                    } else {
                        n.textAlignment = d.Alignment.Near;
                        n.lineAlignment = d.Alignment.Center
                    }
                    n.fitInBounds = true;
                    b.add(this.captions, n);
                    this.addElement(n);
                    this.invalidateLayout()
                }
            },
            listCoords: function(j, k) {
                return this.orientation == d.Orientation.Horizontal ? {
                    x: j,
                    y: k
                } : {
                    x: k,
                    y: j
                }
            },
            listSize: function(j, k) {
                return this.orientation == d.Orientation.Horizontal ? {
                    width: j,
                    height: k
                } : {
                    width: k,
                    height: j
                }
            },
            len: function(j, k) {
                if (k === undefined) {
                    return this.orientation == d.Orientation.Horizontal ? j.width : j.height
                } else {
                    if (this.orientation == d.Orientation.Horizontal) {
                        j.width = k
                    } else {
                        j.height = k
                    }
                }
            },
            brth: function(j, k) {
                if (k === undefined) {
                    return this.orientation == d.Orientation.Horizontal ? j.height : j.width
                } else {
                    if (this.orientation == d.Orientation.Horizontal) {
                        j.height = k
                    } else {
                        j.width = k
                    }
                }
            },
            getBoxAt: function(j) {
                for (var k = 0; k < this.boxes.length; k++) {
                    if (this.boxes[k].containsPoint(j)) {
                        return this.boxes[k]
                    }
                }
            },
            getNodeAt: function(j) {
                var l = this.getBoxAt(j);
                var k = b.indexOf(this.boxes, l);
                return this.items[k]
            },
            selectBox: function(n) {
                for (var k = 0, j = this.boxes.length; k < j; k++) {
                    if (this.boxes[k] === n) {
                        this.draggedNode = this.items[k].clone();
                        document.body.style.cursor = "pointer";
                        this.boxes[k].pen = "#3366CC";
                        this.boxes[k].brush = {
                            type: "SolidBrush",
                            color: "rgba(51,102,204,0.2)"
                        }
                    } else {
                        this.boxes[k].pen = "transparent";
                        this.boxes[k].brush = {
                            type: "SolidBrush",
                            color: "transparent"
                        }
                    }
                }
                this.invalidate()
            },
            selectItem: function(l) {
                var j = b.indexOf(this.items, l);
                var k = this.boxes[j];
                this.selectBox(k);
                this.raiseEvent(d.Events.nodeSelected, new d.NodeEventArgs({
                    node: l
                }))
            },
            getNodes: function() {
                return this.items
            },
            setDefaultNodeSize: function(j) {
                this.defaultNodeSize = j;
                this.invalidateLayout();
                this.invalidate()
            },
            getDefaultNodeSize: function() {
                return this.defaultNodeSize
            },
            setIconSize: function(j) {
                this.iconSize = j;
                this.invalidateLayout();
                this.invalidate()
            },
            getIconSize: function() {
                return this.iconSize
            },
            setOrientation: function(j) {
                this.orientation = j;
                this.invalidateLayout();
                if (this.orientation == d.Orientation.Horizontal) {
                    this.get_element().parentNode.style.overflowX = "auto";
                    this.get_element().parentNode.style.overflowY = "hidden"
                } else {
                    this.get_element().parentNode.style.overflowX = "hidden";
                    this.get_element().parentNode.style.overflowY = "auto"
                }
                this.invalidate()
            },
            getOrientation: function() {
                return this.orientation
            },
            setPadding: function(j) {
                this.padding = j;
                this.invalidateLayout();
                this.invalidate()
            },
            getPadding: function() {
                return this.padding
            },
            getEffectiveBackBrush: function() {
                return this.backBrush
            },
            setEnabled: function(j) {
                this.enabled = j
            },
            getEnabled: function() {
                return this.enabled
            },
            getBackColor: function() {
                return this.backColor
            },
            setBackColor: function(j) {
                this.backColor = j;
                this.get_element().parentNode.style.backgroundColor = this.backColor
            },
            setShapeLibraryLocation: function(k) {
                if (this.shapeLibraryLocation != k) {
                    this.shapeLibraryLocation = k;
                    if (this.shapeLibraryLocation != null && this.shapeLibraryLocation != "") {
                        try {
                            d.Shape.loadFromLibPending = true;
                            new d.ShapeLibrary().loadFromXml(this.shapeLibraryLocation, mflayer.createDelegate(this, this.onShapeLibraryLoad), mflayer.createDelegate(this, this.onShapeLibraryError))
                        } catch (j) {
                            d.Shape.loadFromLibPending = false;
                            throw j
                        }
                    } else {
                        d.Shape.loadFromLibPending = false
                    }
                }
            },
            getShapeLibraryLocation: function() {
                return this.shapeLibraryLocation
            },
            onShapeLibraryLoad: function() {
                this.fromJson(this.json);
                delete this.json;
                d.Shape.loadFromLibPending = false;
                this.invalidate()
            },
            onShapeLibraryLoaded: function(j) {
                d.Shape.loadFromLibPending = false;
                b.forEach(this.items, function(k) {
                    if (k.onShapeLoaded) {
                        k.onShapeLoaded()
                    }
                })
            },
            onShapeLibraryError: function() {
                this.fromJson(this.json);
                delete this.json;
                d.Shape.loadFromLibPending = false;
                this.invalidate()
            },
            getDraggedNode: function() {
                return this.draggedNode
            },
            setTooltipDelay: function(j) {
                if (this.tooltipDelay !== j) {
                    this.tooltipDelay = j
                }
            },
            getTooltipDelay: function() {
                return this.tooltipDelay != undefined ? this.tooltipDelay : 1000
            },
            onMouseDown: function(j) {
                if (!this.enabled) {
                    return
                }
                if (j.button === 0) {
                    this.onMouseLeftButtonDown(j)
                }
            },
            onMouseLeftButtonDown: function(l) {
                var n = MindFusion.Diagramming.Utils.getCursorPos(l, this.get_element());
                this.draggedNode = null;
                var k = this.getBoxAt(this.clientToDoc(n));
                if (k) {
                    this.selectBox(k);
                    var j = b.indexOf(this.boxes, k);
                    this.raiseEvent(d.Events.nodeSelected, new d.NodeEventArgs({
                        node: this.items[j]
                    }));
                    l.preventDefault()
                }
                this.invalidate()
            },
            targetAsDiagram: function(k) {
                if (k.target.nodeType === 1) {
                    if (k.target.id) {
                        var j = mflayer.findControl(k.target.id);
                        if (j != null) {
                            if (mflayer.isInstanceOfType(d.Diagram, j)) {
                                return j
                            }
                        }
                    }
                }
                return null
            },
            onMouseMove: function(o) {
                if (!this.enabled) {
                    return
                }
                var p = MindFusion.Diagramming.Utils.getCursorPos(o, this.get_element());
                var j = this.clientToDoc(p);
                var l = this.draggedNode;
                if (l != null) {
                    var n = this.targetAsDiagram(o);
                    if (n != null) {
                        n.stopCursorChange = true;
                        var p = MindFusion.Diagramming.Utils.getCursorPos(o, n.get_element());
                        var j = n.clientToDoc(p);
                        if (!n.raiseCreating(l, {
                                currentPoint: j,
                                cancelNow: new Function()
                            }) || !n.onItemDragging(l, j)) {
                            n.get_element().style.cursor = "not-allowed"
                        } else {
                            n.get_element().style.cursor = "pointer"
                        }
                    }
                    document.body.style.cursor = "pointer";
                    var k = mflayer.findControl(this.get_element().id + "_shapeCanvas");
                    if (!k) {
                        k = this.addDragShape()
                    }
                    var q = d.Utils.getClientPos(o);
                    k.get_element().style.left = q.x + 5 + "px";
                    k.get_element().style.top = q.y - 20 + "px"
                } else {
                    document.body.style.cursor = "default";
                    this.removeDragShape()
                }
            },
            onViewMouseMove: function(n) {
                if (!this.enabled) {
                    return
                }
                this.clearTooltip();
                if (!this.draggedNode) {
                    var p = MindFusion.Diagramming.Utils.getCursorPos(n, this.get_element());
                    var j = this.clientToDoc(p);
                    var k = this.docToClient(j);
                    var l = mflayer.getBounds(this._element);
                    this.tooltipX = k.x + l.x;
                    this.tooltipY = k.y + l.y;
                    this.tooltipPoint = j;
                    var o = this;
                    this.tooltipTimeoutId = setTimeout(function() {
                        return o.onTooltip()
                    }, this.getTooltipDelay())
                }
            },
            onViewMouseOut: function(j) {
                this.clearTooltip()
            },
            onTooltip: function() {
                var k = this.getNodeAt(this.tooltipPoint);
                if (k) {
                    var l = k.getTooltip(this.tooltipPoint);
                    if (!l) {
                        return
                    }
                    var j = this.get_element().id + "_tooltip";
                    var n = this.tooltipDiv = document.createElement("div");
                    document.body.appendChild(n);
                    n.setAttribute("id", j);
                    n.innerHTML = l;
                    n.style.left = this.tooltipX + 20 + "px";
                    n.style.top = this.tooltipY + "px";
                    n.style.width = "auto";
                    n.style.position = "absolute";
                    n.style.display = "block";
                    n.style.background = "white";
                    n.style.border = "solid 1px";
                    n.style.zIndex = 2
                }
            },
            clearTooltip: function() {
                if (this.tooltipTimeoutId) {
                    clearTimeout(this.tooltipTimeoutId)
                }
                if (this.tooltipDiv) {
                    document.body.removeChild(this.tooltipDiv);
                    this.tooltipDiv = null
                }
            },
            removeDragShape: function() {
                var j = mflayer.findControl(this.get_element().id + "_shapeCanvas");
                if (j) {
                    j.get_element().parentNode.removeChild(j.get_element());
                    j.dispose()
                }
            },
            addDragShape: function() {
                var n = new e(0, 0, 20, 20);
                var j = document.createElement("canvas");
                j.id = this.get_element().id + "_shapeCanvas";
                j.width = n.width;
                j.height = n.height;
                j.style.position = "absolute";
                j.style.zIndex = 9999;
                document.body.appendChild(j);
                var k = mflayer.createControl(MindFusion.Drawing.Canvas, null, null, null, j);
                k.scale = 1;
                k.repaint = this.repaint;
                k.setBounds(n);
                var l = this.draggedNode.clone();
                l.shadowColor = "transparent";
                l.parent = k;
                l.setBounds(n);
                l.addCanvasElements();
                k.repaint();
                return k
            },
            onMouseUp: function(j) {
                if (!this.enabled) {
                    return
                }
                if (j.button === 0) {
                    this.onMouseLeftButtonUp(j)
                }
            },
            onMouseLeftButtonUp: function(o) {
                if (this.draggedNode == null) {
                    return
                }
                var n = this.targetAsDiagram(o);
                if (n != null) {
                    var l = this.draggedNode;
                    this.scaleFont(l, n);
                    this.scaleStrokeThickness(l, n);
                    var k = this.defaultNodeSize;
                    if (k == null) {
                        k = l.getBounds().getSize()
                    }
                    var p = MindFusion.Diagramming.Utils.getCursorPos(o, n.get_element());
                    var j = n.clientToDoc(p);
                    if (n.onItemDragging(l, j) && n.raiseCreating(l, {
                            currentPoint: j,
                            cancelNow: new Function()
                        })) {
                        l.setBounds(e.fromCenterAndSize(j, k));
                        l.setParent(n);
                        if (l.expandButton) {
                            l.expandButton.updateContent();
                            l.expandButton.updateLocation()
                        }
                        if (l.scroller) {
                            l.scroller.updateContent();
                            l.scroller.updateLocation()
                        }
                        if (l.folder) {
                            l.folder.updateContent();
                            l.folder.updateLocation()
                        }
                        n.addItem(l);
                        n.raiseCreated(l);
                        n.onItemDropped(l, j);
                        n.invalidate()
                    }
                    n.get_element().style.cursor = "default"
                }
                document.body.style.cursor = "default";
                this.draggedNode = null;
                this.removeDragShape()
            },
            scaleFont: function(k, l) {
                if (k.font) {
                    if (k.font.size) {
                        var j = (k.font.size * g.getPixel(l.measureUnit));
                        k.font.size = j
                    }
                } else {
                    if (k.style) {
                        if (k.style.fontSize) {
                            var j = (k.style.fontSize * g.getPixel(l.measureUnit));
                            k.font = new h(k.style.fontName || "sans-serif", j, false, false)
                        }
                    }
                }
            },
            scaleStrokeThickness: function(j, k) {
                if (j.style) {
                    if (j.style.strokeThickness) {
                        j.style.strokeThickness = g.convert(j.style.strokeThickness, k.measureUnit, g.Pixel)
                    }
                }
            },
            emulateMouse: function(o) {
                var q = this.get_element().parentNode;
                var k = mflayer.getBounds(q);
                var p = window.pageXOffset;
                var n = window.pageYOffset;
                var l = o.touches;
                var j = {
                    button: 0,
                    clientX: l[0].clientX - p,
                    clientY: l[0].clientY - n
                };
                return j
            },
            onTouchStart: function(k) {
                var j = k.touches;
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch = this.emulateMouse(k);
                    this.onMouseLeftButtonDown(this.lastTouch);
                    k.preventDefault()
                }
            },
            onTouchMove: function(k) {
                var j = k.touches;
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch = this.emulateMouse(k);
                    this.onMouseMove(this.lastTouch);
                    k.preventDefault()
                }
            },
            onTouchEnd: function(j) {
                if (this.preventDefaultTouch && this.targetView) {
                    this.lastTouch.target = this.targetView;
                    this.onMouseLeftButtonUp(this.lastTouch);
                    this.lastTouch = new Date()
                }
            },
            setTargetView: function(j) {
                this.targetView = j
            },
            prepareScriptEvent: function(k, j) {
                if (!j || j == "") {
                    return
                }
                var l = new Function("sender", "args", "return " + j + "(sender, args)");
                this.addEventListener(k, l)
            },
            addEventListener: function(j, k) {
                mflayer.addHandler(this, j, k)
            }
        };
        MindFusion.Diagramming.NodeListView.create = function(j) {
            return mflayer.createControl(MindFusion.Diagramming.NodeListView, null, null, null, j)
        };
        MindFusion.Diagramming.NodeListView.find = function(j, k) {
            return mflayer.findControl(j, k)
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.NodeListView", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = MindFusion.Collections.ArrayList;
        var d = MindFusion.Drawing.Point;
        var c = MindFusion.Drawing.Rect;
        var e = b.Overview = function(f) {
            mflayer.initializeBase(e, this, [f]);
            this.enabled = true;
            this.diagramId = "";
            this.backColor = "#FFFFFF";
            this.scaleFactor = 0.3;
            this.scaleMode = b.ScaleMode.FitAll;
            this.allowZoom = false;
            this.zooming = false;
            this.nofitScaleFactor = 0.3;
            this.eventHandlers = mflayer.eventHandlerList();
            this.scrollZoneSize = 25;
            this.autoScrollAmount = 0
        };
        e.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(e, this, "initialize");
                this.mouseMoveDelegate = mflayer.createDelegate(this, this.onMouseMove);
                mflayer.addHandlers(document, {
                    mousemove: this.mouseMoveDelegate
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                });
                this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                mflayer.addHandlers(window, {
                    resize: this.resizeDelegate
                });
                mflayer.addHandlers(this.get_element(), {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                mflayer.addHandlers(this.get_element(), {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(this.get_element(), {
                    mouseup: mflayer.createDelegate(this, this.onMouseUp)
                })
            },
            dispose: function() {
                mflayer.removeHandler(document, "mousemove", this.mouseMoveDelegate);
                mflayer.removeHandler(document, "mouseup", this.mouseUpDelegate);
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(e, this, "dispose")
            },
            registerForSubmit: function(h) {
                var g = document.getElementById(h);
                if (g) {
                    var f = g.form;
                    if (f) {
                        f.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: h
                        })))
                    }
                }
            },
            setDiagram: function(f) {
                this.diagram = f;
                if (f) {
                    this.diagramId = f.get_element().id;
                    f.addEventListener(b.Events.repaint, mflayer.createDelegate(this, this.onDiagramRepaint));
                    f.addEventListener(b.Events.sizeChanged, mflayer.createDelegate(this, this.onResize));
                    this.init()
                }
            },
            preparePostback: function(g, f) {
                var h = document.getElementById(f.id);
                if (h) {
                    h.value = this.toJson()
                }
            },
            fromJson: function(f) {
                if (f > "") {
                    var g = mflayer.fromJson(f);
                    if (g.diagramView) {
                        this.diagramId = g.diagramView;
                        this.setDimColor(g.dimColor);
                        this.setBackColor(g.backColor);
                        this.setEnabled(g.enabled);
                        this.setScaleMode(g.scaleMode);
                        this.setScaleFactor(g.scaleFactor);
                        this.setAllowZoom(g.allowZoom);
                        this.setAutoScrollAmount(g.autoScrollAmount);
                        this.setMinVisibleFontSize(g.minVisibleFontSize);
                        this.prepareScriptEvent(b.Events.controlLoaded, g.controlLoadedScript);
                        var h = this;
                        setTimeout(function() {
                            return h.prepare()
                        }, 100)
                    }
                }
            },
            prepare: function() {
                this.setDiagram(b.Diagram.find(this.diagramId));
                this.diagram.invalidate();
                this.invalidate()
            },
            toJson: function() {
                var h = this.get_element().parentNode;
                var g = mflayer.getBounds(h);
                var f = {
                    id: this.get_element().id,
                    width: g.width,
                    height: g.height,
                    enabled: this.enabled,
                    diagramView: this.diagramId,
                    dimColor: this.dimColor,
                    backColor: this.backColor,
                    scaleMode: this.scaleMode,
                    scaleFactor: this.scaleFactor * 100,
                    allowZoom: this.allowZoom,
                    autoScrollAmount: this.autoScrollAmount,
                    minVisibleFontSize: this.minVisibleFontSize
                };
                return mflayer.toJson(f)
            },
            getViewport: function() {
                var h = this.get_element().parentNode;
                var g = new d(h.scrollLeft, h.scrollTop);
                var f = new d(h.scrollLeft + h.offsetWidth, h.scrollTop + h.offsetHeight);
                return c.fromPoints(g, f)
            },
            fit: function() {
                if (this.scaleMode != b.ScaleMode.FitAll) {
                    return
                }
                if (this.diagram == null) {
                    return
                }
                var f = mflayer.getBounds(this.diagram.sizeElement());
                f.width = f.width * 100 / this.diagram.zoomFactor;
                f.height = f.height * 100 / this.diagram.zoomFactor;
                var g = new MindFusion.Drawing.Size(this.get_element().parentNode.clientWidth, this.get_element().parentNode.clientHeight);
                this.scaleFactor = Math.min(g.width / f.width, g.height / f.height)
            },
            init: function() {
                if (this.diagram == null) {
                    return
                }
                var j = document.getElementById(this.diagramId).parentNode;
                var l = mflayer.getBounds(j);
                var h = mflayer.getBounds(this.diagram.sizeElement());
                this.bounds = new MindFusion.Drawing.Rect(this.diagram.bounds.x, this.diagram.bounds.y, h.width / this.diagram.scale, h.height / this.diagram.scale);
                h.width = h.width * 100 / this.diagram.zoomFactor;
                h.height = h.height * 100 / this.diagram.zoomFactor;
                var n = new MindFusion.Drawing.Size(this.get_element().parentNode.clientWidth, this.get_element().parentNode.clientHeight);
                var f = this.shrinkToFit(h.width, h.height, n.width, n.height);
                var g = this.get_element();
                g.width = f.width;
                g.height = f.height;
                g.style.width = f.width + "px";
                g.style.height = f.height + "px";
                g.style.marginLeft = (n.width - f.width) / 2 + "px";
                g.style.marginTop = (n.height - f.height) / 2 + "px";
                this.fit();
                if (this.scaleMode != b.ScaleMode.FitAll) {
                    this.recalculateCanvas()
                }
                var k = j.offsetHeight - j.clientHeight;
                var o = {
                    width: (l.width - k) / this.diagram.scale,
                    height: (l.height - k) / this.diagram.scale
                };
                this.trackerRect = new MindFusion.Drawing.Rect(0, 0, o.width, o.height);
                this.trackerRect.brush = {
                    type: "SolidBrush",
                    color: "rgba(204,204,204,0.2)"
                };
                this.trackerRect.pen = "#000000";
                this.trackerRect.overview = this;
                this.resizerWidth = 12;
                this.resizerHeight = 12;
                mflayer.addHandlers(this.diagram.scrollElement(), {
                    scroll: mflayer.createDelegate(this, this.onScroll)
                });
                this.setTrackerPosition();
                this.onDiagramRepaint(this.diagram);
                this.raiseEvent(b.Events.controlLoaded)
            },
            recalculateCanvas: function() {
                if (!this.diagram) {
                    return
                }
                var g = mflayer.getBounds(this.diagram.sizeElement());
                var f = this.get_element();
                f.width = g.width * this.scaleFactor;
                f.height = g.height * this.scaleFactor;
                if (this.scaleMode == b.ScaleMode.FixedScale) {
                    f.width /= this.diagram.getZoomFactor() / 100;
                    f.height /= this.diagram.getZoomFactor() / 100
                }
                f.style.width = f.width + "px";
                f.style.height = f.height + "px";
                f.parentNode.style.overflow = "scroll";
                f.parentNode.style.overflowY = "scroll"
            },
            onDiagramRepaint: function(h, f) {
                var g = f ? f.clipRect : null;
                this.scale = 1 / MindFusion.Drawing.GraphicsUnit.getPixel(h.measureUnit) * this.scaleFactor;
                if (this.scaleMode == b.ScaleMode.CombinedScales) {
                    this.scale *= this.diagram.getZoomFactor() / 100
                }
                this.elements = this.cachedZOrder = a.clone(h.getZOrder());
                if (this.trackerRect) {
                    this.elements.push(this.trackerRect)
                }
                if (this.trackerRect) {
                    this.trackerRect.draw = function(l, k) {
                        l.save();
                        l.transform.apply(l, this.transform.matrix());
                        l.beginPath();
                        l.rect(this.x, this.y, this.width, this.height);
                        l.save();
                        if (this.shadow && k != false) {
                            this.shadow.apply(l)
                        }
                        if (this.brush) {
                            l.fillStyle = MindFusion.Diagramming.Utils.getBrush(l, this.brush, this.getBounds());
                            l.fill()
                        }
                        l.restore();
                        if (this.pen) {
                            l.strokeStyle = this.pen;
                            l.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / l._mf_scale;
                            MindFusion.Drawing.DashStyle.apply(l, this.strokeDashStyle);
                            l.stroke()
                        }
                        var q = this.overview.getTrackerResizer();
                        if (this.pen && this.overview.allowZoom && this.overview.scaleMode != b.ScaleMode.CombinedScales) {
                            var o = q.x;
                            var n = q.y;
                            var p = q.width;
                            var j = q.height;
                            l.moveTo(o + p, n);
                            l.lineTo(o, n + j);
                            l.moveTo(o + p, n + j / 3);
                            l.lineTo(o + p / 3, n + j);
                            l.moveTo(o + p, n + 2 * j / 3);
                            l.lineTo(o + 2 * p / 3, n + j);
                            l.stroke()
                        }
                        l.restore()
                    }
                }
                this.invalidate(g)
            },
            getTrackerResizer: function() {
                var g = this.resizerWidth / this.scale;
                var f = this.resizerHeight / this.scale;
                return new MindFusion.Drawing.Rect(this.trackerRect.right() - g, this.trackerRect.bottom() - f, g, f)
            },
            raiseEvent: function(f, g) {
                var h = mflayer.getHandler(this, f);
                if (h != null) {
                    h(this, g)
                }
            },
            onMouseDown: function(j) {
                if (!this.enabled) {
                    return
                }
                var l = this.currentMousePoint = b.Utils.getCursorPos(j, this.get_element());
                var h = this.clientToDoc(l);
                var k = this;
                this.scrollTimeoutId = setInterval(function() {
                    k.autoScrollIfNeeded()
                }, 100);
                var o = this.getTrackerResizer();
                if (this.allowZoom && o && o.containsPoint(h) && this.scaleMode != b.ScaleMode.CombinedScales) {
                    this.resizeEnabled = true;
                    this.trackerW = this.trackerRect.width;
                    this.trackerH = this.trackerRect.height;
                    this.initialZoomFactor = this.diagram.getZoomFactor();
                    this.startX = h.x - o.x;
                    this.startY = h.y - o.y;
                    this.savedScrollX = this.diagram.getScrollX();
                    this.savedScrollY = this.diagram.getScrollY();
                    j.preventDefault()
                } else {
                    if (this.trackerRect && this.trackerRect.containsPoint(h)) {
                        this.startX = h.x - this.trackerRect.x;
                        this.startY = h.y - this.trackerRect.y;
                        this.startDrag = true;
                        j.preventDefault()
                    } else {
                        var g = Math.floor(h.x - this.trackerRect.width / 2);
                        var n = Math.floor(h.y - this.trackerRect.height / 2);
                        this.tryMoveTracker(g, n);
                        var f = this.scrollPosFromTracker();
                        if (this.diagram) {
                            this.diagram.scrollElement().scrollLeft = f.x;
                            this.diagram.scrollElement().scrollTop = f.y
                        }
                    }
                }
            },
            onMouseMove: function(j) {
                if (!this.enabled) {
                    return
                }
                this.changeCursor(j);
                this.currentMousePoint = b.Utils.getCursorPos(j, this.get_element());
                if (this.allowZoom) {
                    var f = this.clientToDoc(this.currentMousePoint);
                    if (this.resizeEnabled) {
                        var h = f.x - this.startX;
                        var g = f.y - this.startY;
                        this.zooming = true;
                        this.tryMoveTrackerResizer(h, g);
                        this.invalidate();
                        this.zooming = false;
                        return false
                    }
                }
                this.moveTrackerRectIfExists()
            },
            moveTrackerRectIfExists: function() {
                if (this.trackerRect) {
                    if (this.startDrag) {
                        var g = this.clientToDoc(this.currentMousePoint);
                        this.tryMoveTracker(Math.floor(g.x - this.startX), Math.floor(g.y - this.startY));
                        var f = this.scrollPosFromTracker();
                        if (this.diagram) {
                            this.diagram.scrollElement().scrollLeft = f.x;
                            this.diagram.scrollElement().scrollTop = f.y
                        }
                        return false
                    }
                }
            },
            onMouseLeave: function(f) {
                if (!this.enabled) {
                    return
                }
                this.startDrag = false;
                this.resizeEnabled = false
            },
            autoScrollIfNeeded: function() {
                var g = this.getViewport();
                if (g.width > this.scrollZoneSize * 2) {
                    g = b.Utils.inflate(g, -this.scrollZoneSize, 0)
                }
                if (g.height > this.scrollZoneSize * 2) {
                    g = b.Utils.inflate(g, 0, -this.scrollZoneSize)
                }
                var f = !g.containsPoint(this.currentMousePoint);
                if (f) {
                    var h = this.autoScrollAmount > 0 ? this.autoScrollAmount : 4;
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (this.currentMousePoint.x < g.left()) {
                        this.autoScrDX = -h
                    }
                    if (this.currentMousePoint.y < g.top()) {
                        this.autoScrDY = -h
                    }
                    if (this.currentMousePoint.x > g.right()) {
                        this.autoScrDX = h
                    }
                    if (this.currentMousePoint.y > g.bottom()) {
                        this.autoScrDY = h
                    }
                    this.onAutoScroll()
                }
            },
            onScroll: function(f) {
                if (!this.enabled) {
                    return
                }
                if (!this.startDrag && !this.resizeEnabled) {
                    this.setTrackerPosition()
                }
            },
            checkAutoScroll: function(h) {
                var g = this.getViewport();
                if (g.width > this.scrollZoneSize * 2) {
                    g = b.Utils.inflate(g, -this.scrollZoneSize, 0)
                }
                if (g.height > this.scrollZoneSize * 2) {
                    g = b.Utils.inflate(g, 0, -this.scrollZoneSize)
                }
                var f = !g.containsPoint(h);
                if (f) {
                    var k = this.autoScrollAmount > 0 ? this.autoScrollAmount : 4;
                    this.autoScrDX = 0;
                    this.autoScrDY = 0;
                    if (h.x < g.left()) {
                        this.autoScrDX = -k
                    }
                    if (h.y < g.top()) {
                        this.autoScrDY = -k
                    }
                    if (h.x > g.right()) {
                        this.autoScrDX = k
                    }
                    if (h.y > g.bottom()) {
                        this.autoScrDY = k
                    }
                    this.onAutoScroll();
                    if (!this.scrollTimeoutId) {
                        var j = this;
                        this.scrollTimeoutId = setInterval(function() {
                            j.onAutoScroll()
                        }, 100)
                    }
                } else {
                    if (this.scrollTimeoutId) {
                        this.stopAutoScroll();
                        this.invalidate()
                    }
                }
                return f
            },
            stopAutoScroll: function() {
                if (this.scrollTimeoutId) {
                    clearInterval(this.scrollTimeoutId);
                    delete this.scrollTimeoutId
                }
            },
            onAutoScroll: function() {
                var g = this.getViewport();
                if (this.scroller) {
                    g.width -= this.getScrollbarSize(0);
                    g.height -= this.getScrollbarSize(1)
                }
                var h = this.getScrollX(),
                    f = this.getScrollY();
                if (g.width < this.bounds.width) {
                    h += this.autoScrDX;
                    this.currentMousePoint.x += this.autoScrDX
                }
                if (g.height < this.bounds.height) {
                    f += this.autoScrDY;
                    this.currentMousePoint.y += this.autoScrDY
                }
                this.scrollStayInDoc(h, f, g, this.bounds);
                this.moveTrackerRectIfExists();
                this.invalidate()
            },
            scrollStayInDoc: function(k, j, h, l) {
                if (!l) {
                    l = this.bounds
                }
                if (k < l.left()) {
                    k = l.left()
                }
                if (k > l.right() - h.width) {
                    k = Math.max(l.right() - h.width, l.left())
                }
                if (j < l.top()) {
                    j = l.top()
                }
                if (j > l.bottom() - h.height) {
                    j = Math.max(l.bottom() - h.height, l.top())
                }
                var g = this.get_element().parentNode.scrollLeft - k;
                var f = this.get_element().parentNode.scrollTop - j;
                this.get_element().parentNode.scrollLeft = k;
                this.get_element().parentNode.scrollTop = j;
                if (this.currentMousePoint) {
                    this.currentMousePoint.x -= g;
                    this.currentMousePoint.y -= f
                }
            },
            onMouseUp: function(f) {
                if (!this.enabled) {
                    return
                }
                this.startDrag = false;
                this.resizeEnabled = false;
                this.stopAutoScroll();
                this.changeCursor(f)
            },
            changeCursor: function(g) {
                if (this.allowZoom) {
                    var h = b.Utils.getCursorPos(g, this.get_element());
                    var f = this.clientToDoc(h);
                    if (this.trackerRect && this.getTrackerResizer().containsPoint(f) || this.resizeEnabled) {
                        this.get_element().parentNode.style.cursor = "nwse-resize"
                    } else {
                        this.get_element().parentNode.style.cursor = "default"
                    }
                }
            },
            onResize: function(f) {
                if (!this.zooming) {
                    if (this.trackerRect) {
                        this.init();
                        this.invalidate()
                    }
                }
            },
            shrinkToFit: function(f, j, o, k) {
                var n = 0;
                var l = 0;
                var h = 0;
                l = (o / f);
                h = (k / j);
                n = (h < l) ? h : l;
                var p = Math.floor(f * n);
                var g = Math.floor(j * n);
                return new MindFusion.Drawing.Size(p, g)
            },
            setTrackerPosition: function() {
                if (!this.diagram) {
                    return
                }
                var g = this.diagram.scrollElement();
                var f = new MindFusion.Drawing.Point(g.scrollLeft / this.diagram.scale, g.scrollTop / this.diagram.scale);
                if (!isNaN(f.x) && !isNaN(f.y)) {
                    f.x += this.bounds.x;
                    f.y += this.bounds.y;
                    this.tryMoveTracker(Math.floor(f.x), Math.floor(f.y))
                }
            },
            tryMoveTracker: function(f, g) {
                this.trackerRect.x = Math.max(this.bounds.x, Math.min(f, this.bounds.width + this.bounds.x - this.trackerRect.width));
                this.trackerRect.y = Math.max(this.bounds.y, Math.min(g, this.bounds.height + this.bounds.y - this.trackerRect.height));
                this.invalidate()
            },
            tryMoveTrackerResizer: function(z, t) {
                var f = Math.max(this.bounds.x, Math.min(z, this.bounds.width + this.bounds.x - this.resizerWidth));
                if (f < this.trackerRect.x) {
                    f = this.trackerRect.x
                }
                var B = Math.max(this.bounds.y, Math.min(t, this.bounds.height + this.bounds.y - this.resizerHeight));
                if (B < this.trackerRect.y) {
                    B = this.trackerRect.y
                }
                var g = this.trackerW / this.trackerH;
                var k = this.trackerRect.x;
                var v = this.trackerRect.y;
                var j = this.trackerRect.x + this.trackerRect.width - this.resizerWidth;
                var s = this.trackerRect.y + this.trackerRect.height - this.resizerHeight;
                if (Math.abs(v - s) < 0.01) {
                    s = v + 0.001
                }
                var u = (v - s) / (k - j);
                var r = s - u * j;
                var l = u * f + r;
                var n = (B - r) / u;
                var o = l + this.resizerHeight - this.trackerRect.y;
                var A = o * g;
                this.trackerRect.width = A;
                this.trackerRect.height = o;
                var p = this.trackerW / A;
                this.diagram.setZoomFactorAndScroll(this.initialZoomFactor * p, this.savedScrollX, this.savedScrollY);
                this.invalidate()
            },
            scrollPosFromTracker: function() {
                return new MindFusion.Drawing.Point((this.trackerRect.x - this.bounds.x) * this.diagram.scale, (this.trackerRect.y - this.bounds.y) * this.diagram.scale)
            },
            getEffectiveBackBrush: function() {
                if (this.diagram) {
                    return this.diagram.getEffectiveBackBrush != null ? this.diagram.getEffectiveBackBrush() : this.diagram.backBrush
                }
                return this.dimColor
            },
            getBackgroundImage: function() {
                if (this.diagram) {
                    return this.diagram.getBackgroundImage()
                }
                return null
            },
            getBackgroundImageSize: function() {
                if (this.diagram) {
                    if (this.diagram.backgroundImage) {
                        return new MindFusion.Drawing.Size(this.diagram.backgroundImage.width * this.scaleFactor * (this.scaleMode == b.ScaleMode.CombinedScales ? this.diagram.getZoomFactor() / 100 : 1), this.diagram.backgroundImage.height * this.scaleFactor * (this.scaleMode == b.ScaleMode.CombinedScales ? this.diagram.getZoomFactor() / 100 : 1))
                    }
                }
                return new MindFusion.Drawing.Size(0, 0)
            },
            getBackgroundImageAlign: function() {
                if (this.diagram) {
                    return this.diagram.getBackgroundImageAlign()
                }
                return MindFusion.Drawing.ImageAlign.Center
            },
            prepareScriptEvent: function(g, f) {
                if (!f || f == "") {
                    return
                }
                var h = new Function("sender", "args", "return " + f + "(sender, args)");
                this.addEventListener(g, h)
            },
            addEventListener: function(f, g) {
                mflayer.addHandler(this, f, g)
            },
            getBackColor: function() {
                return this.backColor
            },
            setBackColor: function(f) {
                this.backColor = f;
                this.get_element().parentNode.style.backgroundColor = this.backColor
            },
            getDimColor: function() {
                return this.dimColor
            },
            setDimColor: function(f) {
                this.dimColor = f
            },
            setEnabled: function(f) {
                this.enabled = f
            },
            getEnabled: function() {
                return this.enabled
            },
            setScaleFactor: function(f) {
                var g = f / 100;
                if (g > 1) {
                    g = 1
                }
                if (g < 0.001) {
                    g = 0.001
                }
                if (this.scaleMode == b.ScaleMode.FitAll) {
                    this.nofitScaleFactor = g
                } else {
                    this.scaleFactor = g;
                    this.recalculateCanvas();
                    this.invalidate()
                }
            },
            getScaleFactor: function() {
                return this.scaleFactor * 100
            },
            setScaleMode: function(f) {
                if (this.scaleMode == f) {
                    return
                }
                this.scaleMode = f;
                if (this.scaleMode == b.ScaleMode.FitAll) {
                    this.nofitScaleFactor = this.scaleFactor;
                    this.fit()
                } else {
                    this.scaleFactor = this.nofitScaleFactor
                }
                this.invalidate()
            },
            getScaleMode: function() {
                return this.scaleMode
            },
            getAllowZoom: function() {
                return this.allowZoom
            },
            setAllowZoom: function(f) {
                if (this.allowZoom == f) {
                    return
                }
                this.allowZoom = f;
                this.invalidate()
            },
            getAutoScrollAmount: function() {
                return this.autoScrollAmount
            },
            setAutoScrollAmount: function(f) {
                if (this.autoScrollAmount != f) {
                    this.autoScrollAmount = f
                }
            },
            getScrollX: function() {
                return this.get_element().parentNode.scrollLeft
            },
            getScrollY: function() {
                return this.get_element().parentNode.scrollTop
            }
        };
        MindFusion.Diagramming.Overview.create = function(f) {
            return mflayer.createControl(MindFusion.Diagramming.Overview, null, null, null, f)
        };
        MindFusion.Diagramming.Overview.find = function(f, g) {
            return mflayer.findControl(f, g)
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.Overview", MindFusion.Drawing.Canvas)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.PanBehavior = function(d, c) {
            mflayer.initializeBase(b, this, [d])
        };
        b.prototype = {
            setMouseCursor: function(c, d) {
                this.currentCursor = MindFusion.Controls.MouseCursors.Pan;
                return this.currentCursor
            },
            createController: function(c) {
                return new a.PanController(this.diagram)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.PanBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.PathFinder = function(d) {
            this.diagram = d;
            this.graph = this.diagram.toGraph(false, false)
        };
        b.prototype.findAllPaths = function(k, j, h) {
            var f = null;
            var e = null;
            for (var d = 0; d < this.graph.vertices.length; d++) {
                if (this.graph.vertices[d].owner == k) {
                    f = this.graph.vertices[d]
                }
                if (this.graph.vertices[d].owner == j) {
                    e = this.graph.vertices[d]
                }
            }
            var g = MindFusion.Graphs.PathFinder.findAllPaths(this.graph, f, e, false, h);
            return b.convertPaths(g)
        };
        b.prototype.findShortestPath = function(l, k, f, j) {
            var g = null;
            var e = null;
            for (var d = 0; d < this.graph.vertices.length; d++) {
                if (this.graph.vertices[d].owner == l) {
                    g = this.graph.vertices[d]
                }
                if (this.graph.vertices[d].owner == k) {
                    e = this.graph.vertices[d]
                }
            }
            var h = MindFusion.Graphs.PathFinder.findShortestPath(this.graph, g, e, f, j);
            return b.convertPath(h)
        };
        b.prototype.findLongestPath = function(j, h) {
            if (j && h) {
                var f = null;
                var e = null;
                for (var d = 0; d < this.graph.vertices.length; d++) {
                    if (this.graph.vertices[d].owner == j) {
                        f = this.graph.vertices[d]
                    }
                    if (this.graph.vertices[d].owner == h) {
                        e = this.graph.vertices[d]
                    }
                }
                var g = MindFusion.Graphs.PathFinder.findLongestPath(this.graph, f, e);
                return b.convertPath(g)
            }
        };
        b.prototype.findCycle = function(d) {
            var g = null;
            if (d) {
                for (var e = 0; e < this.graph.vertices.length; e++) {
                    if (this.graph.vertices[e].owner == d) {
                        g = this.graph.vertices[e]
                    }
                }
                if (g == null) {
                    return null
                }
            }
            var f = MindFusion.Graphs.PathFinder.findCycle(this.graph, g);
            return b.convertPath(f)
        };
        b.prototype.findAllCycles = function() {
            return b.convertPaths(MindFusion.Graphs.PathFinder.enumAllCycles(this.graph))
        };
        b.convertPath = function(d) {
            if (d) {
                return new c(d)
            }
            return null
        };
        b.convertPaths = function(e) {
            var d = [];
            if (!e) {
                return d
            }
            if (e.length > 0) {
                e.forEach(function(f) {
                    d.push(new c(f))
                })
            }
            return d
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.PathFinder");
        var c = a.Path = function(d) {
            this.nodes = [];
            this.links = [];
            this.items = [];
            if (d != null) {
                d.nodes.forEach(function(e) {
                    this.nodes.push(e.owner)
                }, this);
                d.links.forEach(function(e) {
                    this.links.push(e.owner)
                }, this);
                d.items.forEach(function(e) {
                    this.items.push(e.owner)
                }, this)
            }
        };
        c.prototype.getWeight = function(f, e) {
            var d = 0;
            if (f) {
                this.nodes.forEach(function(g) {
                    d += g.getWeight()
                })
            }
            if (e) {
                this.links.forEach(function(g) {
                    d += node.getWeight()
                })
            }
            return d
        };
        c.prototype.getLength = function() {
            return this.links.length
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.Path")
    })(MindFusion.Diagramming);
    (function(a) {
        var d = MindFusion.Controls.MouseCursors;
        var c = MindFusion.Drawing.GraphicsUnit;
        var b = a.RowResizer = function(e, f) {
            mflayer.initializeBase(b, this, [e]);
            this.rowIndex = f;
            this.row = this.node.getRow(this.rowIndex);
            this.startHeight = this.row.height
        };
        b.prototype = {
            hitTest: function(e) {
                return false
            },
            needsMouseMessages: function(e) {
                return true
            },
            setMouseCursor: function(f) {
                if (this.node.getRotationAngle() != 0) {
                    var e = this.node.getRotationAngle();
                    if (e >= -180 && e < -135) {
                        return d.CounterDiagonalResize
                    } else {
                        if (e >= -135 && e < -90) {
                            return d.HorizontalResize
                        } else {
                            if (e >= -90 && e < -45) {
                                return d.DiagonalResize
                            } else {
                                if (e >= -45 && e < 0) {
                                    return d.VerticalResize
                                } else {
                                    if (e >= 0 && e < 45) {
                                        return d.CounterDiagonalResize
                                    } else {
                                        if (e >= 45 && e < 90) {
                                            return d.HorizontalResize
                                        } else {
                                            if (e >= 90 && e < 135) {
                                                return d.DiagonalResize
                                            } else {
                                                return d.VerticalResize
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return d.VerticalResize
            },
            localPoint: function(e) {
                if (this.node.getRotationAngle() != 0) {
                    return a.Utils.rotatePointAt(e, this.node.bounds.center(), -this.node.getRotationAngle())
                }
                return e.clone()
            },
            onMouseDown: function(f) {
                this.mouseDown = true;
                var e = this.localPoint(f);
                this.current = this.last = e.y
            },
            onMouseMove: function(j) {
                if (!this.mouseDown) {
                    return
                }
                var f = this.localPoint(j);
                this.current = f.y;
                var e = this.node.getParent();
                if (!this.resizing) {
                    if (Math.abs(this.current - this.last) >= c.getMillimeter(e.measureUnit)) {
                        this.resizing = true;
                        if (e.getUndoEnabled()) {
                            this.cmd = new a.ResizeTableRowCommand(e, this.node, this.row)
                        }
                    }
                }
                if (this.resizing) {
                    var h = this.row.height;
                    this.node.setRowHeight(this.rowIndex, Math.max(c.getMillimeter(e.measureUnit), this.row.height + (this.current - this.last)));
                    var g = {
                        value: undefined
                    };
                    if (!e.raiseTableRowResizing(this.node, this.rowIndex, j, 0, g)) {
                        this.node.setRowHeight(this.rowIndex, h)
                    }
                    if (g.value) {
                        this.cancel()
                    }
                    if (h != this.row.height) {
                        this.last = this.current
                    }
                }
            },
            onMouseUp: function(f) {
                if (this.resizing) {
                    var e = this.node.getParent();
                    if (e.getUndoEnabled()) {
                        e.undoManager.executeCommand(this.cmd)
                    }
                    e.raiseTableRowResized(this.node, this.rowIndex, f, 0)
                }
                this.mouseDown = false;
                this.resizing = false
            },
            cancel: function() {
                if (this.resizing) {
                    this.mouseDown = false;
                    this.resizing = false;
                    this.node.setRowHeight(this.rowIndex, this.startHeight);
                    this.cmd = null
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.RowResizer", a.Manipulator)
    })(MindFusion.Diagramming);
    (function(b) {
        var k = MindFusion.Drawing.Point;
        var d = MindFusion.Drawing.Rect;
        var g = MindFusion.Drawing.Path;
        var f = MindFusion.Drawing.Text;
        var j = MindFusion.Diagramming.Utils;
        var n = MindFusion.Diagramming.Alignment;
        var h = MindFusion.Diagramming.Orientation;
        var a = MindFusion.Drawing.GraphicsUnit;
        var e = b.AlignStart = {
            Decrease: 0,
            Increase: 1,
            Undetermined: 2
        };
        var c = b.Scale = function(p, q, o) {
            mflayer.initializeBase(c, this, [p]);
            this.parent = q;
            this.orientation = o;
            this.unit = q.unit;
            this.foreColor = q.foreColor;
            this.backColor = q.backColor;
            this.projectionColor = q.projectionColor;
            this.enableGuides = q.enableGuides;
            this.guideColor = q.guideColor;
            this.textColor = q.textColor;
            this.pointerColor = q.pointerColor;
            this.aligning = false;
            this.alignedNodes = new MindFusion.Collections.Dictionary();
            this.repaintDelegate = mflayer.createDelegate(this, this.repaint);
            this.initialize()
        };
        c.prototype = {
            initialize: function() {
                var o = this.get_element();
                if (typeof o.getContext !== "undefined") {
                    this.canvas = o;
                    this.context = o.getContext("2d")
                }
                mflayer.addHandlers(o, {
                    mousedown: mflayer.createDelegate(this, this.onMouseDown)
                });
                mflayer.addHandlers(o, {
                    mousemove: mflayer.createDelegate(this, this.onMouseMove)
                });
                this.mouseUpDelegate = mflayer.createDelegate(this, this.onMouseUp);
                mflayer.addHandlers(document, {
                    mouseup: this.mouseUpDelegate
                })
            },
            dispose: function() {},
            invalidate: function() {
                if (!this.repaintId) {
                    this.repaintId = setTimeout(this.repaintDelegate, 20)
                }
            },
            repaint: function() {
                if (!this.context) {
                    return
                }
                this.canvas.width = this.canvas.width;
                var o = mflayer.getBounds(this.get_element());
                this.context.strokeStyle = this.foreColor;
                this.context.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / this.context._mf_scale;
                this.context.fillStyle = this.backColor;
                this.context.rect(0, 0, o.width, o.height);
                this.context.fill();
                this.drawProjection(this.context);
                this.drawMarks(this.context);
                if (this.e != null) {
                    this.drawCursorProjection(this.e, this.context)
                }
                if (this.repaintId) {
                    clearTimeout(this.repaintId);
                    this.repaintId = null
                }
            },
            onMouseDown: function(p) {
                if (!this.enableGuides) {
                    return
                }
                if (p.button != 0) {
                    return
                }
                var o = this.parent.diagram;
                if (o == null) {
                    return
                }
                o.startTotalChange();
                this.aligning = true;
                this.alignedNodes = new MindFusion.Collections.Dictionary();
                if (this.get_element().setCapture) {
                    this.get_element().setCapture()
                }
                var q = b.Utils.getCursorPos(p, o.get_element());
                this.ptInitial = o.clientToDoc(q);
                this.ptCurrent = this.ptInitial;
                this.align = e.Undetermined
            },
            onMouseMove: function(t) {
                this.e = t;
                if (this.aligning) {
                    var p = this.parent.diagram;
                    var v = b.Utils.getCursorPos(t, p.get_element());
                    var u = p.clientToDoc(v);
                    if (this.align == e.Undetermined) {
                        if (this.orientation == h.Horizontal) {
                            if (u.x < this.ptInitial.x) {
                                this.align = e.Decrease
                            } else {
                                if (u.x > this.ptInitial.x) {
                                    this.align = e.Increase
                                }
                            }
                        } else {
                            if (u.y < this.ptInitial.y) {
                                this.align = e.Decrease
                            } else {
                                if (u.y > this.ptInitial.y) {
                                    this.align = e.Increase
                                }
                            }
                        }
                        if (this.align == e.Undetermined) {
                            return
                        }
                    }
                    var o = p.getItems();
                    for (var q in o) {
                        var s = o[q];
                        if (s == null) {
                            continue
                        }
                        if (!mflayer.isInstanceOfType(b.DiagramNode, s)) {
                            continue
                        }
                        if (!p.isItemVisible(s)) {
                            continue
                        }
                        if (s.getLocked()) {
                            continue
                        }
                        if (p.getSelection().items.length > 0 && !s.getSelected()) {
                            continue
                        }
                        var r = s.getBounds();
                        if (this.orientation == h.Horizontal) {
                            if (this.align == e.Increase) {
                                if (r.x >= Math.min(u.x, this.ptCurrent.x) - this.getThresh() && r.x <= Math.max(u.x, this.ptCurrent.x) + this.getThresh() && !this.alignedNodes.contains(s)) {
                                    this.alignedNodes.set(s, n.Near)
                                }
                            } else {
                                if (r.right() >= Math.min(u.x, this.ptCurrent.x) - this.getThresh() && r.right() <= Math.max(u.x, this.ptCurrent.x) + this.getThresh() && !this.alignedNodes.contains(s)) {
                                    this.alignedNodes.set(s, n.Far)
                                }
                            }
                        } else {
                            if (this.align == e.Increase) {
                                if (r.y >= Math.min(u.y, this.ptCurrent.y) - this.getThresh() && r.y <= Math.max(u.y, this.ptCurrent.y) + this.getThresh() && !this.alignedNodes.contains(s)) {
                                    this.alignedNodes.set(s, n.Near)
                                }
                            } else {
                                if (r.bottom() >= Math.min(u.y, this.ptCurrent.y) - this.getThresh() && r.bottom() <= Math.max(u.y, this.ptCurrent.y) + this.getThresh() && !this.alignedNodes.contains(s)) {
                                    this.alignedNodes.set(s, n.Far)
                                }
                            }
                        }
                    }
                    this.alignedNodes.forEach(function(z) {
                        var A = this.alignedNodes.get(z);
                        var w = z.getBounds();
                        if (this.orientation == h.Horizontal) {
                            if (A == n.Near) {
                                w.x = u.x
                            } else {
                                w.x = u.x - w.width
                            }
                        } else {
                            if (A == n.Near) {
                                w.y = u.y
                            } else {
                                w.y = u.y - w.height
                            }
                        }
                        z.setBounds(w, false)
                    }, this);
                    p.invalidate();
                    this.ptCurrent = u
                }
            },
            onMouseUp: function(o) {
                if (this.aligning) {
                    this.aligning = false;
                    this.parent.diagram.commitCompositeOperation();
                    this.parent.diagram.invalidate();
                    this.alignedNodes.forEach(function(p) {
                        p.setBounds(p.getBounds(), true)
                    })
                }
                if (document.releaseCapture) {
                    document.releaseCapture()
                }
            },
            onDiagramMouseMove: function(o) {
                this.e = o;
                this.invalidate()
            },
            onDiagramPaint: function() {
                if (!this.aligning) {
                    return
                }
                var p = this.parent.diagram;
                var s = b.Utils.getCursorPos(this.e, p.get_element());
                var o = p.clientToDoc(s);
                var r = p.getBounds();
                var q = p.context;
                q.strokeStyle = this.guideColor;
                q.beginPath();
                if (this.orientation == h.Horizontal) {
                    q.moveTo(o.x, r.y);
                    q.lineTo(o.x, r.bottom())
                } else {
                    q.moveTo(r.x, o.y);
                    q.lineTo(r.right(), o.y)
                }
                q.stroke()
            },
            drawProjection: function(q) {
                var t = this.parent.diagram;
                if (t == null) {
                    return
                }
                if (t.getActiveItem() == null) {
                    return
                }
                var r = t.getActiveItem();
                if (!mflayer.isInstanceOfType(b.DiagramNode, r)) {
                    return
                }
                var o = this.parent.getProjectRotatedBounds() ? r.getRotatedBounds() : r.getBounds();
                var s = mflayer.getBounds(this.get_element());
                s.x = s.y = 0;
                var u = this.parent.diagram.docToClient(new k(o.x, o.y));
                var p = this.parent.diagram.docToClient(new k(o.right(), o.bottom()));
                var w = this.parent.diagram.docToClient(new k(this.parent.diagram.getScrollX(), this.parent.diagram.getScrollY()));
                u.x -= w.x;
                u.y -= w.y;
                p.x -= w.x;
                p.y -= w.y;
                this.context.fillStyle = this.projectionColor;
                if (this.orientation == h.Horizontal) {
                    var v = s;
                    v.y += 1;
                    v.height -= 2;
                    v.x = u.x;
                    v.width = p.x - u.x + 1;
                    if (v.x < s.x) {
                        v.width -= (s.x - v.x);
                        v.x = s.x
                    }
                    if (v.x + v.width > s.right()) {
                        v.width = s.right() - v.x - 1
                    }
                    q.fillRect(v.x, v.y, v.width, v.height)
                } else {
                    var v = s;
                    v.x += 1;
                    v.width -= 2;
                    v.y = u.y;
                    v.height = p.y - u.y + 1;
                    if (v.y < s.y) {
                        v.height -= (s.y - v.y);
                        v.y = s.y
                    }
                    if (v.y + v.height > s.bottom()) {
                        v.height = s.bottom() - v.y - 1
                    }
                    q.fillRect(v.x, v.y, v.width, v.height)
                }
            },
            drawMarks: function(p) {
                var s = this.parent.diagram;
                if (s == null) {
                    return
                }
                var D = mflayer.getBounds(this.get_element());
                D.x = D.y = 0;
                var t = this.calcPixelsPerUnit();
                var z = this.calcUnitInterval(t);
                var F;
                if (this.unit != a.Percent) {
                    F = s.docToClient(new k(0, 0))
                } else {
                    F = s.docToClient(s.bounds.location())
                }
                var G = s.docToClient(new k(s.getScrollX(), s.getScrollY()));
                F.x -= G.x;
                F.y -= G.y;
                var q = (s.font) ? s.font.size : MindFusion.Drawing.Font.defaultFont.size;
                this.context.fillStyle = this.backColor;
                this.context.beginPath();
                if (this.orientation == h.Horizontal) {
                    var E = F.x;
                    var C = 0;
                    if (E <= D.x) {
                        while (E < D.x) {
                            E += z * t;
                            C++
                        }
                        E -= z * t;
                        C--
                    } else {
                        if (E > D.x) {
                            while (E > D.x) {
                                E -= z * t;
                                C--
                            }
                        }
                    }
                    var r = this.parent.getNegatedX() ? -1 : 1;
                    while (E < D.right()) {
                        var v = r * C * z;
                        p.moveTo(E, D.top() + 1);
                        p.lineTo(E, D.top() + D.height);
                        p.stroke();
                        p.strokeStyle = this.textColor;
                        p.strokeText(v, E + 1, D.height / 2 + 1);
                        p.strokeStyle = this.foreColor;
                        var o = a.getStandardDivisions(this.unit);
                        if (z * t > 100) {
                            o *= 2
                        } else {
                            if (z * t <= 40) {
                                o /= 2
                            }
                        }
                        var A = z * t / o;
                        for (var u = 1; u < o; u++) {
                            var w = (o % 2 == 0 && u == o / 2) ? 3 : 0;
                            p.moveTo(E + u * A, D.x + q + D.height / 2 - w);
                            p.lineTo(E + u * A, D.bottom() - 1);
                            p.stroke()
                        }
                        E += z * t;
                        C++
                    }
                } else {
                    var B = F.y;
                    var C = 0;
                    if (B <= D.y) {
                        while (B < D.y) {
                            B += z * t;
                            C++
                        }
                        B -= z * t;
                        C--
                    } else {
                        if (B > D.y) {
                            while (B > D.y) {
                                B -= z * t;
                                C--
                            }
                        }
                    }
                    var r = this.parent.getNegatedY() ? -1 : 1;
                    while (B < D.bottom() + t * z) {
                        var v = r * C * z;
                        p.moveTo(D.x + 1, B);
                        p.lineTo(D.x + D.width - 2, B);
                        p.stroke();
                        p.save();
                        p.translate(D.width / 2 - q, B + 1);
                        p.rotate(90 * Math.PI / 180);
                        p.strokeStyle = this.textColor;
                        p.strokeText(v, q / 2, 0);
                        p.strokeStyle = this.foreColor;
                        p.restore();
                        var o = a.getStandardDivisions(this.unit);
                        if (z * t > 100) {
                            o *= 2
                        } else {
                            if (z * t <= 40) {
                                o /= 2
                            }
                        }
                        var A = z * t / o;
                        for (var u = 1; u < o; u++) {
                            var w = (o % 2 == 0 && u == o / 2) ? 3 : 0;
                            p.moveTo(D.x + q + D.width / 2 - w, B + u * A);
                            p.lineTo(D.right() - 1, B + u * A);
                            p.stroke()
                        }
                        B += z * t;
                        C++
                    }
                }
            },
            drawCursorProjection: function(t, r) {
                var q = this.parent.diagram;
                if (q == null) {
                    return
                }
                var s = mflayer.getBounds(this.get_element());
                s.x = s.y = 0;
                var u = b.Utils.getCursorPos(t, q.get_element());
                var p = q.clientToDoc(u);
                var p = q.docToClient(p);
                var o = q.docToClient(new k(q.getScrollX(), q.getScrollY()));
                p.x -= o.x;
                p.y -= o.y;
                r.beginPath();
                r.strokeStyle = this.pointerColor;
                if (this.orientation == h.Horizontal) {
                    r.moveTo(p.x, s.y);
                    r.lineTo(p.x, s.bottom())
                } else {
                    r.moveTo(s.x, p.y);
                    r.lineTo(s.right(), p.y)
                }
                r.stroke()
            },
            calcPixelsPerUnit: function() {
                var o = a.convert(1, this.unit, a.Pixel);
                if (this.parent.diagram != null) {
                    o *= this.parent.diagram.zoomFactor / 100
                }
                return o
            },
            calcUnitInterval: function(o) {
                var s = "10000";
                var r = this.context.measureText(s).width;
                var q = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];
                for (var p = 0; p < q.length; p++) {
                    if (q[p] * o > r) {
                        return q[p]
                    }
                }
                return q[q.length - 1]
            },
            getThresh: function() {
                var o = 5;
                if (this.parent.diagram == null) {
                    return 1 / o
                }
                return a.convert(1, this.parent.diagram.measureUnit, a.Millimeter) / o
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.Scale", "Control");
        var l = b.Ruler = function(o) {
            mflayer.initializeBase(l, this, [o]);
            this.horizontalScaleVisible = true;
            this.verticalScaleVisible = true;
            this.diagramId = "";
            this.scaleSize = 20;
            this.unit = a.Millimeter;
            this.backColor = "#dddddd";
            this.foreColor = "#000000";
            this.projectionColor = "lightSteelBlue";
            this.enableGuides = true;
            this.guideColor = "#000000";
            this.textColor = "#000000";
            this.pointerColor = "red";
            this.eventHandlers = mflayer.eventHandlerList()
        };
        l.prototype = {
            initialize: function() {
                mflayer.callBaseMethod(l, this, "initialize")
            },
            dispose: function() {
                if (this.horizontalScale) {
                    this.horizontalScale.dispose();
                    this.get_element().removeChild(this.horizontalScale.get_element());
                    this.horizontalScale = null
                }
                if (this.verticalScale) {
                    this.verticalScale.dispose();
                    this.get_element().removeChild(this.verticalScale.get_element());
                    this.verticalScale = null
                }
                mflayer.removeHandler(window, "resize", this.resizeDelegate);
                mflayer.callBaseMethod(l, this, "dispose")
            },
            registerForSubmit: function(q) {
                var p = document.getElementById(q);
                if (p) {
                    var o = p.form;
                    if (o) {
                        o.addEventListener("submit", mflayer.createDelegate(this, mflayer.createCallback(this.preparePostback, {
                            id: q
                        })))
                    }
                }
            },
            setDiagram: function(o) {
                this.diagram = o;
                if (o) {
                    this.diagramId = o.get_element().id;
                    this.repaintDelegate = mflayer.createDelegate(this, this.refreshScales);
                    o.addEventListener(b.Events.repaint, this.repaintDelegate);
                    o.addEventListener(b.Events.repaint, mflayer.createDelegate(this, this.onDiagramPaint));
                    o.addEventListener("zoomChanged", mflayer.createDelegate(this, this.onResize));
                    mflayer.addHandlers(this.diagram.scrollElement(), {
                        scroll: this.repaintDelegate
                    });
                    this.mouseMoveDelegate = mflayer.createDelegate(this, this.onDiagramMouseMove);
                    mflayer.addHandlers(this.diagram.get_element(), {
                        mousemove: this.mouseMoveDelegate
                    });
                    this.resizeDelegate = mflayer.createDelegate(this, this.onResize);
                    mflayer.addHandlers(window, {
                        resize: this.resizeDelegate
                    });
                    this.init()
                }
            },
            preparePostback: function(p, o) {
                var q = document.getElementById(o.id);
                if (q) {
                    q.value = this.toJson()
                }
            },
            fromJson: function(o) {
                if (o > "") {
                    var p = mflayer.fromJson(o);
                    if (p.diagramView) {
                        this.diagramId = p.diagramView;
                        this.setUnit(p.unit);
                        this.setBackColor(p.backColor);
                        this.setForeColor(p.foreColor);
                        this.setProjectionColor(p.projectionColor);
                        this.setGuideColor(p.guideColor);
                        this.setTextColor(p.textColor);
                        this.setPointerColor(p.pointerColor);
                        this.setEnableGuides(p.enableGuides);
                        this.setNegatedX(p.negatedX);
                        this.setNegatedY(p.negatedY);
                        this.setProjectRotatedBounds(p.projectRotatedBounds);
                        this.setHorizontalScaleVisible(p.horizontalScaleVisible);
                        this.setVerticalScaleVisible(p.verticalScaleVisible);
                        this.prepareScriptEvent(b.Events.controlLoaded, p.controlLoadedScript);
                        var q = this;
                        setTimeout(function() {
                            return q.prepare()
                        }, 100)
                    }
                }
            },
            prepare: function() {
                this.setDiagram(b.Diagram.find(this.diagramId));
                this.diagram.invalidate();
                this.refreshScales()
            },
            toJson: function() {
                var o = {
                    id: this.get_element().id,
                    diagramView: this.diagramId,
                    unit: this.unit,
                    backColor: this.backColor,
                    foreColor: this.foreColor,
                    projectionColor: this.projectionColor,
                    guideColor: this.guideColor,
                    textColor: this.textColor,
                    pointerColor: this.pointerColor,
                    enableGuides: this.enableGuides,
                    negatedX: this.negatedX,
                    negatedY: this.negatedY,
                    projectRotatedBounds: this.projectRotatedBounds,
                    horizontalScaleVisible: this.horizontalScaleVisible,
                    verticalScaleVisible: this.verticalScaleVisible,
                };
                return mflayer.toJson(o)
            },
            init: function() {
                if (this.diagram == null) {
                    return
                }
                var q = this.get_element();
                q.style.backgroundColor = this.backColor;
                q.style.overflow = "hidden";
                var o = document.createElement("canvas");
                o.id = this.diagram.get_element().id + "_horizontalScale";
                o.height = this.scaleSize;
                o.style.position = "absolute";
                o.style.zIndex = 9999;
                q.insertBefore(o, q.childNodes[0]);
                this.horizontalScale = new c(o, this, h.Horizontal);
                var p = document.createElement("canvas");
                p.id = this.diagram.get_element().id + "_verticalScale";
                p.width = this.scaleSize;
                p.style.marginTop = this.scaleSize + "px";
                p.style.position = "absolute";
                p.style.zIndex = 9999;
                q.insertBefore(p, q.childNodes[0]);
                this.verticalScale = new c(p, this, h.Vertical);
                this.updateScales();
                this.raiseEvent(b.Events.controlLoaded)
            },
            updateScales: function() {
                var p = document.getElementById(this.diagramId).parentNode;
                this.bounds = mflayer.getBounds(p);
                if (this.horizontalScale) {
                    var o = this.horizontalScale.get_element();
                    if (this.horizontalScaleVisible) {
                        o.style.visibility = "visible";
                        p.style.marginTop = this.scaleSize + "px"
                    } else {
                        o.style.visibility = "hidden";
                        p.style.marginTop = "0px"
                    }
                    if (this.verticalScaleVisible) {
                        o.style.marginLeft = this.scaleSize + "px";
                        o.width = this.bounds.width - this.scaleSize
                    } else {
                        o.style.marginLeft = "0px";
                        o.width = this.bounds.width
                    }
                }
                if (this.verticalScale) {
                    var o = this.verticalScale.get_element();
                    if (this.verticalScaleVisible) {
                        o.style.visibility = "visible";
                        p.style.marginLeft = this.scaleSize + "px"
                    } else {
                        o.style.visibility = "hidden";
                        p.style.marginLeft = "0px"
                    }
                    if (this.horizontalScaleVisible) {
                        o.style.marginTop = this.scaleSize + "px";
                        o.height = this.bounds.height - this.scaleSize
                    } else {
                        o.style.marginTop = "0px";
                        o.height = this.bounds.height
                    }
                }
                this.refreshScales()
            },
            refreshScales: function() {
                if (this.horizontalScale != null) {
                    this.horizontalScale.invalidate()
                }
                if (this.verticalScale != null) {
                    this.verticalScale.invalidate()
                }
            },
            raiseEvent: function(o, p) {
                var q = mflayer.getHandler(this, o);
                if (q != null) {
                    q(this, p)
                }
            },
            onDiagramMouseMove: function(o) {
                if (this.horizontalScale != null) {
                    this.horizontalScale.onDiagramMouseMove(o)
                }
                if (this.verticalScale != null) {
                    this.verticalScale.onDiagramMouseMove(o)
                }
            },
            onDiagramPaint: function(o) {
                if (this.horizontalScale != null) {
                    this.horizontalScale.onDiagramPaint(o)
                }
                if (this.verticalScale != null) {
                    this.verticalScale.onDiagramPaint(o)
                }
            },
            onResize: function(o) {
                this.updateScales()
            },
            prepareScriptEvent: function(p, o) {
                if (!o || o == "") {
                    return
                }
                var q = new Function("sender", "args", "return " + o + "(sender, args)");
                this.addEventListener(p, q)
            },
            addEventListener: function(o, p) {
                mflayer.addHandler(this, o, p)
            },
            setUnit: function(o) {
                this.unit = o;
                if (this.horizontalScale) {
                    this.horizontalScale.unit = o
                }
                if (this.verticalScale) {
                    this.verticalScale.unit = o
                }
            },
            getUnit: function() {
                return this.unit
            },
            setBackColor: function(o) {
                this.backColor = o;
                this.get_element().style.backgroundColor = this.backColor;
                if (this.horizontalScale) {
                    this.horizontalScale.backColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.backColor = o
                }
            },
            getBackColor: function() {
                return this.backColor
            },
            setForeColor: function(o) {
                this.foreColor = o;
                if (this.horizontalScale) {
                    this.horizontalScale.foreColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.foreColor = o
                }
            },
            getForeColor: function() {
                return this.foreColor
            },
            setProjectionColor: function(o) {
                this.projectionColor = o;
                if (this.horizontalScale) {
                    this.horizontalScale.projectionColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.projectionColor = o
                }
            },
            getProjectionColor: function() {
                return this.projectionColor
            },
            setGuideColor: function(o) {
                this.guideColor = o;
                if (this.horizontalScale) {
                    this.horizontalScale.guideColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.guideColor = o
                }
            },
            getGuideColor: function() {
                return this.guideColor
            },
            setTextColor: function(o) {
                this.textColor = o;
                if (this.horizontalScale) {
                    this.horizontalScale.textColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.textColor = o
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setPointerColor: function(o) {
                this.pointerColor = o;
                if (this.horizontalScale) {
                    this.horizontalScale.pointerColor = o
                }
                if (this.verticalScale) {
                    this.verticalScale.pointerColor = o
                }
            },
            getPointerColor: function() {
                return this.pointerColor
            },
            setEnableGuides: function(o) {
                this.enableGuides = o;
                if (this.horizontalScale) {
                    this.horizontalScale.enableGuides = o
                }
                if (this.verticalScale) {
                    this.verticalScale.enableGuides = o
                }
            },
            getEnableGuides: function() {
                return this.enableGuides
            },
            setHorizontalScaleVisible: function(o) {
                this.horizontalScaleVisible = o;
                this.updateScales()
            },
            getHorizontalScaleVisible: function() {
                return this.horizontalScaleVisible
            },
            setVerticalScaleVisible: function(o) {
                this.verticalScaleVisible = o;
                this.updateScales()
            },
            getVerticalScaleVisible: function() {
                return this.verticalScaleVisible
            },
            setNegatedX: function(o) {
                if (this.negatedX != o) {
                    this.negatedX = o;
                    this.refreshScales()
                }
            },
            getNegatedX: function() {
                return this.negatedX
            },
            setNegatedY: function(o) {
                if (this.negatedY != o) {
                    this.negatedY = o;
                    this.refreshScales()
                }
            },
            getNegatedY: function() {
                return this.negatedY
            },
            setProjectRotatedBounds: function(o) {
                if (this.projectRotatedBounds != o) {
                    this.projectRotatedBounds = o;
                    this.refreshScales()
                }
            },
            getProjectRotatedBounds: function() {
                return this.projectRotatedBounds
            }
        };
        MindFusion.Diagramming.Ruler.create = function(o) {
            return mflayer.createControl(MindFusion.Diagramming.Ruler, null, null, null, o)
        };
        MindFusion.Diagramming.Ruler.find = function(o, p) {
            return mflayer.findControl(o, p)
        };
        MindFusion.registerClass(l, "MindFusion.Diagramming.Ruler", "Control")
    })(MindFusion.Diagramming);
    (function(a) {
        var e = MindFusion.Drawing.GraphicsUnit;
        var c = MindFusion.Drawing.Path;
        var b = MindFusion.Drawing.Rect;
        var d = a.ScrollBar = function(f) {
            mflayer.initializeBase(d, this, [f]);
            this.updateContent();
            this.updateLocation()
        };
        d.prototype = {
            needsMouseMessages: function(g) {
                var f = this.getThumbRect(this.node);
                return f != null && f.containsPoint(g)
            },
            onMouseDown: function(f) {
                this.mouseDown = true
            },
            onMouseMove: function(f) {
                if (!this.mouseDown) {
                    return
                }
                this.node.setCurrentScrollRow(this.calcScrollPos(f))
            },
            onMouseUp: function(f) {
                this.mouseDown = false
            },
            cancel: function() {
                this.mouseDown = false
            },
            updateLocation: function() {
                var f = this.getRect();
                this.x = f.x;
                this.y = f.y
            },
            onClick: function(l) {
                var h = this.getRotatedRect();
                if (!h.containsPoint(l)) {
                    return
                }
                var g = this.node;
                var k = e.getMillimeter(g.parent.measureUnit);
                var f = 4 * k;
                var j = new a.ScrollTableCommand(this, g);
                if (l.y < h.y + f) {
                    g.scrollUp()
                }
                if (l.y > h.bottom() - f) {
                    g.scrollDown()
                }
                if (g.parent.getUndoEnabled()) {
                    g.parent.undoManager.executeCommand(j)
                }
            },
            hitTest: function(f) {
                return this.getRotatedRect().containsPoint(f)
            },
            getRect: function() {
                var h = this.node;
                var j = e.getMillimeter(h.parent.measureUnit);
                var g = h.bounds;
                var f = h.getCaptionHeight();
                return new b(g.right() - 5 * j, g.y + f, 5 * j, g.height - f)
            },
            getRotatedRect: function() {
                var g = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var k = [];
                    k.push(g.topLeft());
                    k.push(g.topRight());
                    k.push(g.bottomRight());
                    k.push(g.bottomLeft());
                    a.Utils.rotatePointsAt(k, a.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var f = Math.min(k[0].x, Math.min(k[1].x, Math.min(k[2].x, k[3].x)));
                    var l = Math.min(k[0].y, Math.min(k[1].y, Math.min(k[2].y, k[3].y)));
                    var j = Math.max(k[0].x, Math.max(k[1].x, Math.max(k[2].x, k[3].x)));
                    var h = Math.max(k[0].y, Math.max(k[1].y, Math.max(k[2].y, k[3].y)));
                    return b.fromLTRB(f, l, j, h)
                }
                return g
            },
            updateContent: function() {
                var g = this.node;
                var k = this.background || MindFusion.Diagramming.Utils.rgbToString(200, 200, 200, 0.5);
                var j = this.foreground || g.getEffectiveStroke();
                var h = e.getMillimeter(g.parent.measureUnit);
                var n = 4 * h;
                var f = 3 * h / 4;
                var l = this.getRect();
                l.x = l.y = 0;
                l.brush = k;
                l.pen = undefined;
                this.content = [l];
                var o = new c();
                o.moveTo(l.width / 2, f);
                o.lineTo(l.width - f, n - f);
                o.lineTo(f, n - f);
                o.close();
                o.done();
                o.setBrush(j);
                this.content.push(o);
                var o = new c();
                o.moveTo(l.width / 2, l.height - f);
                o.lineTo(l.width - f, l.height - n + f);
                o.lineTo(f, l.height - n + f);
                o.close();
                o.done();
                o.setBrush(j);
                this.content.push(o);
                var p = this.getThumbRect(g, l);
                if (p) {
                    p.pen = undefined;
                    p.brush = j;
                    this.content.push(p)
                }
            },
            getThumbRect: function(h, o) {
                if (!o) {
                    o = this.getRect()
                }
                if (h.rows.length > 0) {
                    var f = h.rows[0].height;
                    var g = f * h.rows.length;
                    if (g > o.height) {
                        var j = e.getMillimeter(h.parent.measureUnit);
                        var p = 4 * j;
                        var k = o.height - 2 * p;
                        var l = Math.max(4 * j, k * o.height / g);
                        k -= l;
                        var n = k * h.currentScrollRow / h.rows.length;
                        var q = o.clone();
                        q.height = l;
                        q.y += p + n;
                        return q
                    }
                }
                return null
            },
            calcScrollPos: function(r) {
                var j = this.node;
                if (j.rows.length > 0) {
                    var f = j.rows[0].height;
                    var h = f * j.rows.length;
                    var p = this.getRect();
                    if (h > p.height) {
                        var k = e.getMillimeter(j.parent.measureUnit);
                        var q = 4 * k;
                        var l = p.height - 2 * q;
                        var n = Math.max(4 * k, l * p.height / h);
                        l -= n;
                        var o = r.y - p.y - q;
                        var g = parseInt(j.rows.length * o / l);
                        g = Math.max(0, g);
                        g = Math.min(g, j.rows.length - 1);
                        return g
                    }
                }
                return 0
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.ScrollBar", a.Manipulator)
    })(MindFusion.Diagramming);
    (function(b) {
        var e = MindFusion.Drawing.GraphicsUnit;
        var d = MindFusion.Drawing.Path;
        var c = MindFusion.Drawing.Rect;
        var a = b.Scroller = function(f) {
            mflayer.initializeBase(a, this, [f]);
            this.updateContent();
            this.updateLocation()
        };
        a.prototype = {
            updateLocation: function() {
                var f = this.getRect();
                this.x = f.x;
                this.y = f.y
            },
            onClick: function(j) {
                var g = this.getRotatedRect();
                if (!g.containsPoint(j)) {
                    return
                }
                var f = this.node;
                var h = new b.ScrollTableCommand(this, f);
                if (j.y < g.center().y) {
                    f.scrollUp()
                } else {
                    f.scrollDown()
                }
                if (f.parent.getUndoEnabled()) {
                    f.parent.undoManager.executeCommand(h)
                }
            },
            hitTest: function(f) {
                return this.getRotatedRect().containsPoint(f)
            },
            getRect: function() {
                var g = this.node;
                var h = e.getMillimeter(g.parent.measureUnit);
                var f = g.bounds.clone();
                return new c(f.right() - 5 * h, f.y, 5 * h, g.getCaptionHeight())
            },
            getRotatedRect: function() {
                var g = this.getRect();
                if (this.node.rotationAngle != 0) {
                    var k = [];
                    k.push(g.topLeft());
                    k.push(g.topRight());
                    k.push(g.bottomRight());
                    k.push(g.bottomLeft());
                    b.Utils.rotatePointsAt(k, b.Utils.getCenter(this.node.bounds), this.node.rotationAngle);
                    var f = Math.min(k[0].x, Math.min(k[1].x, Math.min(k[2].x, k[3].x)));
                    var l = Math.min(k[0].y, Math.min(k[1].y, Math.min(k[2].y, k[3].y)));
                    var j = Math.max(k[0].x, Math.max(k[1].x, Math.max(k[2].x, k[3].x)));
                    var h = Math.max(k[0].y, Math.max(k[1].y, Math.max(k[2].y, k[3].y)));
                    return c.fromLTRB(f, l, j, h)
                }
                return g
            },
            updateContent: function() {
                var k = this.node;
                var n = k.getEffectiveTextColor();
                var f = k.getEffectiveStroke();
                var o = MindFusion.Diagramming.Utils.rgbToString(100, 100, 100, 0.2);
                var l = e.getMillimeter(k.parent.measureUnit);
                var h = 3 * l / 4;
                var p = this.getRect();
                p.x = p.y = 0;
                p.pen = f;
                this.content = [p];
                var j = p.clone();
                j.pen = n;
                j.height = p.height / 2;
                if (!k.canScrollUp()) {
                    j.brush = o;
                    this.content.push(j)
                }
                var j = j.clone();
                j.pen = n;
                j.y += p.height / 2;
                if (!k.canScrollDown()) {
                    j.brush = o;
                    this.content.push(j)
                }
                var g = n;
                var q = new d();
                q.moveTo(p.width / 2, h);
                q.lineTo(p.width - h, p.height / 2 - h);
                q.lineTo(h, p.height / 2 - h);
                q.close();
                q.done();
                q.setBrush(g);
                this.content.push(q);
                var q = new d();
                q.moveTo(p.width / 2, p.height - h);
                q.lineTo(p.width - h, p.height / 2 + h);
                q.lineTo(h, p.height / 2 + h);
                q.close();
                q.done();
                q.setBrush(g);
                this.content.push(q)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Scroller", b.Manipulator)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.SelectOnlyBehavior = function(d, c) {
            mflayer.initializeBase(b, this, [d])
        };
        b.prototype = {
            createController: function(c) {
                return new a.CreateSelectionController(this.diagram.selection)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.SelectOnlyBehavior", a.BehaviorBase)
    })(MindFusion.Diagramming);
    (function(b) {
        var c = MindFusion.Drawing.Rect;
        var e = MindFusion.Collections.Dictionary;
        var a = MindFusion.Collections.ArrayList;
        var d = b.Selection = function(f) {
            mflayer.initializeBase(d, this, [f]);
            this.items = [];
            this.nodes = [];
            this.links = [];
            this.allowMultipleSelection = true;
            this.bounds = new c(0, 0, 0, 0)
        };
        d.prototype = {
            startDrag: function(f) {
                mflayer.callBaseMethod(d, this, "startDrag", [f]);
                this.savedBounds = this.bounds.clone()
            },
            updateDrag: function(g) {
                if (g.action === b.Action.Modify) {
                    var h = b.Utils.subtract(g.currentPoint, g.startPoint);
                    var f = this.savedBounds.topLeft().addVector(h);
                    this.bounds.setLocation(f)
                }
            },
            endDrag: function(f) {
                if (f.action === b.Action.Create) {
                    var g = c.fromPoints(f.startPoint, f.currentPoint);
                    this.selectItemsInRect(g);
                    this.parent.invalidate()
                } else {
                    if (f.action === b.Action.Modify) {
                        this.parent.raiseSelectionMoved()
                    }
                }
            },
            allowDrag: function(g) {
                for (var h = 0, f = this.nodes.length; h < f; h++) {
                    var j = this.nodes[h];
                    if (!j.allowDrag(g)) {
                        return false
                    }
                }
                return true
            },
            saveLocationState: function() {
                return {
                    bounds: this.bounds.clone()
                }
            },
            addItem: function(f) {
                if (!f) {
                    return
                }
                this.addItemInternal(f);
                this.parent.activeItem = f
            },
            addItemInternal: function(f) {
                if (f.getSelected()) {
                    return
                }
                this.items.push(f);
                f.setSelectedState(true);
                if (mflayer.isInstanceOfType(b.DiagramNode, f)) {
                    this.nodes.push(f);
                    f.updateAnchorVisibility4()
                } else {
                    this.links.push(f)
                }
                this.bounds = this.items.length == 1 ? f.getRotatedBounds() : b.Utils.unionRects(this.bounds, f.getRotatedBounds());
                this.parent.raiseSelected(f)
            },
            removeItem: function(f) {
                if (!this.removeItemInternal(f)) {
                    return false
                }
                if (!this.parent.activeItem.getSelected()) {
                    this.parent.activeItem = (this.items.length > 0) ? this.items[0] : null
                }
                return true
            },
            removeItemInternal: function(f) {
                if (this.itemInSelection(f)) {
                    a.remove(this.items, f);
                    if (mflayer.isInstanceOfType(b.DiagramNode, f)) {
                        a.remove(this.nodes, f)
                    } else {
                        a.remove(this.links, f)
                    }
                    f.setSelectedState(false);
                    if (mflayer.isInstanceOfType(b.DiagramNode, f)) {
                        f.updateAnchorVisibility4()
                    }
                    this.recalcRect();
                    this.parent.raiseDeselected(f);
                    return true
                }
                return false
            },
            getBounds: function() {
                return this.bounds
            },
            recalcRect: function() {
                this.bounds = new c(0, 0, 0, 0);
                for (var g = 0, f = this.items.length; g < f; g++) {
                    var h = this.items[g];
                    b.Utils.unionRects(this.bounds, h.getRotatedBounds())
                }
            },
            clear: function() {
                this.clearInternal();
                this.parent.activeItem = null
            },
            clearInternal: function() {
                for (var g = 0, f = this.items.length; g < f; g++) {
                    this.items[g].setSelectedState(false);
                    this.parent.raiseDeselected(this.items[g]);
                    if (mflayer.isInstanceOfType(b.DiagramNode, this.items[g])) {
                        this.items[g].updateAnchorVisibility4()
                    }
                }
                this.items = [];
                this.nodes = [];
                this.links = []
            },
            selectSingle: function(f) {
                this.clearInternal();
                this.items.push(f);
                f.invalidate()
            },
            itemInSelection: function(g) {
                for (var f = 0; f < this.items.length; f++) {
                    if (this.items[f] === g) {
                        return true
                    }
                }
                return false
            },
            selectItemsInRect: function(j) {
                this.clearInternal();
                var g = [];
                this.parent.getIntersectingItems(j, g, this.allowMultipleSelection, true);
                for (var h = 0, f = g.length; h < f; h++) {
                    this.addItemInternal(g[h])
                }
                if (this.items.length === 0) {
                    this.parent.activeItem = null
                } else {
                    if (this.parent.activeItem == null || !this.parent.activeItem.getSelected()) {
                        this.parent.activeItem = this.items[0]
                    }
                }
            },
            onRemove: function() {},
            cloneNodes: function(j) {
                var f = [];
                for (var h = 0, g = this.items.length; h < g; h++) {
                    if (mflayer.isInstanceOfType(b.DiagramNode, this.items[h])) {
                        var k = this.items[h].clone();
                        if (this.items[h].container != null && j.contains(this.items[h].container)) {
                            k.container = j.get(this.items[h].container)
                        }
                        if (this.items[h].masterNode != null && j.contains(this.items[h].masterNode)) {
                            k.masterNode = j.get(this.items[h].masterNode)
                        }
                        j.set(this.items[h], k);
                        f.push(k)
                    }
                }
                return f
            },
            cloneLinks: function(k) {
                var f = [];
                for (var h = 0, g = this.items.length; h < g; h++) {
                    if (mflayer.isInstanceOfType(b.DiagramLink, this.items[h])) {
                        var j = this.items[h];
                        var n = j.clone();
                        if (this.items[h].origin != null && k.contains(this.items[h].origin)) {
                            n.origin = k.get(this.items[h].origin)
                        } else {
                            n.origin = null
                        }
                        if (this.items[h].destination != null && k.contains(this.items[h].destination)) {
                            n.destination = k.get(this.items[h].destination)
                        } else {
                            n.destination = null
                        }
                        n.setupOriginConnection(j.originConnection.clone(n, n.origin == null ? new b.DummyNode() : n.origin));
                        n.setupDestConnection(j.destinationConnection.clone(n, n.destination == null ? new b.DummyNode() : n.destination));
                        f.push(n)
                    }
                }
                return f
            },
            toJson: function() {
                var q = [];
                var n = new e();
                var f = this.cloneNodes(n);
                var o = this.cloneLinks(n);
                var j = 0;
                for (var h = 0, g = f.length; h < g; h++) {
                    f[h].instanceId = j++
                }
                for (var h = 0, g = f.length; h < g; h++) {
                    var p = f[h].toJson();
                    q.push(p)
                }
                for (var h = 0, g = o.length; h < g; h++) {
                    var k = o[h];
                    k.instanceId = j++;
                    var p = k.toJson();
                    q.push(p)
                }
                return mflayer.toJson({
                    items: q
                })
            },
            getHandlePosition: function(f) {
                if (mflayer.isInstanceOfType(b.DiagramNode, this.parent.activeItem)) {
                    return this.parent.activeItem.getHandlePosition(f)
                }
                return this.bounds.topLeft()
            },
            handleAtPoint: function(f) {
                if (this.items.length <= 1) {
                    return null
                }
                var g = this.parent;
                var j = g.getHandleAt(f, true);
                if (j) {
                    if (g.allowMultipleResize && mflayer.isInstanceOfType(b.DiagramNode, j.item)) {
                        return j
                    }
                    return {
                        item: this,
                        index: 8
                    }
                }
                var h = this.parent.getItemAt(f);
                if (h != null && h.getSelected()) {
                    return {
                        item: this,
                        index: 8
                    }
                }
                return null
            }
        };
        MindFusion.registerClass(d, "MindFusion.Diagramming.Selection", b.DiagramItem)
    })(MindFusion.Diagramming);
    (function(c) {
        var d = MindFusion.Drawing.Path;
        var b = MindFusion.Drawing.Matrix;
        var e = MindFusion.Drawing.Point;
        var a = MindFusion.Collections.ArrayList;
        var f = c.Shape = function(j, h) {
            if (!j) {
                j = {}
            }
            this.params = j;
            if (!this.params.fillMode) {
                this.params.fillMode = "nonzero"
            }
            if (j.id) {
                this.id = j.id;
                if (h !== true) {
                    g[j.id] = this
                }
            }
            if (h === true) {
                this.dummy = true
            }
        };
        var g = f.shapes = [];
        defaultShapesDefined = false;
        f.loadFromLibPending = false;
        f.fromId = function(h) {
            if (f.loadFromLibPending) {
                return f.createDummyShape(h)
            }
            if (!defaultShapesDefined) {
                f.initializeDefault()
            }
            return g[h]
        };
        f.component = function(n, l, k) {
            var j = f.fromId(n);
            if (!j) {
                j = f.fromId("Rectangle")
            }
            var h = j.clone();
            h.isOutline = l;
            if (k) {
                if (l && !k.outlineRenderer) {
                    h.host = k;
                    k.outlineRenderer = new c.ShapeRenderer(h)
                }
            }
            h.shapeRenderer = new c.ShapeRenderer(h);
            return h
        };
        f.createDummyShape = function(h) {
            return new f({
                id: h,
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0"
            }, true)
        };
        f.registerDefaultShape = function(h) {
            if (!h || !h.id) {
                return
            }
            if (!defaultShapesDefined) {
                f.initializeDefault()
            }
            g[h.id] = h
        };
        f.initializeDefault = function() {
            defaultShapesDefined = true;
            var k = {};
            var h = [];
            h.push(k = {
                id: "Actor",
                outline: "M50,20  A10, 10, 0, 0, 1, 50, 0 A10, 10, 0, 0, 1, 50, 20  L70,20  A5, 5, 0, 0, 1, 75, 25  L75,60 L68,60 L68,30 L64,30 L64,100 L52,100 L52,65 L48,65 L48,100 L36,100 L36,30 L32,30 L32,60 L25,60 L25,25  A5, 5, 0, 0, 1, 30, 20  L50,20"
            });
            h.push(k = {
                id: "Alternative",
                outline: "M0,100 L50,0 L100,100 L0,100"
            });
            h.push(k = {
                id: "Arrow",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,95 L50,0 L13,95"
            });
            h.push(k = {
                id: "Arrow1",
                outline: "M40,50 L0,0 L60,0 L100,50 L60,100 L0,100 L40,50"
            });
            h.push(k = {
                id: "Arrow2",
                outline: "M0,0 L25,0 L25,40 L60,40 L60,0 L100,50 L60,100 L60,60 L25,60 L25,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "Arrow3",
                outline: "M0,30 L60,30 L60,0 L100,50 L60,100 L60,70 L0,70 L0,30"
            });
            h.push(k = {
                id: "Arrow4",
                outline: "M0,30 L60,30 L60,0 L100,50 L60,100 L60,70 L0,70 L20,50 L0,30"
            });
            h.push(k = {
                id: "Arrow5",
                outline: "M30,30 L30,0 L0,50 L30,100 L30,70 L70,70 L70,100 L100,50 L70,0 L70,30 L30,30"
            });
            h.push(k = {
                id: "Arrow6",
                outline: "M0,100 C50,66,50,33,0,0 L100,50 L0,100"
            });
            h.push(k = {
                id: "Arrow7",
                outline: "M0,0 L70,0 L100,50 L70,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "Arrow8",
                outline: "M40,0 L40,35 L0,0 L0,100 L40,65 L40,100 L100,50 L40,0",
                decoration: "M40,35 L40,65"
            });
            h.push(k = {
                id: "Arrow9",
                outline: "M0,0 L30,50 L0,100 L100,50 L0,0"
            });
            h.push(k = {
                id: "BackSlash",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,-37 L87,37"
            });
            h.push(k = {
                id: "BeginLoop",
                outline: "M0,25 L0,25 L0,100 L100,100 L100,25 L75,0 L25,0 L0,25"
            });
            h.push(k = {
                id: "BowArrow",
                outline: "M50,0 L94,95 L60,75 L60,95 L40,95 L40,75 L6,95 L50,0"
            });
            h.push(k = {
                id: "BpmnComplex",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M20,45 L38,45 L25,32 L32,25 L45,38 L45,20 L55,20 L55,38 L68,25 L75,32 L62,45 L80,45 L80,55 L62,55 L75,68 L68,75 L55,62 L55,80 L45,80 L45,62 L32,75 L25,68 L38,55 L20,55 L20,45"
                }]
            });
            h.push(k = {
                id: "BpmnDataBasedXor",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M45,50 L33,26 L43,26 L50,40 L57,26 L67,26 L55,50 L67,74 L57,74 L50,60 L43,74 L33,74 L45,50"
                }]
            });
            h.push(k = {
                id: "BpmnEndCancel",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M45,50 L23,28 L28,23 L50,45 L73,23 L78,28 L55,50 L78,73 L73,78 L50,55 L28,78 L23,73 L45,50"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndCompensation",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M14,50 L50,30 L50,70 L14,50"
                }, {
                    path: "M47,50 L83,30 L83,70 L47,50"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndError",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M77,23 L60,65 L43,45 L23,77 L40,35 L57,55 L77,23"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30",
                shapeDecorations: [{
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndMultiple",
                outline: "M100,50  A50, 50, 0, 1, 1, 99.2403876506104, 41.31759111665348 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEndTerminate",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999 "
                }, {
                    path: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  L90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  L100,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnEventBasedXor",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M70,50  A20, 20, 0, 0, 1, 30, 50 A20, 20, 0, 0, 1, 70, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M44,41 L50,32 L56,41 L66,41 L61,50 L66,59 L56,59 L50,68 L44,59 L34,59 L39,50 L34,41 L44,41"
                }]
            });
            h.push(k = {
                id: "BpmnInclusive",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  L70,50  A20, 20, 0, 0, 1, 30, 50 A20, 20, 0, 0, 1, 70, 49.99999999999999  L80,50",
                    fillMode: "evenodd"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateCancel",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M45,50 L23,28 L28,23 L50,45 L73,23 L78,28 L55,50 L78,73 L73,78 L50,55 L28,78 L23,73 L45,50"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateCompensation",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M14,50 L50,30 L50,70 L14,50"
                }, {
                    path: "M47,50 L83,30 L83,70 L47,50"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateError",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M77,23 L60,65 L43,45 L23,77 L40,35 L57,55 L77,23"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30"
            });
            h.push(k = {
                id: "BpmnIntermediateMultiple",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateRule",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999 ",
                shapeDecorations: [{
                    path: "M25,20 L75,20 L75,80 L25,80 L25,20",
                    brush: "#FFFFFF"
                }, {
                    path: "M45,30 L55,30 L55,31 L45,31 L45,30",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,47 L60,47 L60,48 L40,48 L40,47",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,65 L60,65 L60,66 L40,66 L40,65",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }]
            });
            h.push(k = {
                id: "BpmnIntermediateTimer",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M90,50  A40, 40, 0, 0, 1, 10, 50.00000000000001 A40, 40, 0, 0, 1, 90, 49.99999999999999  M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M20,50 L30,50 M24,35 L30,39 M35,24 L39,30 M50,20 L50,30 M65,24 L61,30 M76,35 L70,39 M70,50 L80,50 M76,65 L70,61 M65,76 L61,70 M50,70 L50,80 M24,65 L30,61 M35,76 L39,70 M50,50 L53,24 M50,50 L67,50"
            });
            h.push(k = {
                id: "BpmnParallelFork",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                shapeDecorations: [{
                    path: "M20,45 L45,45 L45,20 L55,20 L55,45 L80,45 L80,55 L55,55 L55,80 L45,80 L45,55 L20,55 L20,45"
                }]
            });
            h.push(k = {
                id: "BpmnStartLink",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M20,35 L77,35 L77,20 L88,50 L77,80 L77,65 L20,65 L20,35"
                }]
            });
            h.push(k = {
                id: "BpmnStartMessage",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M17,30 L83,30 L83,70 L17,70 L17,30 L50,50 L83,30"
            });
            h.push(k = {
                id: "BpmnStartMultiple",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M39,31 L50,12 L61,31 L83,31 L72,50 L83,69 L61,69 L50,88 L39,69 L18,69 L27,50 L17,31 L39,31"
                }]
            });
            h.push(k = {
                id: "BpmnStartRule",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                shapeDecorations: [{
                    path: "M25,20 L75,20 L75,80 L25,80 L25,20",
                    brush: "#FFFFFF"
                }, {
                    path: "M45,30 L55,30 L55,31 L45,31 L45,30",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,47 L60,47 L60,48 L40,48 L40,47",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }, {
                    path: "M40,65 L60,65 L60,66 L40,66 L40,65",
                    brush: "rgba(242,242,252,0)",
                    pen: {
                        brush: "#000000",
                        dashStyle: 0,
                        width: 1
                    }
                }]
            });
            h.push(k = {
                id: "BpmnStartTimer",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M80,50  A30, 30, 0, 0, 1, 20, 50.00000000000001 A30, 30, 0, 0, 1, 80, 49.99999999999999  M20,50 L30,50 M24,35 L30,39 M35,24 L39,30 M50,20 L50,30 M65,24 L61,30 M76,35 L70,39 M70,50 L80,50 M76,65 L70,61 M65,76 L61,70 M50,70 L50,80 M24,65 L30,61 M35,76 L39,70 M50,50 L53,24 M50,50 L67,50"
            });
            h.push(k = {
                id: "Circle",
                fillMode: "evenodd",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 "
            });
            h.push(k = {
                id: "Cloud",
                outline: "M67,0 C58,2,61,7,60,19 C49,11,51,8,43,14 C37,19,40,25,41,33 C35,24,27,13,13,21 C10,25,7,29,15,44 C5,47,0,50,0,63 C3,74,17,72,27,71 C21,77,14,93,27,100 C38,100,52,93,55,78 C70,93,81,87,88,80 C91,69,87,63,79,57 C90,52,100,43,100,24 C96,7,77,0,67,0"
            });
            h.push(k = {
                id: "Collate",
                outline: "M100,100 L0,100 L100,0 L0,0 L100,100"
            });
            h.push(k = {
                id: "ConeDown",
                outline: "M0,80 C6,94,30,100,50,100 C70,100,94,94,100,80 L50,0 L0,80",
                decoration: "M0,80 C10,65,30,60,50,60 C70,60,90,65,100,80"
            });
            h.push(k = {
                id: "ConeUp",
                outline: "M0,80 C6,94,30,100,50,100 C70,100,94,94,100,80 L50,0 L0,80"
            });
            h.push(k = {
                id: "ConnectedIssues",
                outline: "M0,10 L40,50 L0,90 L10,100 L50,60 L90,100 L100,90 L60,50 L100,10 L90,0 L50,40 L10,0 L0,10"
            });
            h.push(k = {
                id: "CreateRequest",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15 M0,85 L100,85"
            });
            h.push(k = {
                id: "Cross",
                outline: "M40,40 L40,0 L60,0 L60,40 L100,40 L100,60 L60,60 L60,100 L40,100 L40,60 L0,60 L0,40 L40,40"
            });
            h.push(k = {
                id: "Cube",
                outline: "M70,100 L70,100 L0,100 L0,30 L70,30 L0,30 L30,0 L100,0 L70,30 L100,0 L100,70 L70,100 L70,30 L70,100"
            });
            h.push(k = {
                id: "Cylinder",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20"
            });
            h.push(k = {
                id: "Database",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20 M100,30 C100,45,70,50,50,50 C30,50,0,45,0,30 M100,40 C100,55,70,60,50,60 C30,60,0,55,0,40"
            });
            h.push(k = {
                id: "DataTransmition",
                outline: "M15,100 L85,100 L100,50 L85,0 L15,0 L0,50 L15,100"
            });
            h.push(k = {
                id: "DDelay",
                outline: "M0,100 L67,100 C85,100,100,75,100,50 C100,25,85,0,67,0 L0,0 C15,0,33,25,33,50 C33,75,15,100,0,100"
            });
            h.push(k = {
                id: "Decision",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0"
            });
            h.push(k = {
                id: "Decision2",
                outline: "M0,50 L25,100 L75,100 L100,50 L75,0 L25,0 L0,50"
            });
            h.push(k = {
                id: "DefaultFlow",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,111 L87,37"
            });
            h.push(k = {
                id: "Delay",
                outline: "M0,0 L50,0 C80,0,100,30,100,50 C100,70,80,100,50,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "DInDelay",
                outline: "M0,100 L100,100 C85,100,67,75,67,50 C67,25,85,0,100,0 L0,0 C15,0,33,25,33,50 C33,75,15,100,0,100"
            });
            h.push(k = {
                id: "DirectAccessStorage",
                outline: "M10,0 L90,0 C95.52284749830794,0,100,22.38576250846033,100,50 C100,77.61423749153967,95.52284749830794,100,90,100 L10,100 C4.477152501692068,100,1.7763568394002505e-15,77.61423749153967,0,50.00000000000001 C0,22.38576250846034,4.477152501692064,7.105427357601002e-15,9.999999999999998,0",
                decoration: "M10,0 C15.522847498307934,0,20,22.38576250846033,20,50 C20,77.61423749153967,15.522847498307934,100,10,100"
            });
            h.push(k = {
                id: "DiskStorage",
                outline: "M100,20 L100,80 C100,95,70,100,50,100 C30,100,0,95,0,80 L0,20 C0,5,30,0,50,0 C70,0,100,5,100,20",
                decoration: "M100,20 C100,35,70,40,50,40 C30,40,0,35,0,20 M100,30 C100,45,70,50,50,50 C30,50,0,45,0,30"
            });
            h.push(k = {
                id: "Display",
                outline: "M40,100 C15,100,0,70,0,50 C0,30,15,0,40,0 L85,0 C100,20,100,30,100,50 C100,70,100,80,85,100 L40,100"
            });
            h.push(k = {
                id: "DividedEvent",
                outline: "M10,100 L90,100 C95,100,100,95,100,90 L100,10 C100,5,95,0,90,0 L10,0 C5,0,0,5,0,10 L0,90 C0,95,5,100,10,100",
                decoration: "M0,15 L100,15"
            });
            h.push(k = {
                id: "DividedProcess",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15"
            });
            h.push(k = {
                id: "Document",
                outline: "M0,90 L0,0 L100,0 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90"
            });
            h.push(k = {
                id: "DoubleArrow",
                outline: "M50,0 L87,95 L50,95 L87,190 L13,190 L50,95 L50,95 L13,95 L50,0"
            });
            h.push(k = {
                id: "DOutDelay",
                outline: "M33,100 L67,100 C80,100,100,75,100,50 C100,25,85,0,67,0 L33,0 C15,0,0,25,0,50 C0,75,15,100,33,100"
            });
            h.push(k = {
                id: "Ellipse",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 "
            });
            h.push(k = {
                id: "EndLoop",
                outline: "M100,75 L100,0 L0,0 L0,75 L25,100 L75,100 L100,75"
            });
            h.push(k = {
                id: "ExternalOrganization",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M10,0 L0,10 M90,0 L100,10 M90,100 L100,90 M0,90 L10,100"
            });
            h.push(k = {
                id: "ExternalProcess",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M40,10 L60,10 M40,90 L60,90 M10,40 L10,60 M90,40 L90,60"
            });
            h.push(k = {
                id: "File",
                outline: "M0,0 L0,100 L100,100 L100,30 L70,0 L0,0",
                decoration: "M70,0 L70,30 L100,30"
            });
            h.push(k = {
                id: "FramedRectangle",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M5,5 L95,5 L95,95 L5,95 L5,5"
            });
            h.push(k = {
                id: "Gate",
                outline: "M6.123233995736766e-15,0 C55.228474983079344,0,100,22.38576250846033,100,50 C100,77.61423749153967,55.228474983079344,100,6.123233995736766e-15,100 M0,100 C55,75,55,25,0,0"
            });
            h.push(k = {
                id: "Heart",
                outline: "M50,20 C50,5,65,0,75,0 C85,0,100,10,100,25 C100,50,67,75,50,100 C33,75,0,50,0,25 C0,10,15,0,25,0 C35,0,50,5,50,20"
            });
            h.push(k = {
                id: "Heptagon",
                outline: "M28,100 L0,70 L10,25 L50,0 L90,25 L100,70 L72,100 L28,100"
            });
            h.push(k = {
                id: "Hourglass",
                outline: "M0,0 L30,50 L0,100 L100,100 L70,50 L100,0 L0,0"
            });
            h.push(k = {
                id: "Input",
                outline: "M0,100 L0,100 L100,100 L100,0 L0,40 L0,100"
            });
            h.push(k = {
                id: "InternalStorage",
                outline: "M0,100 L100,100 L100,0 L0,0 L0,100",
                decoration: "M0,15 L100,15 M15,0 L15,100"
            });
            h.push(k = {
                id: "Interrupt",
                outline: "M0,0 L0,100 L100,50 L100,100 L100,0 L100,50 L0,0"
            });
            h.push(k = {
                id: "Interrupt2",
                outline: "M0,0 L0,100 L80,50 L80,20 L100,0 L80,20 L80,80 L60,100 L80,80 L80,50 L0,0"
            });
            h.push(k = {
                id: "IsoProcess",
                outline: "M0,0 L75,0 L100,50 L75,100 L0,100 L25,50 L0,0"
            });
            h.push(k = {
                id: "Junction",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M15,15 L85,85 M85,15 L15,85"
            });
            h.push(k = {
                id: "Lightning",
                outline: "M30,0 L30,0 L15,40 L45,40 L30,100 L65,30 L33,27 L56,0 L30,0"
            });
            h.push(k = {
                id: "LinedDocument",
                outline: "M0,90 L0,0 L100,0 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90",
                decoration: "M15,0 L15,96"
            });
            h.push(k = {
                id: "ManualOperation",
                outline: "M100,0 L0,0 L20,100 L80,100 L100,0"
            });
            h.push(k = {
                id: "Merge",
                outline: "M0,0 L100,0 L50,100 L0,0"
            });
            h.push(k = {
                id: "MessageFromUser",
                outline: "M0,100 L100,100 L80,50 L100,0 L0,0 L0,100"
            });
            h.push(k = {
                id: "MessageToUser",
                outline: "M100,100 L20,100 L0,50 L20,0 L100,0 L100,100"
            });
            h.push(k = {
                id: "Microform",
                outline: "M0,90 L0,10 C16,20,33,20,50,10 C66,0,83,0,100,10 L100,90 C83,80,66,80,50,90 C33,100,16,100,0,90"
            });
            h.push(k = {
                id: "MicroformProcessing",
                outline: "M0,100 L50,74 L100,100 L100,0 L50,25 L0,0 L0,100"
            });
            h.push(k = {
                id: "MicroformRecording",
                outline: "M0,100 L80,75 L100,85 L100,15 L80,25 L0,0 L0,100"
            });
            h.push(k = {
                id: "MultiDocument",
                outline: "M0,92 L0,20 L10,20 L10,10 L20,10 L20,0 L100,0 L100,72 C95,69,90,69,90,69 L90,82 C85,79,80,79,80,79 L80,92 C66,84,53,84,39,92 C26,100,13,100,0,92",
                decoration: "M10,20 L80,20 L80,79 M20,10 L90,10 L90,69"
            });
            h.push(k = {
                id: "MultiProc",
                outline: "M0,100 L80,100 L80,90 L90,90 L90,80 L100,80 L100,0 L20,0 L20,10 L10,10 L10,20 L0,20 L0,100",
                decoration: "M10,20 L80,20 L80,90 M20,10 L90,10 L90,80"
            });
            h.push(k = {
                id: "Octagon",
                outline: "M33,100 L0,67 L0,33 L33,0 L67,0 L100,33 L100,67 L67,100 L33,100"
            });
            h.push(k = {
                id: "OfflineStorage",
                outline: "M0,0 L50,100 L100,0 L0,0",
                decoration: "M10,20 L90,20"
            });
            h.push(k = {
                id: "OffpageConnection",
                outline: "M0,0 L50,0 L100,50 L50,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "OffpageReference",
                outline: "M0,70 L0,0 L100,0 L100,70 L50,100 L0,70"
            });
            h.push(k = {
                id: "Or",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M50,0 L50,100 M0,50 L100,50"
            });
            h.push(k = {
                id: "Pentagon",
                outline: "M50,0 L0,50 L15,100 L85,100 L100,50 L50,0"
            });
            h.push(k = {
                id: "PentagonArrow",
                outline: "M50,0 L87,37 L87,95 L13,95 L13,37 L50,0"
            });
            h.push(k = {
                id: "PointerArrow",
                outline: "M50,0 L87,95 L50,60 L13,95 L50,0"
            });
            h.push(k = {
                id: "PrimitiveFromCall",
                outline: "M0,100 L100,100 L80,50 L100,0 L0,0 L0,100",
                decoration: "M15,0 L15,100"
            });
            h.push(k = {
                id: "PrimitiveToCall",
                outline: "M100,100 L20,100 L0,50 L20,0 L100,0 L100,100",
                decoration: "M85,0 L85,100"
            });
            h.push(k = {
                id: "Procedure",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M15,0 L15,100 M85,0 L85,100"
            });
            h.push(k = {
                id: "Process",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0",
                decoration: "M15,0 L15,100"
            });
            h.push(k = {
                id: "Prysm",
                outline: "M50,0 L100,20 L100,80 L50,100 L50,100 L0,80 L0,20 L50,0",
                decoration: "M0,20 L50,40 L50,100 M50,40 L100,20"
            });
            h.push(k = {
                id: "PunchedCard",
                outline: "M0,100 L0,100 L0,30 L30,0 L100,0 L100,100 L0,100"
            });
            h.push(k = {
                id: "PyramidDown",
                outline: "M50,100 L100,80 L50,0 L0,80 L50,100",
                decoration: "M0,80 L50,60 M50,0 L50,60 M100,80 L50,60"
            });
            h.push(k = {
                id: "PyramidUp",
                outline: "M50,100 L100,80 L50,0 L0,80 L50,100",
                decoration: "M50,0 L50,100"
            });
            h.push(k = {
                id: "Quill",
                outline: "M50,0 L87,37 L87,95 L50,58 L13,95 L13,37 L50,0"
            });
            h.push(k = {
                id: "Rectangle",
                outline: "M0,0 L100,0 L100,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "Reversed",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,0 L50,95 L13,0"
            });
            h.push(k = {
                id: "RevTriangle",
                outline: "M87,0 L50,95 L13,0 L87,0"
            });
            h.push(k = {
                id: "RevWithCirc",
                fillMode: "evenodd",
                outline: "M84,147  A37, 37, 0, 0, 1, 10, 147 A37, 37, 0, 0, 1, 84, 147 ",
                decoration: "M87,0 L50,95 L13,0"
            });
            h.push(k = {
                id: "RevWithLine",
                fillMode: "evenodd",
                outline: "",
                decoration: "M87,0 L50,95 L13,0 M13,110 L87,110"
            });
            h.push(k = {
                id: "Rhombus",
                outline: "M50,0 L83,55 L50,100 L17,55 L50,0"
            });
            h.push(k = {
                id: "RoundRect",
                outline: "U0,0,100,100,2.5"
            });
            h.push(k = {
                id: "RSave",
                outline: "M30,100 L100,100 L70,0 L0,0 L30,100"
            });
            h.push(k = {
                id: "Save",
                outline: "M0,100 L25,0 L100,0 L75,100 L0,100"
            });
            h.push(k = {
                id: "Slash",
                fillMode: "evenodd",
                outline: "",
                decoration: "M13,37 L87,-37"
            });
            h.push(k = {
                id: "Sort",
                outline: "M50,0 L100,50 L50,100 L0,50 L50,0",
                decoration: "M0,50 L100,50"
            });
            h.push(k = {
                id: "Sphere",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986 ",
                decoration: "M50,0 C25,25,25,75,50,100"
            });
            h.push(k = {
                id: "Star",
                outline: "M50,0 L50,0 L40,33 L0,30 L30,50 L15,100 L50,60 L85,100 L67,50 L100,30 L60,33 L50,0"
            });
            h.push(k = {
                id: "Start",
                outline: "M15,100 C5,100,0,75,0,50 C0,25,5,0,15,0 L85,0 C95,0,100,25,100,50 C100,75,95,100,85,100 L15,100",
                decoration: "M15,0 L15,100 M85,0 L85,100"
            });
            h.push(k = {
                id: "Tape",
                outline: "M50,100  A50, 50, 0, 1, 1, 74.99999999999998, 93.30127018922194  M75,93.30127 L100,93.30127 L100,100 L50,100"
            });
            h.push(k = {
                id: "Terminator",
                outline: "M20,100 L80,100 C90,100,100,75,100,50 C100,25,90,0,80,0 L20,0 C10,0,0,25,0,50 C0,75,10,100,20,100"
            });
            h.push(k = {
                id: "Tetragon",
                outline: "M50,0 L83,80 L50,100 L17,80 L50,0"
            });
            h.push(k = {
                id: "TransmittalTape",
                outline: "M60,90 L100,100 L100,0 L0,0 L0,90 L60,90"
            });
            h.push(k = {
                id: "Triangle",
                outline: "M50,0 L87,95 L13,95 L50,0"
            });
            h.push(k = {
                id: "RightTriangle",
                outline: "M0,0 L100,100 L0,100 L0,0"
            });
            h.push(k = {
                id: "Decagon",
                outline: "M100,50 L90.45085,80.9017 L65.45085,100 L34.54915,100 L9.54915,80.9017 L0,50 L9.54915,19.0983 L34.54915,0.000002414559 L65.45085,0.000002414559 L90.45085,19.0983 L100,50"
            });
            h.push(k = {
                id: "Trapezoid",
                outline: "M10,0 L90,0 L100,100 L0,100 L10,0"
            });
            h.push(k = {
                id: "Star4Pointed",
                outline: "M50,0 L64.14214,35.85786 L100,50 L64.14214,64.14214 L50,100 L35.85786,64.14214 L0,50 L35.85786,35.85786 L50,0"
            });
            h.push(k = {
                id: "Star5Pointed",
                outline: "M50,0 L60.58014,35.43769 L97.55283,34.54915 L67.11902,55.56231 L79.38926,90.45085 L50,68 L20.61074,90.45085 L32.88098,55.56231 L2.447174,34.54915 L39.41986,35.43769 L50,0"
            });
            h.push(k = {
                id: "Star6Pointed",
                outline: "M50,0 L58,36.14359 L93.30127,25 L66,50 L93.30127,75 L58,63.85641 L50,100 L42,63.85641 L6.69873,75 L34,50 L6.69873,25 L42,36.14359 L50,0"
            });
            h.push(k = {
                id: "Star7Pointed",
                outline: "M50,0 L56.94214,35.5845 L89.09158,18.82551 L65.59885,46.43967 L98.7464,61.12605 L62.5093,59.97584 L71.69418,95.04845 L50,66 L28.30581,95.04845 L37.4907,59.97584 L1.253604,61.12605 L34.40115,46.43967 L10.90843,18.82551 L43.05786,35.5845 L50,0"
            });
            h.push(k = {
                id: "Star16Pointed",
                outline: "M50,0 L57.80361,10.76859 L69.13417,3.806023 L72.22281,16.74121 L85.35534,14.64466 L83.25878,27.77719 L96.19398,30.86583 L89.23141,42.19639 L100,50 L89.23141,57.80361 L96.19398,69.13417 L83.25878,72.22281 L85.35534,85.35534 L72.22281,83.25878 L69.13417,96.19398 L57.80361,89.23141 L50,100 L42.19639,89.23141 L30.86583,96.19398 L27.77719,83.25878 L14.64466,85.35534 L16.74121,72.22281 L3.806023,69.13417 L10.76859,57.80361 L0,50 L10.76859,42.19639 L3.806023,30.86583 L16.74121,27.77719 L14.64466,14.64466 L27.77719,16.74121 L30.86583,3.806023 L42.19639,10.76859 L50,0"
            });
            h.push(k = {
                id: "Star24Pointed",
                outline: "M50,0 L55.22105,10.34221 L62.94095,1.703709 L65.30733,13.04482 L75,6.69873 L74.35046,18.26587 L85.35534,14.64466 L81.73413,25.64954 L93.30127,25 L86.95518,34.69266 L98.29629,37.05905 L89.65779,44.77895 L100,50 L89.65779,55.22105 L98.29629,62.94095 L86.95518,65.30733 L93.30127,75 L81.73413,74.35046 L85.35534,85.35534 L74.35046,81.73413 L75,93.30127 L65.30733,86.95518 L62.94095,98.29629 L55.22105,89.65779 L50,100 L44.77895,89.65779 L37.05905,98.29629 L34.69266,86.95518 L25,93.30127 L25.64954,81.73413 L14.64466,85.35534 L18.26587,74.35046 L6.69873,75 L13.04482,65.30733 L1.703709,62.94095 L10.34221,55.22105 L0,50 L10.34221,44.77895 L1.703709,37.05905 L13.04482,34.69266 L6.69873,25 L18.26587,25.64954 L14.64466,14.64466 L25.64954,18.26587 L25,6.69873 L34.69266,13.04482 L37.05905,1.703709 L44.77895,10.34221 L50,0"
            });
            h.push(k = {
                id: "Star32Pointed",
                outline: "M50,0 L53.92068,10.19261 L59.75452,0.960736 L61.61139,11.72239 L69.13417,3.806023 L68.85587,14.72315 L77.77851,8.426519 L75.37573,19.07958 L85.35534,14.64466 L80.92042,24.62427 L91.57348,22.22149 L85.27685,31.14413 L96.19398,30.86583 L88.27761,38.38861 L99.03926,40.24548 L89.80739,46.07932 L100,50 L89.80739,53.92068 L99.03926,59.75452 L88.27761,61.61139 L96.19398,69.13417 L85.27685,68.85587 L91.57348,77.77851 L80.92042,75.37573 L85.35534,85.35534 L75.37573,80.92042 L77.77851,91.57348 L68.85587,85.27685 L69.13417,96.19398 L61.61139,88.27761 L59.75452,99.03926 L53.92068,89.80739 L50,100 L46.07932,89.80739 L40.24548,99.03926 L38.38861,88.27761 L30.86583,96.19398 L31.14413,85.27685 L22.22149,91.57348 L24.62427,80.92042 L14.64466,85.35534 L19.07958,75.37573 L8.426519,77.77851 L14.72315,68.85587 L3.806023,69.13417 L11.72239,61.61139 L0.960736,59.75452 L10.19261,53.92068 L0,50 L10.19261,46.07932 L0.960736,40.24548 L11.72239,38.38861 L3.806023,30.86583 L14.72315,31.14413 L8.426519,22.22149 L19.07958,24.62427 L14.64466,14.64466 L24.62427,19.07958 L22.22149,8.426519 L31.14413,14.72315 L30.86583,3.806023 L38.38861,11.72239 L40.24548,0.960736 L46.07932,10.19261 L50,0"
            });
            h.push(k = {
                id: "Donut",
                fillMode: "evenodd",
                outline: "M100,50  A50, 50, 0, 0, 1, 0, 50.00000000000001 A50, 50, 0, 0, 1, 100, 49.999999999999986  M74,50  A24, 24, 0, 0, 1, 26, 50.00000000000001 A24, 24, 0, 0, 1, 74, 50 "
            });
            h.push(k = {
                id: "Plaque",
                outline: "M10,0 L90,0  A10, 10, 0, 0, 0, 100, 10  L100,90  A10, 10, 0, 0, 0, 90, 100  L10,100  A10, 10, 0, 0, 0, 6.123233995736766e-16, 90  L0,10  A10, 10, 0, 0, 0, 10, 0 "
            });
            for (var j = 0; j < h.length; j++) {
                new f(h[j])
            }
        };
        f.prototype = {
            loadFromXml: function(u, h) {
                this.params = {};
                this.params.id = this.id = u.getAttribute("id");
                var j = u.getAttribute("fill-mode");
                if (j == "Alternate") {
                    this.params.fillMode = "evenodd"
                } else {
                    this.params.fillMode = "nonzero"
                }
                var t = h.selectSingleNode("outline", u);
                if (t) {
                    this.params.outline = this.xmlCollectionToPath(t, h)
                }
                var n = h.selectSingleNode("decorations", u);
                if (n) {
                    this.params.decoration = this.xmlCollectionToPath(n, h)
                }
                var s = h.selectSingleNode("shape-decorations", u);
                if (s && s.childNodes.length > 0) {
                    this.params.shapeDecorations = [];
                    for (var o = 0; o < s.childNodes.length; o++) {
                        var l = s.childNodes[o];
                        if (l.nodeType !== 1) {
                            continue
                        }
                        var r = h.selectSingleNode("decorations", l);
                        var q = {};
                        q.path = this.xmlCollectionToPath(r, h);
                        var p = h.selectSingleNode("brush", l);
                        if (p) {
                            q.brush = h.readBrushContent(p)
                        }
                        var k = h.selectSingleNode("pen", l);
                        if (k) {
                            q.pen = h.readPen("pen", l)
                        }
                        q.fillMode = "nonzero";
                        var v = h.selectSingleNode("fill-mode", l);
                        if (v && v.textContent == "0") {
                            q.fillMode = "evenodd"
                        }
                        this.params.shapeDecorations.push(q)
                    }
                }
            },
            xmlCollectionToPath: function(h, o) {
                var p = [];
                for (var n = 0; n < h.childNodes.length; n++) {
                    var r = h.childNodes[n];
                    if (r.nodeType !== 1) {
                        continue
                    }
                    var q = this.xmlElementToPath(r);
                    if (Array.isArray(q[0])) {
                        p = p.concat(q)
                    } else {
                        if (q[0] != "none") {
                            p.push(q)
                        }
                    }
                }
                this.pt = null;
                var k = "";
                for (var n = 0; n < p.length; n++) {
                    var q = p[n];
                    if (q[0] instanceof Array) {
                        for (var l = 0; l < q.length; l++) {
                            k += this.processPathString(q[l]);
                            k += " "
                        }
                    } else {
                        k += this.processPathString(q);
                        if (n == 0 && q[0] == "bezier" && k.substring(0, 1) != "M") {
                            k = "M" + q[1] + "," + q[2] + " " + k
                        }
                        k += " "
                    }
                }
                return k.trim()
            },
            processPathString: function(k) {
                var h = "";
                switch (k[0]) {
                    case "arc":
                        if (this.pt == null || this.pt.x != k[7] || this.pt.y != k[8]) {
                            h += "M" + k[7] + "," + k[8] + " "
                        }
                        var j = k[5] - k[4];
                        h += "A" + k[3] + "," + k[3] + ",0," + (Math.abs(j) >= Math.PI ? 1 : 0) + "," + (j > 0 ? 1 : 0);
                        this.pt = this.getArcPoint(k[1], k[2], k[3], k[5]);
                        h += "," + this.pt.x + "," + this.pt.y;
                        break;
                    case "line":
                        if (this.pt == null || this.pt.x != k[1] || this.pt.y != k[2]) {
                            h += "M" + k[1] + "," + k[2] + " L" + k[3] + "," + k[4]
                        } else {
                            h += "L" + k[3] + "," + k[4]
                        }
                        this.pt = {
                            x: k[3],
                            y: k[4]
                        };
                        break;
                    case "bezier":
                        if (this.pt == null || this.pt.x != k[1] || this.pt.y != k[2]) {
                            h += "M" + k[1] + "," + k[2] + " "
                        }
                        h += "C" + k[3] + "," + k[4] + "," + k[5] + "," + k[6] + "," + k[7] + "," + k[8];
                        this.pt = {
                            x: k[7],
                            y: k[8]
                        };
                        break;
                    case "quad":
                        if (this.pt == null || this.pt.x != k[1] || this.pt.y != k[2]) {
                            h += "M" + k[1] + "," + k[2] + " "
                        }
                        h += "Q" + k[3] + "," + k[4] + "," + k[5] + "," + k[6];
                        this.pt = {
                            x: k[5],
                            y: k[6]
                        };
                        break;
                    case "roundRect":
                        if (this.pt == null || this.pt.x != k[1] || this.pt.y != k[2]) {
                            h += "M" + k[1] + "," + k[2] + " "
                        }
                        h += "U" + k[1] + "," + k[2] + "," + k[3] + "," + k[4] + "," + k[5];
                        this.pt = {
                            x: k[4],
                            y: k[5]
                        };
                        break;
                    default:
                        break
                }
                return h
            },
            xmlElementToPath: function(o) {
                switch (o.tagName) {
                    case "arc":
                        var A = parseFloat(o.getAttribute("x"));
                        var u = parseInt(o.getAttribute("y"));
                        var B = parseFloat(o.getAttribute("arc-width"));
                        var p = parseFloat(o.getAttribute("arc-height"));
                        var z = parseFloat(o.getAttribute("start"));
                        var C = parseFloat(o.getAttribute("sweep"));
                        if (C == 360) {
                            return [this.addArc(A, u, B, p, z, 180), this.addArc(A, u, B, p, z + 180, 180)]
                        }
                        if (C == -360) {
                            return [this.addArc(A, u, B, p, z, -180), this.addArc(A, u, B, p, z - 180, -180)]
                        }
                        return this.addArc(A, u, B, p, z, C);
                    case "line":
                        var D = o.getElementsByTagName("point");
                        var n = parseFloat(D[0].getAttribute("x"));
                        var l = parseFloat(D[1].getAttribute("x"));
                        var v = parseFloat(D[0].getAttribute("y"));
                        var t = parseFloat(D[1].getAttribute("y"));
                        return ["line", n, v, l, t];
                    case "bezier":
                        var D = o.getElementsByTagName("point");
                        var n = parseFloat(D[0].getAttribute("x"));
                        var l = parseFloat(D[1].getAttribute("x"));
                        var k = parseFloat(D[2].getAttribute("x"));
                        var E = parseFloat(D[3].getAttribute("x"));
                        var v = parseFloat(D[0].getAttribute("y"));
                        var t = parseFloat(D[1].getAttribute("y"));
                        var s = parseFloat(D[2].getAttribute("y"));
                        var q = parseFloat(D[3].getAttribute("y"));
                        return ["bezier", n, v, l, t, k, s, E, q];
                    case "round-rectangle":
                        var A = parseFloat(o.getAttribute("x"));
                        var u = parseFloat(o.getAttribute("y"));
                        var B = parseFloat(o.getAttribute("w"));
                        var p = parseFloat(o.getAttribute("h"));
                        var j = parseFloat(o.getAttribute("r"));
                        return ["roundRect", A, u, A + B, u + p, j];
                    default:
                        return ["none"]
                }
            },
            addArc: function(u, s, v, r, t, z) {
                var o = v / 2;
                var l = r / 2;
                if (o == l) {
                    var n = this.getArcPoint(u + v / 2, s + r / 2, o, c.Utils.radians(t));
                    return ["arc", u + o, s + l, o, c.Utils.radians(t), c.Utils.radians(t + z), z < 0 ? 1 : 0, n.x, n.y]
                }
                var A = c.Utils.arcToBezierCurves(u, s, v, r, t, z);
                var B = [];
                for (var q = 0, k = 0; q < A.length; k++) {
                    B.push(["bezier"]);
                    for (var p = 0; p < 4; p++) {
                        if (A[q + p] == null) {
                            continue
                        }
                        B[k].push(A[q + p].x);
                        B[k].push(A[q + p].y)
                    }
                    q += 4
                }
                return B
            },
            getArcPoint: function(h, l, k, j) {
                return {
                    x: Math.round(h + Math.cos(j) * k),
                    y: Math.round(l + Math.sin(j) * k)
                }
            },
            apply: function(h) {
                h.outlinePath = new d(this.params.outline || "");
                h.outlinePath.setPen(this.params.outlinePen || "#000000");
                h.outlinePath.setBrush(this.params.outlineBrush || "#A9A9A9");
                h.decorationPath = new d(this.params.decoration || "");
                h.decorationPath.setPen(this.params.decorationPen || "#000000");
                h.decorationPath.setBrush(this.params.decorationBrush || "transparent");
                h.shapeDecorationPath = new d(this.params.shapeDecoration || "");
                h.shapeDecorationPath.setPen(this.params.shapeDecorationPen || "#000000");
                h.shapeDecorationPath.setBrush(this.params.shapeDecorationBrush || "#000000")
            },
            updateData: function(l, k, o) {
                if (k.width === 0 || k.height === 0) {
                    return
                }
                var n = this.defaultBounds;
                var h = k.width / n.width;
                var p = k.height / n.height;
                var j = new b();
                j.translate(k.x - k.width / 2, k.y - k.height / 2);
                j.scale(h, p);
                j.translate(k.width / h - n.x - n.width / 2, k.height / p - n.y - n.height / 2);
                if (this.shapeOrientation > 0) {
                    j.rotateAt(this.shapeOrientation, n.x + n.width / 2, n.y + n.height / 2)
                }
                if (o !== 0) {
                    j.rotateAt(o, n.x + n.width / 2, n.y + n.height / 2)
                }
                l.outlinePath.transform = j.clone();
                l.decorationPath.transform = j.clone();
                l.shapeDecorationPath.transform = j.clone()
            },
            addCanvasElements: function(j, k, h) {
                if (h != null) {
                    if (!j.outlinePath.empty()) {
                        a.insert(k, h, j.outlinePath)
                    }
                    if (!j.decorationPath.empty()) {
                        a.insert(k, h + 1, j.decorationPath)
                    }
                    if (!j.shapeDecorationPath.empty()) {
                        a.insert(k, h + 2, j.shapeDecorationPath)
                    }
                } else {
                    if (!j.outlinePath.empty()) {
                        a.add(k, j.outlinePath)
                    }
                    if (!j.decorationPath.empty()) {
                        a.add(k, j.decorationPath)
                    }
                    if (!j.shapeDecorationPath.empty()) {
                        a.add(k, j.shapeDecorationPath)
                    }
                }
            },
            removeCanvasElements: function(h, j) {
                a.remove(j, h.outlinePath);
                a.remove(j, h.decorationPath);
                a.remove(j, h.shapeDecorationPath)
            },
            clone: function() {
                var h = new f();
                h.id = this.id;
                h.params = this.params;
                return h
            },
            setBounds: function(h) {
                var j = this.host ? this.host.rotationAngle : 0;
                if (!h.equals(this.bounds) || this.rotationAngle != j) {
                    this.bounds = h;
                    this.rotationAngle = j;
                    this.shapeRenderer.updateData(this.bounds, j)
                }
            },
            getBounds: function() {
                return this.bounds
            },
            draw: function(j, h) {
                if (this.bounds.width === 0 || this.bounds.height === 0) {
                    return
                }
                this.shapeRenderer.draw(j, h)
            },
            getId: function() {
                return this.id
            },
            setBrush: function(h) {
                if (this.shapeRenderer) {
                    this.shapeRenderer.outlineBrush = this.shapeRenderer.decorationBrush = h
                }
            },
            getBrush: function() {
                if (this.shapeRenderer) {
                    return this.shapeRenderer.outlineBrush
                }
                return "#A9A9A9"
            },
            setPen: function(h) {
                if (this.shapeRenderer) {
                    this.shapeRenderer.outlinePen = this.shapeRenderer.decorationPen = h
                }
            },
            getPen: function() {
                if (this.shapeRenderer) {
                    return this.shapeRenderer.outlinePen
                }
                return "#000000"
            },
            isElliptic: function() {
                var j = new d(this.params.outline);
                var h = j.builder;
                if (h[0] == "A") {
                    if (h[7] == 0 && h[9] == 6.28318530717959) {
                        return true
                    }
                }
                return false
            },
            isDummy: function() {
                return this.dummy === true
            },
            id: "",
            shapeOrientation: 0,
            defaultBounds: new MindFusion.Drawing.Rect(0, 0, 100, 100),
            shapeRenderer: null,
            isOutline: false,
            bounds: null,
            rotationAngle: 0
        };
        MindFusion.registerClass(f, "MindFusion.Diagramming.Shape")
    })(MindFusion.Diagramming);
    (function(c) {
        var d = MindFusion.Diagramming.Shape;
        var a = MindFusion.Collections.ArrayList;
        var b = c.ShapeLibrary = function(e) {
            this.shapes = [];
            if (e) {
                for (var f in e) {
                    this.shapes.push(f)
                }
            }
        };
        b.onShapeLibraryLoaded = function() {
            if (!document) {
                return
            }
            var e = document.getElementsByTagName("CANVAS");
            if (!e) {
                return
            }
            a.forEach(e, function(f) {
                var g = MindFusion.find(f.id);
                if (g && g.onShapeLibraryLoaded) {
                    g.onShapeLibraryLoaded()
                }
            })
        };
        b.prototype = {
            loadFromXml: function(e, g, h) {
                var f = this;
                var j = new XMLHttpRequest();
                j.onload = function() {
                    if (j.readyState == 4 && j.status == 200) {
                        var p = j.responseXML;
                        var n = new c.XmlPersistContext(f, p);
                        f.shapes = [];
                        var k = p.getElementsByTagName("shapes")[0];
                        if (!k) {
                            return
                        }
                        var l = k.firstChild;
                        if (!l) {
                            return
                        }
                        while (l != null) {
                            if (l.nodeType == 1) {
                                var o = new d();
                                o.loadFromXml(l, n);
                                d.registerDefaultShape(o);
                                f.shapes.push(o)
                            }
                            l = l.nextSibling
                        }
                        b.onShapeLibraryLoaded(true);
                        if (g) {
                            g(f)
                        }
                    } else {
                        if (console && console.log) {
                            console.log("Error while getting ShapeLibrary XML. " + j.status + " " + j.statusText)
                        }
                        b.onShapeLibraryLoaded(false);
                        if (h) {
                            h(f)
                        }
                    }
                };
                j.onerror = function() {
                    if (console && console.log) {
                        console.log("Error while getting ShapeLibrary XML. " + j.status + " " + j.statusText)
                    }
                    b.onShapeLibraryLoaded(false);
                    if (h) {
                        h(f)
                    }
                };
                j.open("GET", e);
                j.responseType = "document";
                j.send()
            },
            getShapes: function() {
                if (!this.shapes) {
                    this.shapes = []
                }
                return this.shapes
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ShapeLibrary")
    })(MindFusion.Diagramming);
    (function(c) {
        var b = MindFusion.Collections.ArrayList;
        var h = MindFusion.Drawing.GraphicsUnit;
        var a = MindFusion.Diagramming.FitSize;
        var f = MindFusion.Drawing.Text;
        var e = MindFusion.Diagramming.EffectPhase;
        var d = MindFusion.Drawing.Thickness;
        var g = c.ShapeNode = function(j) {
            c.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(g, this, [j]);
            this.rotationAngle = 0;
            if (c.DiagramItem.useStyles === false) {
                this.setTextColor("black")
            }
            this.text.fitInBounds = true;
            this.imageLocation = "";
            this.image = null;
            this.imageAlign = MindFusion.Drawing.ImageAlign.Fit;
            this.rotateText = true;
            this.rotateImage = true;
            this.allowFlip = false;
            this.flipX = false;
            this.flipY = false;
            if (j && c.DiagramItem.useStyles === false) {
                this.pen = j.shapePen;
                this.brush = j.shapeBrush
            }
            this.setShape(j && j.defaultShape ? j.defaultShape : "RoundRect");
            this.transparent = false;
            c.Diagram.suppressSetDirty = false
        };
        g.prototype = {
            clone: function() {
                c.Diagram.suppressSetDirty = true;
                var j = mflayer.callBaseMethod(g, this, "clone", []);
                j.setShape(this.shape.id);
                j.setImageLocation(this.imageLocation);
                j.setTransparent(this.transparent);
                j.setImageAlign(this.imageAlign);
                j.imagePadding = this.imagePadding;
                j.setRotateText(this.rotateText);
                j.setRotateImage(this.rotateImage);
                j.setImageContent(this.imageContent);
                j.setEnableStyledText(this.getEnableStyledText());
                j.setFlipX(this.getFlipX());
                j.setFlipY(this.getFlipY());
                j.setAllowFlip(this.getAllowFlip());
                c.Diagram.suppressSetDirty = false;
                return j
            },
            toJson: function() {
                var j = mflayer.callBaseMethod(g, this, "toJson", []);
                if (this.imageContent) {
                    if (this.parent.saveImage) {
                        j.imageIndex = this.parent.saveImage(this.imageContent)
                    } else {
                        j.imageData = this.imageContent
                    }
                }
                j.shape = this.shape.id;
                j.imageLocation = this.imageLocation || "";
                j.transparent = this.transparent;
                j.imageAlign = this.imageAlign;
                j.imagePadding = this.imagePadding;
                j.rotateText = this.rotateText;
                j.rotateImage = this.rotateImage;
                j.enableStyledText = this.getEnableStyledText();
                j.flipX = this.flipX;
                j.flipY = this.flipY;
                j.allowFlip = this.allowFlip;
                return j
            },
            fromJson: function(j) {
                mflayer.callBaseMethod(g, this, "fromJson", [j]);
                this.setShape(MindFusion.Diagramming.Shape.fromId(j.shape) || "RoundRect");
                if (j.imageIndex != undefined) {
                    this.setImageContent(this.parent.images[j.imageIndex])
                }
                if (j.imageData != undefined) {
                    this.setImageContent(j.imageData)
                }
                this.setImageLocation(j.imageLocation);
                this.setTransparent(j.transparent);
                this.setImageAlign(j.imageAlign);
                if (j.imagePadding) {
                    this.setImagePadding(d.copy(j.imagePadding))
                }
                this.setRotateText(j.rotateText);
                this.setRotateImage(j.rotateImage);
                this.setEnableStyledText(j.enableStyledText);
                if (j.flipX != undefined) {
                    this.setFlipX(j.flipX)
                }
                if (j.flipY != undefined) {
                    this.setFlipY(j.flipY)
                }
                if (j.allowFlip != undefined) {
                    this.setAllowFlip(j.allowFlip)
                }
            },
            loadFromXml: function(l, k) {
                mflayer.callBaseMethod(g, this, "loadFromXml", [l, k]);
                this.setEnableStyledText(k.readBool("EnableStyledText", l));
                this.setShape(k.readShape("Shape", l));
                if (this.shape == null) {
                    this.setShape("Rectangle")
                }
                this.rotateText = k.readBool("RotateText", l, this.rotateText);
                var j = k.readStringFormat("TextFormat", l);
                if (j) {
                    this.setTextAlignment(j.alignment);
                    this.setLineAlignment(j.lineAlignment)
                } else {
                    this.setTextAlignment(k.readInt("TextAlignment", l));
                    this.setLineAlignment(k.readInt("TextVerticalAlignment", l))
                }
                this.imageAlign = k.readInt("ImageAlign", l);
                this.setImageContent(k.readImage("Image", l));
                this.rotateImage = k.readBool("RotateImage", l, this.rotateImage);
                var n = k.selectNode(l, "ImagePadding");
                if (n) {
                    this.imagePadding = k.readThickness("ImagePadding", l)
                }
                this.transparent = k.readBool("Transparent", l);
                this.flipX = k.readBool("FlipX", l, this.flipX);
                this.flipY = k.readBool("FlipY", l, this.flipY);
                this.allowFlip = k.readBool("AllowFlip", l, this.allowFlip)
            },
            saveToXml: function(k, j) {
                mflayer.callBaseMethod(g, this, "saveToXml", [k, j]);
                j.writeBool(this.getEnableStyledText(), "EnableStyledText", k);
                j.writeShape(this.getShape(), "Shape", k);
                j.writeBool(this.rotateText, "RotateText", k);
                j.writeInt(this.getTextAlignment(), "TextAlignment", k);
                j.writeInt(this.getLineAlignment(), "TextVerticalAlignment", k);
                j.writeInt(this.imageAlign, "ImageAlign", k);
                j.writeImage(this.getImageContent(), "Image", k);
                j.writeBool(this.rotateImage, "RotateImage", k);
                if (this.imagePadding) {
                    j.writeThickness(this.imagePadding, "ImagePadding", k)
                }
                j.writeBool(this.transparent, "Transparent", k);
                j.writeBool(this.flipX, "FlipX", k);
                j.writeBool(this.flipY, "FlipY", k);
                j.writeBool(this.allowFlip, "AllowFlip", k)
            },
            setRotateText: function(j) {
                if (this.rotateText != j) {
                    this.rotateText = j;
                    this.invalidate()
                }
            },
            getRotateText: function() {
                return this.rotateText
            },
            setRotateImage: function(j) {
                if (this.rotateImage != j) {
                    this.rotateImage = j;
                    this.invalidate()
                }
            },
            getRotateImage: function() {
                return this.rotateImage
            },
            setImage: function(j) {
                if (!j) {
                    this.image = null
                } else {
                    this.image = new MindFusion.Drawing.Image(this.bounds);
                    this.image.image = j;
                    this.image.loaded = true
                }
                this.invalidate()
            },
            getImage: function() {
                if (!this.image) {
                    return null
                }
                return this.image.image
            },
            setImageAlign: function(j) {
                if (this.imageAlign != j) {
                    this.imageAlign = j;
                    if (this.image) {
                        this.invalidate()
                    } else {
                        this.setDiagramDirty()
                    }
                }
            },
            getImageAlign: function() {
                if (this.imageAlign === undefined) {
                    return MindFusion.Drawing.ImageAlign.Fit
                }
                return this.imageAlign
            },
            setImagePadding: function(j) {
                if (this.imagePadding !== j) {
                    this.imagePadding = j;
                    this.invalidate()
                }
            },
            getImagePadding: function() {
                return this.imagePadding
            },
            setTransparent: function(j) {
                if (this.transparent != j) {
                    this.transparent = j;
                    this.invalidate()
                }
            },
            getTransparent: function() {
                return this.transparent
            },
            setFlipX: function(j) {
                if (this.flipX != j) {
                    this.flipX = j;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                    this.invalidate()
                }
            },
            getFlipX: function() {
                return this.flipX
            },
            setFlipY: function(j) {
                if (this.flipY != j) {
                    this.flipY = j;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                    this.invalidate()
                }
            },
            getFlipY: function() {
                return this.flipY
            },
            setAllowFlip: function(j) {
                if (this.allowFlip != j) {
                    this.allowFlip = j;
                    this.invalidate()
                }
            },
            getAllowFlip: function() {
                return this.allowFlip
            },
            validateParams: function(j) {
                if (j.length === 0) {
                    return
                }
                this.parent = j[0]
            },
            getBaseType: function() {
                return this.constructor.__baseType.__typeName
            },
            containsPoint: function(j) {
                var k = this.getRotatedBounds();
                if (!k.containsPoint(j)) {
                    return false
                }
                if (c.Utils.pointInPolygon(j, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(j)) {
                    return true
                }
                return false
            },
            onShapeLoaded: function() {
                this.graphicsContainer.invalidParent = this
            },
            updateCanvasElements: function() {
                var n = this.graphicsContainer.content = [];
                if (this.shape.isDummy() && !c.Shape.loadFromLibPending) {
                    this.shape = c.Shape.fromId(this.shape.id);
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setShape(this.shape)
                    }
                }
                var l = this.bounds;
                if (!this.transparent) {
                    var j = this.getEffectiveBrush();
                    var p = {
                        brush: j,
                        phase: e.BeforeFill
                    };
                    this.applyEffects(n, p);
                    if (p.brush) {
                        j = p.brush
                    }
                }
                if (!this.shapeRenderer) {
                    this.shapeRenderer = new c.ShapeRenderer(this.shape);
                    this.shapeRenderer.setFlip(this.flipX, this.flipY)
                }
                this.shapeRenderer.updateData(this.bounds, this.rotationAngle);
                if (!this.transparent) {
                    this.shapeRenderer.outlineBrush = this.getEffectiveBrush();
                    this.shapeRenderer.outlinePen = this.getEffectiveStroke();
                    this.shapeRenderer.decorationPen = this.shapeRenderer.outlinePen;
                    this.shapeRenderer.strokeThickness = this.getEffectiveStrokeThickness();
                    this.shapeRenderer.strokeDashStyle = this.getEffectiveStrokeDashStyle();
                    this.shapeRenderer.shadow = this.createShadow();
                    n.push(this.shapeRenderer)
                }
                var o = this.image;
                if (o && o.loaded) {
                    if (this.transparent) {
                        this.shapeRenderer.updateData(this.bounds, this.rotationAngle)
                    }
                    o.clipPath = this.shapeRenderer.getOutline();
                    var k = l.clone();
                    if (this.imagePadding) {
                        this.imagePadding.applyTo(k)
                    }
                    o.setBounds(k, this.rotateImage ? this.rotationAngle : 0);
                    o.imageAlign = this.imageAlign;
                    n.push(o)
                }
                if (!this.transparent) {
                    this.applyEffects(n, {
                        phase: e.AfterFill
                    })
                }
                this.text.font = this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.setBounds(l, (this.rotateText) ? this.rotationAngle : 0);
                n.push(this.text);
                this.addManipulatorVisuals(n);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            updateDrag: function(j) {
                mflayer.callBaseMethod(g, this, "updateDrag", [j]);
                var l = j.originalStates.get(this);
                if (l == null) {
                    return
                }
                var k = j.adjustmentHandle.index;
                if (this.allowFlip && k < 8) {
                    var p = this.flipX;
                    var n = this.flipY;
                    var o = j.delta();
                    if (o.x != 0) {
                        if ((o.x < 0 && (k == 1 || k == 2 || k == 5)) || (o.x > 0 && (k == 0 || k == 3 || k == 7))) {
                            this.flipX = j.startBounds.width - Math.abs(o.x) < 0 ? !l.flipX : l.flipX
                        }
                    }
                    if (o.y != 0) {
                        if ((o.y < 0 && (k == 2 || k == 3 || k == 6)) || (o.y > 0 && (k == 0 || k == 1 || k == 4))) {
                            this.flipY = j.startBounds.height - Math.abs(o.y) < 0 ? !l.flipY : l.flipY
                        }
                    }
                    if (this.shapeRenderer && (this.flipX != p || this.flipY != n)) {
                        this.shapeRenderer.setFlip(this.flipX, this.flipY)
                    }
                }
            },
            setShape: function(j) {
                if (typeof j == "string") {
                    j = c.Shape.fromId(j)
                }
                if (this.shape != j) {
                    this.shape = j;
                    if (this.shapeRenderer) {
                        this.shapeRenderer.setShape(this.shape)
                    }
                    this.invalidate()
                }
            },
            getShape: function() {
                return this.shape
            },
            setImageLocation: function(j) {
                if (this.imageLocation != j) {
                    this.imageLocation = j;
                    if (j) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        this.image.image.src = j
                    }
                    this.setDiagramDirty()
                }
            },
            getImageLocation: function() {
                return this.imageLocation
            },
            setImageContent: function(k) {
                if (this.imageContent != k) {
                    this.imageContent = k;
                    if (k) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        var j = "data:image/png;base64," + this.imageContent;
                        this.image.image.src = j
                    }
                    this.setDiagramDirty()
                }
            },
            getImageContent: function() {
                return this.imageContent
            },
            loadImage: function() {
                this.image.loaded = true;
                if (this.parent) {
                    this.invalidate()
                }
            },
            setEnableStyledText: function(j) {
                if (this.text.enableStyledText != j) {
                    this.text.enableStyledText = j;
                    this.invalidate()
                }
            },
            getEnableStyledText: function() {
                return this.text.enableStyledText
            },
            textOverflows: function() {
                return true
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var j = c.Utils.getApproximatingContext();
                this.shapeRenderer.getOutline().addToContext(j);
                return j.transformAndGetPoints()
            },
            resolveInheritedStyle: function(k, l) {
                var j = l.styles["std:ShapeNode"];
                if (j) {
                    if (k.apply(j)) {
                        return j
                    }
                }
                return mflayer.callBaseMethod(g, this, "resolveInheritedStyle", [k, l])
            },
            resizeToFitText: function(v) {
                if (this.text == undefined || this.text == "") {
                    return false
                }
                if (v == undefined) {
                    v = a.KeepRatio
                }
                var A = h.getMillimeter(this.parent.measureUnit);
                var w = this.bounds.clone();
                this.textPadding.applyTo(w);
                var u = c.Utils.getFitTextStep(this.parent.measureUnit);
                var t = u;
                var n = this.text.text;
                var p = this.getEffectiveFont();
                var z = this.getEnableStyledText();
                if (v == a.KeepWidth) {
                    var q = this.parent.measureString(n, p, w, z);
                    w.height = q.height;
                    this.textPadding.addToRect(w);
                    this.setBounds(w, true)
                } else {
                    if (v == a.KeepHeight) {
                        if (z) {
                            w.width = Number.MAX_VALUE;
                            var q = this.parent.measureString(n, p, w, z);
                            w.width = q.width
                        } else {
                            var s = w.clone();
                            s.width = Number.MAX_VALUE;
                            var l = this.parent.measureString(n, p, s, z);
                            var q = this.parent.measureString(n, p, w, z);
                            var o = f.getMinWidth(n, p, this.parent.context, this.parent.scale);
                            if (w.width < o) {
                                var B = o - w.width;
                                w.width = o
                            }
                            if (q.height > w.height) {
                                while (q.height > w.height && w.width < l.width) {
                                    w.width += u;
                                    q = this.parent.measureString(n, p, w, z);
                                    if (w.width < o) {
                                        break
                                    }
                                }
                            } else {
                                while (q.height < w.height) {
                                    w.width -= u;
                                    q = this.parent.measureString(n, p, w, z);
                                    if (w.width < o) {
                                        break
                                    }
                                }
                                w.width += u
                            }
                        }
                        this.textPadding.addToRect(w);
                        this.setBounds(w, true)
                    } else {
                        if (v == a.KeepRatio) {
                            var r = w.width / w.height;
                            var D = w.height / w.width;
                            if (r < D) {
                                D = 1 / r;
                                r = 1
                            } else {
                                r = 1 / D;
                                D = 1
                            }
                            u = r * u;
                            t = D * t;
                            var k = 0;
                            var j = 0;
                            var C = this.bounds.clone();
                            var q = this.parent.measureString(n, p, w, z);
                            var o = z ? 20 * A : f.getMinWidth(n, p, this.parent.context, this.parent.scale);
                            if (C.width < o) {
                                var B = o - w.width;
                                C.width = o;
                                C.height = w.height + B
                            }
                            if (q.height < w.height) {
                                do {
                                    k -= u;
                                    j -= t;
                                    w = C.clone();
                                    w = c.Utils.inflate(w, k, j);
                                    q = this.parent.measureString(n, p, w, z);
                                    if (w.width < o) {
                                        break
                                    }
                                } while (q.height < w.height);
                                k += u;
                                j += t;
                                w = C.clone();
                                w = c.Utils.inflate(w, k, j)
                            } else {
                                var q = this.parent.measureString(n, p, w, z);
                                while (q.height > w.height) {
                                    k += u;
                                    j += t;
                                    w = this.bounds.clone();
                                    w = c.Utils.inflate(w, k, j);
                                    var q = this.parent.measureString(n, p, w, z);
                                    if (w.width > A * 1000) {
                                        break
                                    }
                                }
                            }
                            this.textPadding.addToRect(w);
                            this.setBounds(w, true)
                        }
                    }
                }
                this.invalidate();
                return true
            },
            saveLocationState: function() {
                var j = mflayer.callBaseMethod(g, this, "saveLocationState", []);
                j.flipX = this.flipX;
                j.flipY = this.flipY;
                return j
            },
            restoreLocationState: function(j) {
                var k = j.originalStates.get(this);
                if (k != null) {
                    this.setFlipX(k.flipX);
                    this.setFlipY(k.flipY)
                }
                mflayer.callBaseMethod(g, this, "restoreLocationState", [j])
            },
            saveState: function() {
                var j = mflayer.callBaseMethod(g, this, "saveState", []);
                j.shape = this.shape;
                j.imageLocation = this.imageLocation;
                j.transparent = this.transparent;
                j.imageAlign = this.imageAlign;
                j.imagePadding = this.imagePadding;
                j.rotateText = this.rotateText;
                j.rotateImage = this.rotateImage;
                j.allowFlip = this.allowFlip;
                j.flipX = this.flipX;
                j.flipY = this.flipY;
                return j
            },
            restoreState: function(j) {
                mflayer.callBaseMethod(g, this, "restoreState", [j]);
                this.setShape(j.shape);
                this.setImageLocation(j.imageLocation);
                this.setTransparent(j.transparent);
                this.setImageAlign(j.imageAlign);
                this.imagePadding = j.imagePadding;
                this.setRotateText(j.rotateText);
                this.setRotateImage(j.rotateImage);
                this.allowFlip = j.allowFlip;
                this.setFlipX(j.flipX);
                this.setFlipY(j.flipY)
            },
            init: function() {
                if (!c.ShapeNodeBuilder) {
                    c.ShapeNodeBuilder = new MindFusion.Builder(g.prototype, null, this)
                } else {
                    c.ShapeNodeBuilder.setInstance(this)
                }
                return c.ShapeNodeBuilder
            }
        };
        g.With = function(j) {
            if (!c.ShapeNodeBuilder) {
                c.ShapeNodeBuilder = new MindFusion.Builder(g.prototype, j)
            } else {
                c.ShapeNodeBuilder.setInstance(null)
            }
            return c.ShapeNodeBuilder
        };
        c.ShapeNodeBuilder = null;
        MindFusion.registerClass(g, "MindFusion.Diagramming.ShapeNode", c.DiagramNode)
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Diagramming.Shape;
        var a = MindFusion.Drawing.Matrix;
        var e = MindFusion.Drawing.PathParser;
        var c = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Path;
        var h = b.ShapeRenderer = function(j) {
            this.shape = j;
            this.flipX = false;
            this.flipY = false;
            this.transform = null;
            this.outlinePen = "#000000";
            this.outlineBrush = "#A9A9A9";
            this.decorationPen = "#000000";
            this.decorationBrush = "transparent";
            this.shapeDecorationPen = "#000000";
            this.shapeDecorationBrush = "#000000";
            this.strokeDashStyle = undefined;
            this.strokeThickness = 0;
            this.lineJoin = "miter";
            this.currentPhase = f.None;
            this.targetBounds = new c(0, 0, 100, 100);
            this.setShapeTransform = false;
            this.pathCopy = this.shape.params.outline;
            this.build()
        };
        h.prototype = {
            build: function() {
                if (this.shape.params.outline) {
                    this.outlineBounds = this.getEmptyBounds();
                    this.outlineBuilder = []
                }
                if (this.shape.params.decoration) {
                    this.decorationBounds = this.getEmptyBounds();
                    this.decorationBuilder = []
                }
                if (this.shape.params.shapeDecorations) {
                    this.shapeDecorationBounds = [];
                    this.shapeDecorationBuilder = [];
                    for (var j = 0; j < this.shape.params.shapeDecorations.length; j++) {
                        this.shapeDecorationBounds.push(this.getEmptyBounds());
                        this.shapeDecorationBuilder.push([])
                    }
                }
                this.parseAll()
            },
            rebuild: function() {
                delete this.outlineBounds;
                delete this.outlineBuilder;
                delete this.decorationBounds;
                delete this.decorationBuilder;
                delete this.shapeDecorationBounds;
                delete this.shapeDecorationBuilder;
                this.build()
            },
            draw: function(l, j) {
                this.currentPhase = f.None;
                if (this.shape.params.outline) {
                    this.currentPhase = f.Outline;
                    l.save();
                    this.addToContext(l);
                    if (this.shadow && j != false) {
                        this.shadow.apply(l)
                    }
                    l.fillStyle = this.getOutlineBrush(l);
                    l.fill(this.shape.params.fillMode);
                    l.restore();
                    l.strokeStyle = this.getOutlinePen(l);
                    l.lineWidth = (this.strokeThickness ? this.strokeThickness : 1) / l._mf_scale;
                    MindFusion.Drawing.DashStyle.apply(l, this.strokeDashStyle);
                    l.lineJoin = this.lineJoin;
                    l.stroke()
                }
                if (this.shape.params.decoration) {
                    this.currentPhase = f.Decoration;
                    l.save();
                    this.addToContext(l);
                    l.fillStyle = this.getDecorationBrush(l);
                    l.fill(this.shape.params.fillMode);
                    l.restore();
                    l.strokeStyle = this.getDecorationPen(l);
                    l.lineWidth = this.strokeThickness / l._mf_scale;
                    MindFusion.Drawing.DashStyle.apply(l, this.strokeDashStyle);
                    l.lineJoin = this.lineJoin;
                    l.stroke()
                }
                if (this.shape.params.shapeDecorations) {
                    for (var k = 0; k < this.shape.params.shapeDecorations.length; k++) {
                        var n = this.shape.params.shapeDecorations[k];
                        this.addShapeDecoration(n, l, k)
                    }
                }
                this.currentPhase = f.None
            },
            addShapeDecoration: function(l, k, j) {
                this.currentPhase = f.ShapeDecoration + j;
                k.save();
                this.addToContext(k);
                k.fillStyle = this.getShapeDecorationBrush(k, j);
                k.fill(l.fillMode || "nonzero");
                k.restore();
                k.strokeStyle = this.getShapeDecorationPen(k, j);
                k.lineWidth = this.strokeThickness / k._mf_scale;
                MindFusion.Drawing.DashStyle.apply(k, (l.pen ? l.pen.dashStyle : this.strokeDashStyle));
                k.lineJoin = this.lineJoin;
                k.stroke();
                this.currentPhase = f.None
            },
            drawShadow: function(j) {
                if (this.shadow) {
                    j.save();
                    this.currentPhase = f.Shadow;
                    this.addToContext(j);
                    this.shadow.apply(j);
                    j.fillStyle = this.shadow.color;
                    j.fill(this.shape.params.fillMode);
                    j.restore();
                    this.currentPhase = f.None
                }
            },
            drawOutline: function(j) {
                this.getOutline().setBrush(this.outlineBrush);
                this.outlinePath.setPen(this.outlinePen);
                this.outlinePath.strokeThickness = this.strokeThickness;
                this.outlinePath.draw(j)
            },
            addToContext: function(n, k) {
                if (k == false) {
                    n.save()
                }
                if (this.transform) {
                    n.transform.apply(n, this.transform.matrix())
                }
                n.beginPath();
                var j = this.getBuilder();
                if (j) {
                    for (var l = 0; l < j.length; l++) {
                        if (j[l].func == "roundRect") {
                            this.drawRoundRect(n, j[l])
                        } else {
                            n[j[l].func].apply(n, j[l].args)
                        }
                    }
                }
                if (k == false) {
                    n.restore()
                }
            },
            drawRoundRect: function(o, n) {
                o.save();
                o.transform.apply(o, this.shapeTransform.matrix());
                var q = this.targetBounds;
                var l = q.x + q.width * n.args[0] / 100;
                var r = q.y + q.height * n.args[1] / 100;
                var p = q.width * n.args[2] / 100;
                var k = q.height * n.args[3] / 100;
                var j = n.args[4];
                o.moveTo(l, r + j);
                o.lineTo(l, r + k - j);
                o.quadraticCurveTo(l, r + k, l + j, r + k);
                o.lineTo(l + p - j, r + k);
                o.quadraticCurveTo(l + p, r + k, l + p, r + k - j);
                o.lineTo(l + p, r + j);
                o.quadraticCurveTo(l + p, r, l + p - j, r);
                o.lineTo(l + j, r);
                o.quadraticCurveTo(l, r, l, r + j);
                o.restore()
            },
            updateArrowHeadData: function(n, r, l) {
                if (n.width === 0 || n.height === 0) {
                    return
                }
                var q = this.shape.defaultBounds;
                var o = b.Utils.subtract(r, l);
                var p = 90 + b.Utils.degrees(Math.atan2(o.y, o.x));
                var j = n.width / 100;
                var k = new a();
                k.translate(r.x, r.y);
                k.scale(j, j);
                k.rotate(p);
                k.translate(-50, 0);
                this.transform = k.clone();
                this.getOutline().transform = k.clone()
            },
            updateData: function(l, p) {
                if (l.width === 0 || l.height === 0) {
                    return
                }
                var n = this.shape.defaultBounds;
                var j = l.width / n.width;
                var o = l.height / n.height;
                var k = new a();
                k.translate(l.x - l.width / 2, l.y - l.height / 2);
                k.scale(j, o);
                k.translate(l.width / j - n.x - n.width / 2, l.height / o - n.y - n.height / 2);
                if (this.shape.shapeOrientation > 0) {
                    k.rotateAt(this.shape.shapeOrientation, n.x + n.width / 2, n.y + n.height / 2)
                }
                if (p !== 0) {
                    k.rotateAt(p, n.x + n.width / 2, n.y + n.height / 2)
                }
                if (this.flipX || this.flipY) {
                    k.translate(n.x + n.width / 2, n.y + n.height / 2);
                    k.scale(this.flipX ? -1 : 1, this.flipY ? -1 : 1);
                    k.translate(-(n.x + n.width / 2), -(n.y + n.height / 2))
                }
                this.transform = k.clone();
                this.getOutline().transform = k.clone();
                if (this.setShapeTransform) {
                    var k = new a();
                    k.scale(1 / j, 1 / o);
                    this.shapeTransform = k;
                    this.targetBounds = new c(0, 0, l.width, l.height)
                }
                this.shadow = null;
                this.outlinePen = this.outlinePen || this.shape.params.outlinePen || "#000000";
                this.outlineBrush = this.outlineBrush || this.shape.params.outlineBrush || "#A9A9A9";
                this.decorationPen = this.decorationPen || this.shape.params.decorationPen || "#000000";
                this.decorationBrush = this.decorationBrush || this.shape.params.decorationBrush || "transparent";
                this.shapeDecorationPen = this.shape.params.shapeDecorationPen || "#000000";
                this.shapeDecorationBrush = this.shape.params.shapeDecorationBrush || "#000000"
            },
            prepareCommands: function(j) {
                if (j != null) {
                    var n = ["M", "L", "B", "Q", "A", "Z", "C", "E", "R", "U"];
                    var l = 0;
                    while (l < n.length) {
                        var k = n[l];
                        j = j.replace(new RegExp(k, "g"), ":" + k);
                        l++
                    }
                    var o = j.split(":");
                    return o.filter(String)
                }
                return []
            },
            getOutline: function() {
                if (!this.outlinePath) {
                    this.updateOutline()
                }
                return this.outlinePath
            },
            updateOutline: function() {
                this.outlinePath = new d(this.shape.params.outline || "")
            },
            getBounds: function(j) {
                var k;
                switch (j) {
                    case f.None:
                        return null;
                    case f.Shadow:
                    case f.Outline:
                        k = this.outlineBounds;
                        break;
                    case f.Decoration:
                        k = this.decorationBounds;
                        break;
                    default:
                        k = this.shapeDecorationBounds[j - f.ShapeDecoration];
                        break
                }
                return new c(k.minX, k.minY, k.maxX - k.minX, k.maxY - k.minY)
            },
            getEmptyBounds: function() {
                return {
                    minX: Number.MAX_VALUE,
                    minY: Number.MAX_VALUE,
                    maxX: 0,
                    maxY: 0
                }
            },
            expandBounds: function(j, n) {
                var l = null;
                switch (this.currentPhase) {
                    case f.None:
                        return;
                    case f.Shadow:
                    case f.Outline:
                        l = this.outlineBounds;
                        break;
                    case f.Decoration:
                        l = this.decorationBounds;
                        break;
                    default:
                        var k = this.currentPhase - f.ShapeDecoration;
                        l = this.shapeDecorationBounds[k];
                        break
                }
                if (!l) {
                    return
                }
                l.minX = Math.min(l.minX, j);
                l.minY = Math.min(l.minY, n);
                l.maxX = Math.max(l.maxX, j);
                l.maxY = Math.max(l.maxY, n)
            },
            getBuilder: function() {
                switch (this.currentPhase) {
                    case f.None:
                        return null;
                    case f.Shadow:
                    case f.Outline:
                        return this.outlineBuilder;
                    case f.Decoration:
                        return this.decorationBuilder;
                    default:
                        return this.shapeDecorationBuilder[this.currentPhase - f.ShapeDecoration]
                }
            },
            getOutlineBrush: function(j) {
                return MindFusion.Diagramming.Utils.getBrush(j, this.outlineBrush || "#A9A9A9", this.getBounds(f.Outline))
            },
            getOutlinePen: function(j) {
                return MindFusion.Diagramming.Utils.getBrush(j, this.outlinePen || "#000000", this.getBounds(f.Outline), true)
            },
            getDecorationBrush: function(j) {
                return MindFusion.Diagramming.Utils.getBrush(j, this.decorationBrush || "transparent", this.getBounds(f.Decoration))
            },
            getDecorationPen: function(j) {
                return MindFusion.Diagramming.Utils.getBrush(j, this.decorationPen || "#000000", this.getBounds(f.Decoration), true)
            },
            getShapeDecorationBrush: function(k, j) {
                return MindFusion.Diagramming.Utils.getBrush(k, this.shape.params.shapeDecorations[j].brush || this.shapeDecorationBrush || "#000000", this.getBounds(f.ShapeDecoration + j))
            },
            getShapeDecorationPen: function(k, j) {
                return MindFusion.Diagramming.Utils.getBrush(k, (this.shape.params.shapeDecorations[j].pen ? this.shape.params.shapeDecorations[j].pen.brush : (this.shapeDecorationPen || "#000000")), this.getBounds(f.ShapeDecoration + j), true)
            },
            parseAll: function() {
                this.currentPhase = f.None;
                if (this.shape.params.outline) {
                    this.currentPhase = f.Outline;
                    this.parse(this.prepareCommands(this.shape.params.outline))
                }
                if (this.shape.params.decoration) {
                    this.currentPhase = f.Decoration;
                    this.parse(this.prepareCommands(this.shape.params.decoration))
                }
                if (this.shape.params.shapeDecorations) {
                    for (var j = 0; j < this.shape.params.shapeDecorations.length; j++) {
                        this.currentPhase = f.ShapeDecoration + j;
                        this.parse(this.prepareCommands(this.shape.params.shapeDecorations[j].path))
                    }
                }
            },
            setShape: function(j) {
                this.shape = j;
                this.rebuild();
                this.updateOutline()
            },
            setFlip: function(k, j) {
                this.flipX = k;
                this.flipY = j
            },
            parse: function(j) {
                e.parse(j, this)
            },
            moveTo: function(j, l) {
                var k = this.getBuilder();
                if (!k) {
                    return
                }
                k.push({
                    func: "moveTo",
                    args: [j, l]
                });
                this.expandBounds(j, l)
            },
            lineTo: function(j, l) {
                var k = this.getBuilder();
                if (!k) {
                    return
                }
                k.push({
                    func: "lineTo",
                    args: [j, l]
                });
                this.expandBounds(j, l)
            },
            bezierTo: function(o, q, l, p, j, n) {
                var k = this.getBuilder();
                if (!k) {
                    return
                }
                k.push({
                    func: "bezierCurveTo",
                    args: [o, q, l, p, j, n]
                });
                this.expandBounds(o, q);
                this.expandBounds(l, p);
                this.expandBounds(j, n)
            },
            arcTo: function(k, s, j, o, n, q) {
                var l = this.getBuilder();
                if (!l) {
                    return
                }
                l.push({
                    func: "arc",
                    args: [k, s, j, o, n, q]
                });
                var p = +j;
                this.expandBounds(+k - p, +s - p);
                this.expandBounds(+k + p, +s + p)
            },
            quadraticCurveTo: function(l, n, j, o) {
                var k = this.getBuilder();
                if (!k) {
                    return
                }
                k.push({
                    func: "quadraticCurveTo",
                    args: [l, n, j, o]
                });
                this.expandBounds(l, n);
                this.expandBounds(j, o)
            },
            roundRect: function(n, p, l, o, j) {
                var k = this.getBuilder();
                if (!k) {
                    return
                }
                k.push({
                    func: "roundRect",
                    args: [n, p, l, o, j]
                });
                this.setShapeTransform = true;
                this.expandBounds(n, p);
                this.expandBounds(l, o)
            },
            close: function() {
                var j = this.getBuilder();
                if (!j) {
                    return
                }
                j.push({
                    func: "closePath",
                    args: null
                })
            },
            createSvgElement: function(u) {
                var t = this.shape.params.outline;
                var C = this.shape.params.decoration;
                var F = this.shape.params.shapeDecorations;
                var L = this.shape.params.fillMode;
                var v = t.search("U[0-9]");
                if (v != -1) {
                    var q = t.substring(1);
                    var M = +q.split(",")[0];
                    var p = +q.split(",")[1];
                    var K = +q.split(",")[2];
                    var n = +q.split(",")[3];
                    var s = +q.split(",")[4];
                    var H = K - M;
                    var E = n - p;
                    var l = u.createElementNS("http://www.w3.org/2000/svg", "rect");
                    l.setAttribute("x", M);
                    l.setAttribute("y", p);
                    l.setAttribute("width", H);
                    l.setAttribute("height", E);
                    l.setAttribute("rx", s);
                    l.setAttribute("ry", s);
                    if (this.transform) {
                        l.setAttribute("transform", this.transform.svgMatrix())
                    }
                    if (L) {
                        l.setAttribute("fill-rule", L)
                    }
                    l.setAttribute("stroke-width", this.strokeThickness ? this.strokeThickness : 1);
                    return l
                }
                var A = u.createElementNS("http://www.w3.org/2000/svg", "g");
                if (this.transform) {
                    A.setAttribute("transform", this.transform.svgMatrix())
                }
                if (t) {
                    var k = u.createElementNS("http://www.w3.org/2000/svg", "path");
                    k.setAttribute("d", t);
                    var w = this.getOutlineBrush(null);
                    if (w) {
                        k.setAttribute("fill", w)
                    }
                    var r = this.getOutlinePen(null);
                    if (r) {
                        k.setAttribute("stroke", r)
                    }
                    A.appendChild(k)
                }
                if (C) {
                    var D = u.createElementNS("http://www.w3.org/2000/svg", "path");
                    D.setAttribute("d", C);
                    var j = this.getDecorationBrush(null);
                    if (j) {
                        D.setAttribute("fill", j)
                    }
                    var O = this.getDecorationPen(null);
                    if (O) {
                        D.setAttribute("stroke", O)
                    }
                    A.appendChild(D)
                }
                if (F) {
                    if (F.length == 1) {
                        var G = u.createElementNS("http://www.w3.org/2000/svg", "path");
                        G.setAttribute("d", F[0].path);
                        if (F[0].fillMode) {
                            G.setAttribute("fill-rule", F[0].fillMode)
                        }
                        var o = this.getShapeDecorationBrush(null, 0);
                        if (o) {
                            G.setAttribute("fill", o)
                        }
                        var z = this.getShapeDecorationPen(null, 0);
                        if (z) {
                            G.setAttribute("stroke", z)
                        }
                        A.appendChild(G)
                    } else {
                        var B = u.createElementNS("http://www.w3.org/2000/svg", "g");
                        for (var J = 0; J < F.length; J++) {
                            var G = u.createElementNS("http://www.w3.org/2000/svg", "path");
                            G.setAttribute("d", F[J].path);
                            if (F[J].fillMode) {
                                G.setAttribute("fill-rule", F[J].fillMode)
                            }
                            var o = this.getShapeDecorationBrush(null, J);
                            var z = this.getShapeDecorationPen(null, J);
                            if (o) {
                                G.setAttribute("fill", o)
                            }
                            if (z) {
                                G.setAttribute("stroke", z)
                            }
                            B.appendChild(G)
                        }
                        A.appendChild(B)
                    }
                }
                if (L) {
                    A.setAttribute("fill-rule", L)
                }
                var N = 1;
                if (this.transform) {
                    var I = this.transform.matrix();
                    N = Math.sqrt(I[0] * I[0] + I[2] * I[2])
                }
                N *= 4;
                A.setAttribute("id", this.shape.params.id);
                A.setAttribute("stroke-width", this.strokeThickness ? this.strokeThickness / N : 1 / N);
                return A
            }
        };
        MindFusion.registerClass(h, "MindFusion.Diagramming.ShapeRenderer");
        var f = {
            None: -1,
            Shadow: 0,
            Outline: 1,
            Decoration: 2,
            ShapeDecoration: 3
        }
    })(MindFusion.Diagramming);
    MindFusion.Diagramming.Shapes = function() {};
    MindFusion.Diagramming.Shapes.Actor = function() {
        return MindFusion.Diagramming.Shape.fromId("Actor")
    };
    MindFusion.Diagramming.Shapes.Alternative = function() {
        return MindFusion.Diagramming.Shape.fromId("Alternative")
    };
    MindFusion.Diagramming.Shapes.Arrow = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow")
    };
    MindFusion.Diagramming.Shapes.Arrow1 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow1")
    };
    MindFusion.Diagramming.Shapes.Arrow2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow2")
    };
    MindFusion.Diagramming.Shapes.Arrow3 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow3")
    };
    MindFusion.Diagramming.Shapes.Arrow4 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow4")
    };
    MindFusion.Diagramming.Shapes.Arrow5 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow5")
    };
    MindFusion.Diagramming.Shapes.Arrow6 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow6")
    };
    MindFusion.Diagramming.Shapes.Arrow7 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow7")
    };
    MindFusion.Diagramming.Shapes.Arrow8 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow8")
    };
    MindFusion.Diagramming.Shapes.Arrow9 = function() {
        return MindFusion.Diagramming.Shape.fromId("Arrow9")
    };
    MindFusion.Diagramming.Shapes.BackSlash = function() {
        return MindFusion.Diagramming.Shape.fromId("BackSlash")
    };
    MindFusion.Diagramming.Shapes.BeginLoop = function() {
        return MindFusion.Diagramming.Shape.fromId("BeginLoop")
    };
    MindFusion.Diagramming.Shapes.BowArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("BowArrow")
    };
    MindFusion.Diagramming.Shapes.BpmnComplex = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnComplex")
    };
    MindFusion.Diagramming.Shapes.BpmnDataBasedXor = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnDataBasedXor")
    };
    MindFusion.Diagramming.Shapes.BpmnEndCancel = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndCancel")
    };
    MindFusion.Diagramming.Shapes.BpmnEndCompensation = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndCompensation")
    };
    MindFusion.Diagramming.Shapes.BpmnEndError = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndError")
    };
    MindFusion.Diagramming.Shapes.BpmnEndLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndLink")
    };
    MindFusion.Diagramming.Shapes.BpmnEndMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnEndMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnEndTerminate = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEndTerminate")
    };
    MindFusion.Diagramming.Shapes.BpmnEventBasedXor = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnEventBasedXor")
    };
    MindFusion.Diagramming.Shapes.BpmnInclusive = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnInclusive")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateCancel = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateCancel")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateCompensation = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateCompensation")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateError = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateError")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateLink")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateRule = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateRule")
    };
    MindFusion.Diagramming.Shapes.BpmnIntermediateTimer = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnIntermediateTimer")
    };
    MindFusion.Diagramming.Shapes.BpmnParallelFork = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnParallelFork")
    };
    MindFusion.Diagramming.Shapes.BpmnStartLink = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartLink")
    };
    MindFusion.Diagramming.Shapes.BpmnStartMessage = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartMessage")
    };
    MindFusion.Diagramming.Shapes.BpmnStartMultiple = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartMultiple")
    };
    MindFusion.Diagramming.Shapes.BpmnStartRule = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartRule")
    };
    MindFusion.Diagramming.Shapes.BpmnStartTimer = function() {
        return MindFusion.Diagramming.Shape.fromId("BpmnStartTimer")
    };
    MindFusion.Diagramming.Shapes.Circle = function() {
        return MindFusion.Diagramming.Shape.fromId("Circle")
    };
    MindFusion.Diagramming.Shapes.Cloud = function() {
        return MindFusion.Diagramming.Shape.fromId("Cloud")
    };
    MindFusion.Diagramming.Shapes.Collate = function() {
        return MindFusion.Diagramming.Shape.fromId("Collate")
    };
    MindFusion.Diagramming.Shapes.ConeDown = function() {
        return MindFusion.Diagramming.Shape.fromId("ConeDown")
    };
    MindFusion.Diagramming.Shapes.ConeUp = function() {
        return MindFusion.Diagramming.Shape.fromId("ConeUp")
    };
    MindFusion.Diagramming.Shapes.ConnectedIssues = function() {
        return MindFusion.Diagramming.Shape.fromId("ConnectedIssues")
    };
    MindFusion.Diagramming.Shapes.CreateRequest = function() {
        return MindFusion.Diagramming.Shape.fromId("CreateRequest")
    };
    MindFusion.Diagramming.Shapes.Cross = function() {
        return MindFusion.Diagramming.Shape.fromId("Cross")
    };
    MindFusion.Diagramming.Shapes.Cube = function() {
        return MindFusion.Diagramming.Shape.fromId("Cube")
    };
    MindFusion.Diagramming.Shapes.Cylinder = function() {
        return MindFusion.Diagramming.Shape.fromId("Cylinder")
    };
    MindFusion.Diagramming.Shapes.Database = function() {
        return MindFusion.Diagramming.Shape.fromId("Database")
    };
    MindFusion.Diagramming.Shapes.DataTransmition = function() {
        return MindFusion.Diagramming.Shape.fromId("DataTransmition")
    };
    MindFusion.Diagramming.Shapes.DDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DDelay")
    };
    MindFusion.Diagramming.Shapes.Decision = function() {
        return MindFusion.Diagramming.Shape.fromId("Decision")
    };
    MindFusion.Diagramming.Shapes.Decision2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Decision2")
    };
    MindFusion.Diagramming.Shapes.DefaultFlow = function() {
        return MindFusion.Diagramming.Shape.fromId("DefaultFlow")
    };
    MindFusion.Diagramming.Shapes.Delay = function() {
        return MindFusion.Diagramming.Shape.fromId("Delay")
    };
    MindFusion.Diagramming.Shapes.DInDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DInDelay")
    };
    MindFusion.Diagramming.Shapes.DirectAccessStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("DirectAccessStorage")
    };
    MindFusion.Diagramming.Shapes.DiskStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("DiskStorage")
    };
    MindFusion.Diagramming.Shapes.Display = function() {
        return MindFusion.Diagramming.Shape.fromId("Display")
    };
    MindFusion.Diagramming.Shapes.DividedEvent = function() {
        return MindFusion.Diagramming.Shape.fromId("DividedEvent")
    };
    MindFusion.Diagramming.Shapes.DividedProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("DividedProcess")
    };
    MindFusion.Diagramming.Shapes.Document = function() {
        return MindFusion.Diagramming.Shape.fromId("Document")
    };
    MindFusion.Diagramming.Shapes.DoubleArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("DoubleArrow")
    };
    MindFusion.Diagramming.Shapes.DOutDelay = function() {
        return MindFusion.Diagramming.Shape.fromId("DOutDelay")
    };
    MindFusion.Diagramming.Shapes.Ellipse = function() {
        return MindFusion.Diagramming.Shape.fromId("Ellipse")
    };
    MindFusion.Diagramming.Shapes.EndLoop = function() {
        return MindFusion.Diagramming.Shape.fromId("EndLoop")
    };
    MindFusion.Diagramming.Shapes.ExternalOrganization = function() {
        return MindFusion.Diagramming.Shape.fromId("ExternalOrganization")
    };
    MindFusion.Diagramming.Shapes.ExternalProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("ExternalProcess")
    };
    MindFusion.Diagramming.Shapes.File = function() {
        return MindFusion.Diagramming.Shape.fromId("File")
    };
    MindFusion.Diagramming.Shapes.FramedRectangle = function() {
        return MindFusion.Diagramming.Shape.fromId("FramedRectangle")
    };
    MindFusion.Diagramming.Shapes.Gate = function() {
        return MindFusion.Diagramming.Shape.fromId("Gate")
    };
    MindFusion.Diagramming.Shapes.Heart = function() {
        return MindFusion.Diagramming.Shape.fromId("Heart")
    };
    MindFusion.Diagramming.Shapes.Heptagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Heptagon")
    };
    MindFusion.Diagramming.Shapes.Hourglass = function() {
        return MindFusion.Diagramming.Shape.fromId("Hourglass")
    };
    MindFusion.Diagramming.Shapes.Input = function() {
        return MindFusion.Diagramming.Shape.fromId("Input")
    };
    MindFusion.Diagramming.Shapes.InternalStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("InternalStorage")
    };
    MindFusion.Diagramming.Shapes.Interrupt = function() {
        return MindFusion.Diagramming.Shape.fromId("Interrupt")
    };
    MindFusion.Diagramming.Shapes.Interrupt2 = function() {
        return MindFusion.Diagramming.Shape.fromId("Interrupt2")
    };
    MindFusion.Diagramming.Shapes.IsoProcess = function() {
        return MindFusion.Diagramming.Shape.fromId("IsoProcess")
    };
    MindFusion.Diagramming.Shapes.Junction = function() {
        return MindFusion.Diagramming.Shape.fromId("Junction")
    };
    MindFusion.Diagramming.Shapes.Lightning = function() {
        return MindFusion.Diagramming.Shape.fromId("Lightning")
    };
    MindFusion.Diagramming.Shapes.LinedDocument = function() {
        return MindFusion.Diagramming.Shape.fromId("LinedDocument")
    };
    MindFusion.Diagramming.Shapes.ManualOperation = function() {
        return MindFusion.Diagramming.Shape.fromId("ManualOperation")
    };
    MindFusion.Diagramming.Shapes.Merge = function() {
        return MindFusion.Diagramming.Shape.fromId("Merge")
    };
    MindFusion.Diagramming.Shapes.MessageFromUser = function() {
        return MindFusion.Diagramming.Shape.fromId("MessageFromUser")
    };
    MindFusion.Diagramming.Shapes.MessageToUser = function() {
        return MindFusion.Diagramming.Shape.fromId("MessageToUser")
    };
    MindFusion.Diagramming.Shapes.Microform = function() {
        return MindFusion.Diagramming.Shape.fromId("Microform")
    };
    MindFusion.Diagramming.Shapes.MicroformProcessing = function() {
        return MindFusion.Diagramming.Shape.fromId("MicroformProcessing")
    };
    MindFusion.Diagramming.Shapes.MicroformRecording = function() {
        return MindFusion.Diagramming.Shape.fromId("MicroformRecording")
    };
    MindFusion.Diagramming.Shapes.MultiDocument = function() {
        return MindFusion.Diagramming.Shape.fromId("MultiDocument")
    };
    MindFusion.Diagramming.Shapes.MultiProc = function() {
        return MindFusion.Diagramming.Shape.fromId("MultiProc")
    };
    MindFusion.Diagramming.Shapes.Octagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Octagon")
    };
    MindFusion.Diagramming.Shapes.OfflineStorage = function() {
        return MindFusion.Diagramming.Shape.fromId("OfflineStorage")
    };
    MindFusion.Diagramming.Shapes.OffpageConnection = function() {
        return MindFusion.Diagramming.Shape.fromId("OffpageConnection")
    };
    MindFusion.Diagramming.Shapes.OffpageReference = function() {
        return MindFusion.Diagramming.Shape.fromId("OffpageReference")
    };
    MindFusion.Diagramming.Shapes.Or = function() {
        return MindFusion.Diagramming.Shape.fromId("Or")
    };
    MindFusion.Diagramming.Shapes.Pentagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Pentagon")
    };
    MindFusion.Diagramming.Shapes.PentagonArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("PentagonArrow")
    };
    MindFusion.Diagramming.Shapes.PointerArrow = function() {
        return MindFusion.Diagramming.Shape.fromId("PointerArrow")
    };
    MindFusion.Diagramming.Shapes.PrimitiveFromCall = function() {
        return MindFusion.Diagramming.Shape.fromId("PrimitiveFromCall")
    };
    MindFusion.Diagramming.Shapes.PrimitiveToCall = function() {
        return MindFusion.Diagramming.Shape.fromId("PrimitiveToCall")
    };
    MindFusion.Diagramming.Shapes.Procedure = function() {
        return MindFusion.Diagramming.Shape.fromId("Procedure")
    };
    MindFusion.Diagramming.Shapes.Process = function() {
        return MindFusion.Diagramming.Shape.fromId("Process")
    };
    MindFusion.Diagramming.Shapes.Prysm = function() {
        return MindFusion.Diagramming.Shape.fromId("Prysm")
    };
    MindFusion.Diagramming.Shapes.PunchedCard = function() {
        return MindFusion.Diagramming.Shape.fromId("PunchedCard")
    };
    MindFusion.Diagramming.Shapes.PyramidDown = function() {
        return MindFusion.Diagramming.Shape.fromId("PyramidDown")
    };
    MindFusion.Diagramming.Shapes.PyramidUp = function() {
        return MindFusion.Diagramming.Shape.fromId("PyramidUp")
    };
    MindFusion.Diagramming.Shapes.Quill = function() {
        return MindFusion.Diagramming.Shape.fromId("Quill")
    };
    MindFusion.Diagramming.Shapes.Rectangle = function() {
        return MindFusion.Diagramming.Shape.fromId("Rectangle")
    };
    MindFusion.Diagramming.Shapes.Reversed = function() {
        return MindFusion.Diagramming.Shape.fromId("Reversed")
    };
    MindFusion.Diagramming.Shapes.RevTriangle = function() {
        return MindFusion.Diagramming.Shape.fromId("RevTriangle")
    };
    MindFusion.Diagramming.Shapes.RevWithCirc = function() {
        return MindFusion.Diagramming.Shape.fromId("RevWithCirc")
    };
    MindFusion.Diagramming.Shapes.RevWithLine = function() {
        return MindFusion.Diagramming.Shape.fromId("RevWithLine")
    };
    MindFusion.Diagramming.Shapes.Rhombus = function() {
        return MindFusion.Diagramming.Shape.fromId("Rhombus")
    };
    MindFusion.Diagramming.Shapes.RoundRect = function() {
        return MindFusion.Diagramming.Shape.fromId("RoundRect")
    };
    MindFusion.Diagramming.Shapes.RSave = function() {
        return MindFusion.Diagramming.Shape.fromId("RSave")
    };
    MindFusion.Diagramming.Shapes.Save = function() {
        return MindFusion.Diagramming.Shape.fromId("Save")
    };
    MindFusion.Diagramming.Shapes.Slash = function() {
        return MindFusion.Diagramming.Shape.fromId("Slash")
    };
    MindFusion.Diagramming.Shapes.Sort = function() {
        return MindFusion.Diagramming.Shape.fromId("Sort")
    };
    MindFusion.Diagramming.Shapes.Sphere = function() {
        return MindFusion.Diagramming.Shape.fromId("Sphere")
    };
    MindFusion.Diagramming.Shapes.Star = function() {
        return MindFusion.Diagramming.Shape.fromId("Star")
    };
    MindFusion.Diagramming.Shapes.Start = function() {
        return MindFusion.Diagramming.Shape.fromId("Start")
    };
    MindFusion.Diagramming.Shapes.Tape = function() {
        return MindFusion.Diagramming.Shape.fromId("Tape")
    };
    MindFusion.Diagramming.Shapes.Terminator = function() {
        return MindFusion.Diagramming.Shape.fromId("Terminator")
    };
    MindFusion.Diagramming.Shapes.Tetragon = function() {
        return MindFusion.Diagramming.Shape.fromId("Tetragon")
    };
    MindFusion.Diagramming.Shapes.TransmittalTape = function() {
        return MindFusion.Diagramming.Shape.fromId("TransmittalTape")
    };
    MindFusion.Diagramming.Shapes.Triangle = function() {
        return MindFusion.Diagramming.Shape.fromId("Triangle")
    };
    MindFusion.Diagramming.Shapes.RightTriangle = function() {
        return MindFusion.Diagramming.Shape.fromId("RightTriangle")
    };
    MindFusion.Diagramming.Shapes.Decagon = function() {
        return MindFusion.Diagramming.Shape.fromId("Decagon")
    };
    MindFusion.Diagramming.Shapes.Trapezoid = function() {
        return MindFusion.Diagramming.Shape.fromId("Trapezoid")
    };
    MindFusion.Diagramming.Shapes.Star4Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star4Pointed")
    };
    MindFusion.Diagramming.Shapes.Star5Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star5Pointed")
    };
    MindFusion.Diagramming.Shapes.Star6Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star6Pointed")
    };
    MindFusion.Diagramming.Shapes.Star7Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star7Pointed")
    };
    MindFusion.Diagramming.Shapes.Star16Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star16Pointed")
    };
    MindFusion.Diagramming.Shapes.Star24Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star24Pointed")
    };
    MindFusion.Diagramming.Shapes.Star32Pointed = function() {
        return MindFusion.Diagramming.Shape.fromId("Star32Pointed")
    };
    MindFusion.Diagramming.Shapes.Donut = function() {
        return MindFusion.Diagramming.Shape.fromId("Donut")
    };
    MindFusion.Diagramming.Shapes.Plaque = function() {
        return MindFusion.Diagramming.Shape.fromId("Plaque")
    };
    MindFusion.Diagramming.Shapes.prototype = {};
    MindFusion.registerClass(MindFusion.Diagramming.Shapes, "MindFusion.Diagramming.Shapes");
    (function(b) {
        var a = b.Style = function(d) {
            mflayer.initializeBase(a, this);
            if (d) {
                this.brush = d.brush;
                this.backBrush = d.backBrush;
                this.stroke = d.stroke;
                this.strokeThickness = d.strokeThickness;
                this.strokeDashStyle = d.strokeDashStyle;
                this.textColor = d.textColor;
                this.fontName = d.fontName;
                this.fontSize = d.fontSize;
                this.fontStyle = d.fontStyle;
                this.shadowColor = d.shadowColor;
                this.nodeEffects = [];
                if (d.nodeEffects) {
                    this.nodeEffects = d.nodeEffects.slice(0)
                }
                if (d.effects) {
                    for (var e = 0, c = d.effects.length; e < c; e++) {
                        if (d.effects[e] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var g = mflayer.parseType(d.effects[e].typeName);
                        if (g) {
                            var f = new g(this);
                            f.fromJson(d.effects[e]);
                            this.nodeEffects.push(f)
                        }
                    }
                }
            }
        };
        a.prototype = {
            getType: function() {
                return this.constructor.__typeName
            },
            fromJson: function(e) {
                this.brush = e.brush;
                this.backBrush = e.backBrush;
                this.stroke = e.stroke;
                this.strokeThickness = e.strokeThickness;
                this.strokeDashStyle = e.strokeDashStyle;
                this.textColor = e.textColor;
                this.fontName = e.fontName;
                this.fontSize = e.fontSize;
                this.fontStyle = e.fontStyle;
                this.shadowColor = e.shadowColor;
                this.nodeEffects = [];
                if (e.effects) {
                    for (var d = 0, c = e.effects.length; d < c; d++) {
                        if (e.effects[d] == null) {
                            this.nodeEffects.push(null);
                            continue
                        }
                        var g = mflayer.parseType(e.effects[d].typeName);
                        if (g) {
                            var f = new g(this);
                            f.fromJson(e.effects[d]);
                            this.nodeEffects.push(f)
                        }
                    }
                }
            },
            toJson: function() {
                var e = {
                    brush: this.brush,
                    backBrush: this.backBrush,
                    stroke: this.stroke,
                    strokeThickness: this.strokeThickness,
                    strokeDashStyle: this.strokeDashStyle,
                    textColor: this.textColor,
                    fontName: this.fontName,
                    fontSize: this.fontSize,
                    fontStyle: this.fontStyle,
                    shadowColor: this.shadowColor
                };
                var f = [];
                if (this.nodeEffects) {
                    for (var d = 0, c = this.nodeEffects.length; d < c; d++) {
                        if (this.nodeEffects[d] == null) {
                            f.push(null)
                        } else {
                            f.push(this.nodeEffects[d].toJson())
                        }
                    }
                }
                e.effects = f;
                return e
            },
            saveToXml: function(e, d) {
                if (this.hasFontName()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "FontFamily");
                    d.writeString(this.fontName, "Value", c).setAttribute("Type", "1")
                }
                if (this.hasFontSize()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "FontSize");
                    d.writeFloat(this.fontSize, "Value", c).setAttribute("Type", "6")
                }
                if (this.hasFontStyle()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "FontStyle");
                    d.writeInt(this.fontStyle, "Value", c).setAttribute("Type", "8")
                }
                if (this.hasBrush()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "Brush");
                    this.writeBrush(this.brush, c, d).setAttribute("Type", "100")
                }
                if (this.hasStroke()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "Stroke");
                    this.writeBrush(this.stroke, c, d).setAttribute("Type", "100")
                }
                if (this.hasStrokeThickness()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "StrokeThickness");
                    d.writeFloat(this.strokeThickness, "Value", c).setAttribute("Type", "6")
                }
                if (this.hasStrokeDashStyle()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "StrokeDashStyle");
                    d.writeInt(this.strokeDashStyle, "Value", c).setAttribute("Type", "8")
                }
                if (this.hasShadowColor()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "ShadowBrush");
                    this.writeBrush(this.shadowColor, c, d).setAttribute("Type", "100")
                }
                if (this.hasTextColor()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "TextBrush");
                    this.writeBrush(this.textColor, c, d).setAttribute("Type", "100")
                }
                if (this.hasNodeEffects()) {
                    var c = d.addChildElement("Property", e);
                    c.setAttribute("Name", "Effects");
                    this.writeEffects(c, d)
                }
            },
            loadFromXml: function(g, f) {
                var h = g.getElementsByTagName("Property");
                for (var e = 0; e < h.length; e++) {
                    var c = h[e];
                    var d = c.getAttribute("Name");
                    switch (d) {
                        case "FontFamily":
                            this.fontName = f.readString("Value", c);
                            break;
                        case "FontSize":
                            this.fontSize = f.readFloat("Value", c);
                            break;
                        case "FontStyle":
                            this.fontStyle = f.readInt("Value", c);
                            break;
                        case "Brush":
                            this.brush = this.readBrush(c, f);
                            break;
                        case "Stroke":
                            this.stroke = this.readBrush(c, f);
                            break;
                        case "StrokeThickness":
                            this.strokeThickness = f.readFloat("Value", c);
                            break;
                        case "StrokeDashStyle":
                            this.strokeDashStyle = f.readInt("Value", c);
                            break;
                        case "ShadowBrush":
                            this.shadowColor = this.readBrush(c, f);
                            break;
                        case "TextBrush":
                            this.textColor = this.readBrush(c, f);
                            break;
                        case "Effects":
                            this.readEffects(c, f);
                            break
                    }
                }
            },
            writeBrush: function(c, e, d) {
                var f = d.addChildElement("Value", e);
                d.writeBrush(c, "Brush", f);
                return f
            },
            readBrush: function(d, c) {
                var e = c.selectSingleNode("Value", d);
                return c.readBrush("Brush", e)
            },
            writeEffects: function(j, g) {
                var f = g.addChildElement("Value", j);
                f.setAttribute("Type", "105");
                var h = g.addChildElement("List", f);
                for (var e = 0; e < this.nodeEffects.length; e++) {
                    var d = g.addChildElement("Item", h);
                    var k = g.addChildElement("Value", d);
                    k.setAttribute("Type", "103");
                    var c = this.nodeEffects[e];
                    g.writeEffect(c, "Effect", k)
                }
            },
            readEffects: function(g, f) {
                this.nodeEffects = [];
                var e = f.selectSingleNode("Value", g);
                var h = e.getElementsByTagName("Effect");
                for (var d = 0; d < h.length; d++) {
                    var c = h[d];
                    this.nodeEffects.push(f.readEffect(c))
                }
            },
            clone: function() {
                var c = new this.constructor();
                c.brush = this.brush;
                c.backBrush = this.backBrush;
                c.stroke = this.stroke;
                c.strokeThickness = this.strokeThickness;
                c.strokeDashStyle = this.strokeDashStyle;
                c.textColor = this.textColor;
                c.fontName = this.fontName;
                c.fontSize = this.fontSize;
                c.fontStyle = this.fontStyle;
                c.shadowColor = this.shadowColor;
                if (this.nodeEffects) {
                    c.nodeEffects = this.nodeEffects.slice(0)
                }
                return c
            },
            getBrush: function() {
                return this.brush
            },
            setBrush: function(c) {
                this.brush = c
            },
            hasBrush: function() {
                return this.brush ? true : false
            },
            getBackBrush: function() {
                return this.backBrush
            },
            setBackBrush: function(c) {
                this.backBrush = c
            },
            hasBackBrush: function() {
                return this.backBrush ? true : false
            },
            getStroke: function() {
                return this.stroke
            },
            setStroke: function(c) {
                this.stroke = c
            },
            hasStroke: function() {
                return this.stroke ? true : false
            },
            getStrokeThickness: function() {
                return this.strokeThickness
            },
            setStrokeThickness: function(c) {
                this.strokeThickness = c
            },
            hasStrokeThickness: function() {
                return this.strokeThickness ? true : false
            },
            getStrokeDashStyle: function() {
                return this.strokeDashStyle
            },
            setStrokeDashStyle: function(c) {
                this.strokeDashStyle = c
            },
            hasStrokeDashStyle: function() {
                return this.strokeDashStyle !== undefined && this.strokeDashStyle !== null
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextColor: function(c) {
                this.textColor = c
            },
            hasTextColor: function() {
                return this.textColor ? true : false
            },
            getFontName: function() {
                return this.fontName
            },
            setFontName: function(c) {
                this.fontName = c
            },
            hasFontName: function() {
                return this.fontName ? true : false
            },
            getFontSize: function() {
                return this.fontSize
            },
            setFontSize: function(c) {
                this.fontSize = c
            },
            hasFontSize: function() {
                return this.fontSize ? true : false
            },
            getFontStyle: function() {
                return this.fontStyle
            },
            setFontStyle: function(c) {
                this.fontStyle = c
            },
            hasFontStyle: function() {
                return this.fontStyle !== undefined && this.fontStyle !== null
            },
            getShadowColor: function() {
                return this.shadowColor
            },
            setShadowColor: function(c) {
                this.shadowColor = c
            },
            hasShadowColor: function() {
                return this.shadowColor !== undefined ? true : false
            },
            getNodeEffects: function() {
                return this.nodeEffects
            },
            setNodeEffects: function(c) {
                this.nodeEffects = c
            },
            hasNodeEffects: function() {
                return this.nodeEffects ? true : false
            },
            init: function() {
                if (!b.StyleBuilder) {
                    b.StyleBuilder = new MindFusion.Builder(a.prototype, null, this)
                } else {
                    b.StyleBuilder.setInstance(this)
                }
                return b.StyleBuilder
            }
        };
        a.With = function(c) {
            if (!b.StyleBuilder) {
                b.StyleBuilder = new MindFusion.Builder(a.prototype)
            } else {
                b.StyleBuilder.setInstance(null)
            }
            return b.StyleBuilder
        };
        b.StyleBuilder = null;
        MindFusion.registerClass(a, "MindFusion.Diagramming.Style")
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.SvgExporter = function() {};
        a.prototype = {
            exportElement: function(d, j) {
                if (!j) {
                    j = document
                }
                j._mf_context = d.context;
                var h = j.createElementNS("http://www.w3.org/2000/svg", "svg");
                h.setAttribute("version", "1.1");
                var n = d.getBounds();
                h.setAttribute("width", parseInt(n.width * d.scale));
                h.setAttribute("height", parseInt(n.height * d.scale));
                var o = "";
                o += n.x + " ";
                o += n.y + " ";
                o += n.width + " ";
                o += n.height;
                h.setAttribute("viewBox", o);
                var k = j.createElementNS("http://www.w3.org/2000/svg", "defs");
                h.appendChild(k);
                j._mf_defsElement = k;
                j._mf_clipCounter = 0;
                var c = d.getBounds().clone();
                c.brush = d.getBackBrush();
                c.pen = null;
                backgroundElement = c.createSvgElement(j);
                if (backgroundElement) {
                    h.appendChild(backgroundElement)
                }
                for (var f = 0; f < d.items.length; f++) {
                    var l = d.items[f];
                    var e = l.graphicsContainer.createSvgElement(j);
                    if (e != null) {
                        var g = l.shapeRenderer;
                        if (g) {
                            e.setAttribute("fill", g.outlineBrush);
                            e.setAttribute("stroke", g.outlinePen)
                        }
                        h.appendChild(e)
                    }
                }
                delete j._mf_context;
                delete j._mf_defsElement;
                delete j._mf_clipCounter;
                return h
            },
            exportString: function(c) {
                var f = document.implementation.createDocument("", "", null);
                var e = this.exportElement(c, f);
                f.appendChild(e);
                var d = (new XMLSerializer()).serializeToString(f);
                return d
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.SvgExporter")
    })(MindFusion.Diagramming);
    (function(a) {
        var h = MindFusion.Collections.ArrayList;
        var c = MindFusion.Drawing.Line;
        var f = MindFusion.Drawing.Point;
        var b = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Font;
        var g = MindFusion.Diagramming.EffectPhase;
        var e = MindFusion.Diagramming.Utils;
        var k = a.SvgNode = function(l) {
            a.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(k, this, [l]);
            a.Diagram.suppressSetDirty = false
        };
        k.prototype = {
            clone: function() {
                a.Diagram.suppressSetDirty = true;
                var l = mflayer.callBaseMethod(k, this, "clone", []);
                l.setContent(this.getContent());
                a.Diagram.suppressSetDirty = false;
                return l
            },
            toJson: function() {
                var l = mflayer.callBaseMethod(k, this, "toJson", []);
                var n = this.getContent();
                if (n) {
                    if (n.svgString) {
                        if (this.parent.saveSVG) {
                            l.svgIndex = this.parent.saveSVG(n.svgString)
                        } else {
                            l.svgData = n.svgString
                        }
                    } else {
                        l.contentFile = n.fileName
                    }
                }
                return l
            },
            fromJson: function(l) {
                mflayer.callBaseMethod(k, this, "fromJson", [l]);
                var n = new MindFusion.Diagramming.SvgContent();
                if (l.svgIndex != undefined) {
                    n.svgString = this.parent.svgs[l.svgIndex]
                } else {
                    if (l.contentFile) {
                        n.fileName = l.contentFile
                    } else {
                        if (l.svgData) {
                            n.svgString = l.svgData
                        }
                    }
                }
                this.setContent(n)
            },
            loadFromXml: function(n, l) {
                mflayer.callBaseMethod(k, this, "loadFromXml", [n, l]);
                var o = new MindFusion.Diagramming.SvgContent();
                var p = l.readSvg("Content", n);
                if (p) {
                    o.svgString = e.Base64.encode(p)
                }
                var q = l.readString("SvgUrl", n);
                if (q) {
                    o.fileName = q
                }
                this.setContent(o)
            },
            saveToXml: function(n, l) {
                mflayer.callBaseMethod(k, this, "saveToXml", [n, l]);
                if (this.content.svgString) {
                    l.writeSvg(e.Base64.decode(this.content.svgString), "Content", n)
                }
                if (this.content.fileName) {
                    l.writeString(this.content.fileName, "SvgUrl", n)
                }
            },
            setContent: function(n) {
                if (this.content != n) {
                    this.content = n;
                    if (n) {
                        this.image = new MindFusion.Drawing.Image(this.bounds);
                        this.image.svg = true;
                        this.image.image.width = 100;
                        this.image.image.height = 100;
                        mflayer.addHandlers(this.image.image, {
                            load: mflayer.createDelegate(this, this.loadImage)
                        });
                        if (this.content.svgString) {
                            var l = "data:image/svg+xml;base64," + this.content.svgString;
                            this.image.image.src = l
                        } else {
                            if (this.content.fileName) {
                                this.image.image.src = this.content.fileName
                            }
                        }
                    }
                    this.setDiagramDirty()
                }
            },
            getContent: function() {
                return this.content
            },
            setImageLocation: function(l) {},
            getImageLocation: function() {
                return null
            },
            init: function() {
                if (!a.SvgNodeBuilder) {
                    a.SvgNodeBuilder = new MindFusion.Builder(k.prototype, null, this)
                } else {
                    a.SvgNodeBuilder.setInstance(this)
                }
                return a.SvgNodeBuilder
            }
        };
        k.With = function(l) {
            if (!a.SvgNodeBuilder) {
                a.SvgNodeBuilder = new MindFusion.Builder(k.prototype, l)
            } else {
                a.SvgNodeBuilder.setInstance(null)
            }
            return a.SvgNodeBuilder
        };
        a.SvgNodeBuilder = null;
        MindFusion.registerClass(k, "MindFusion.Diagramming.SvgNode", a.ShapeNode);
        var j = a.SvgContent = function() {};
        j.prototype = {
            parse: function(l) {
                this.fileName = l
            },
            parseSvg: function(l) {
                this.svgString = l
            },
            fileName: null,
            svgString: null
        };
        MindFusion.registerClass(j, "MindFusion.Diagramming.SvgContent")
    })(MindFusion.Diagramming);
    (function(a) {
        var c = MindFusion.Drawing.Point;
        var b = a.TableConnectionPoint = function(f, e, d, g) {
            mflayer.initializeBase(b, this, [f, e, d]);
            this.type = this.constructor.__typeName;
            this.node = f;
            this.link = e;
            this.incoming = d;
            this.anchorPointDetails = {
                index: -1,
                point: new MindFusion.Drawing.Point(0, 0)
            };
            if (g === undefined) {
                g = -1
            }
            this.row = g;
            if (g > -1) {
                this.anchorPointDetails.row = f.getRow(g)
            }
        };
        b.prototype = {
            addLinkToNode: function() {
                if (!this.anchorPointDetails.row) {
                    if (this.incoming) {
                        this.node.addIncomingLink(this.link)
                    } else {
                        this.node.addOutgoingLink(this.link)
                    }
                } else {
                    if (this.incoming) {
                        this.node.addRowIncomingLink(this.row, this.link)
                    } else {
                        this.node.addRowOutgoingLink(this.row, this.link)
                    }
                }
            },
            removeLinkFromNode: function() {
                if (!this.anchorPointDetails.row) {
                    if (this.incoming) {
                        this.node.removeIncomingLink(this.link)
                    } else {
                        this.node.removeOutgoingLink(this.link)
                    }
                    return
                }
                if (this.incoming) {
                    this.node.removeRowIncomingLink(this.row, this.link)
                } else {
                    this.node.removeRowOutgoingLink(this.row, this.link)
                }
            },
            saveEndRelative: function() {
                var d = this.incoming ? this.link.getEndPoint() : this.link.getStartPoint();
                var g = this.node.rotationAngle;
                if (g !== 0) {
                    var e = a.Utils.getCenter(this.node.bounds);
                    d = a.Utils.rotatePointAt(d, e, -g)
                }
                var f = this.anchorPointDetails.row ? this.node.getRowRect(this.row) : this.node.bounds;
                this.relativePosition = a.Utils.getRectPtPercent(d, f)
            },
            getNearestBorderPoint: function(e) {
                var h = this.node.connectionStyle != a.ConnectionStyle.Node ? this.node.rowFromPoint(e) : -1;
                if (h == -1) {
                    return mflayer.callBaseMethod(b, this, "getNearestBorderPoint", [e])
                }
                this.row = h;
                var f = this.node.getRowRect(h);
                var d = f.x + f.width / 2;
                var j = f.y + f.height / 2;
                var g = {
                    row: this.node.getRow(h),
                    point: e.x > d ? new c(f.right(), j) : new c(f.left(), j),
                    location: e.x > d ? new c(100, 50) : new c(0, 50),
                    index: -1
                };
                return g
            },
            alignEndPointToBorder: function(d) {
                if (this.anchorPointDetails && this.anchorPointDetails.row) {
                    var f = this.node.getBounds();
                    var e = this.node.getRowRect(this.row).center();
                    if (d.x < e.x) {
                        this.anchorPointDetails.point = new c(f.x, e.y)
                    } else {
                        this.anchorPointDetails.point = new c(f.right(), e.y)
                    }
                } else {
                    mflayer.callBaseMethod(b, this, "alignEndPointToBorder", [d])
                }
            },
            linkChanges: function(e, d) {
                if (e == this.node) {
                    return this.node.rowFromPoint(d) != this.row
                }
                return mflayer.callBaseMethod(b, this, "linkChanges", [e, d])
            },
            rowObject: function() {
                if (this.anchorPointDetails && this.anchorPointDetails.row) {
                    return this.anchorPointDetails.row
                }
                return null
            },
            getInitialPoint: function() {
                return this.anchorPointDetails.row ? this.node.getRowRect(this.row).center() : mflayer.callBaseMethod(b, this, "getInitialPoint", [])
            },
            getIntersection: function(f, e) {
                var d = this.node;
                if (this.row != -1) {
                    return d.getRowIntersection(this.row, f, e)
                }
                return d.getIntersection(f, e)
            },
            getEndPoint: function() {
                var h = this.relativePosition;
                var f = this.anchorPointDetails.row ? this.node.getRowRect(this.row) : this.node.bounds;
                var d = a.Utils.rectPtFromPercent(h, f);
                d.x = Math.min(d.x, this.node.bounds.right());
                d.y = Math.min(d.y, this.node.bounds.bottom());
                var g = this.node.rotationAngle;
                if (g !== 0) {
                    var e = a.Utils.getCenter(this.node.bounds);
                    d = a.Utils.rotatePointAt(d, e, g)
                }
                return d
            },
            setRow: function(e, d) {
                if (this.row != e) {
                    if (d) {
                        this.removeLinkFromNode()
                    }
                    this.row = e;
                    this.anchorPointDetails.row = this.node.getRow(e);
                    if (d) {
                        this.addLinkToNode();
                        if (this.incoming) {
                            this.link.updateDestinationIntersection()
                        } else {
                            this.link.updateOriginIntersection()
                        }
                    }
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.TableConnectionPoint", a.ConnectionPoint)
    })(MindFusion.Diagramming);
    (function(b) {
        var o = MindFusion.Collections.ArrayList;
        var g = MindFusion.Drawing.Line;
        var j = MindFusion.Drawing.Border3D;
        var l = MindFusion.Drawing.Point;
        var c = MindFusion.Drawing.Rect;
        var k = MindFusion.Drawing.Font;
        var a = MindFusion.Drawing.GraphicsUnit;
        var f = MindFusion.Drawing.Path;
        var n = MindFusion.Diagramming.EffectPhase;
        var e = MindFusion.Drawing.Size;
        var h = MindFusion.Diagramming.FitSize;
        var d = b.TableNode = function(p) {
            b.Diagram.suppressSetDirty = true;
            mflayer.initializeBase(d, this, [p]);
            this.captionHeight = 6;
            this.text.fitInBounds = true;
            this.text.lineAlignment = b.Alignment.Center;
            this.cells = new MindFusion.Collections.Grid(1, 1);
            this.rows = [this.createRow()];
            this.columns = [this.createColumn()];
            this.currentScrollRow = 0;
            this.connectionStyle = b.ConnectionStyle.Rows;
            b.Diagram.suppressSetDirty = false;
            this.cellFrameStyle = b.CellFrameStyle.Simple;
            this.allowResizeColumns = false;
            this.allowResizeRows = false
        };
        d.prototype = {
            clone: function() {
                b.Diagram.suppressSetDirty = true;
                var u = mflayer.callBaseMethod(d, this, "clone", []);
                u.captionHeight = this.captionHeight;
                u.currentScrollRow = this.currentScrollRow;
                u.connectionStyle = this.connectionStyle;
                u.captionBackBrush = this.captionBackBrush;
                u.captionFont = this.captionFont;
                u.setScrollable(this.getScrollable());
                u.shape = this.shape;
                u.cellFrameStyle = this.cellFrameStyle;
                u.setEnableStyledText(this.getEnableStyledText());
                u.allowResizeColumns = this.allowResizeColumns;
                u.allowResizeRows = this.allowResizeRows;
                u.cells = this.cells.clone();
                u.rows = this.rows.slice(0);
                for (var q = 0; q < u.rows.length; q++) {
                    var s = u.rows[q];
                    if (s) {
                        u.rows[q] = this.copyRow(s)
                    }
                }
                u.columns = this.columns.slice(0);
                for (var t = 0; t < u.columns.length; t++) {
                    var p = u.columns[t];
                    if (p) {
                        u.columns[t] = this.copyColumn(p)
                    }
                }
                b.Diagram.suppressSetDirty = false;
                return u
            },
            toJson: function() {
                var p = mflayer.callBaseMethod(d, this, "toJson", []);
                p.captionHeight = this.captionHeight;
                p.currentScrollRow = this.currentScrollRow;
                p.connectionStyle = this.connectionStyle;
                p.captionBackBrush = this.captionBackBrush;
                p.captionFont = this.captionFont;
                p.scrollable = this.getScrollable();
                p.cellFrameStyle = this.cellFrameStyle;
                p.enableStyledText = this.getEnableStyledText();
                p.allowResizeColumns = this.getAllowResizeColumns();
                p.allowResizeRows = this.getAllowResizeRows();
                p.shape = this.shape;
                p.rows = [];
                for (var s = 0; s < this.cells.rows; s++) {
                    var t = this.getRow(s);
                    p.rows[s] = {
                        height: t.height
                    }
                }
                p.columns = [];
                for (var u = 0; u < this.cells.columns; u++) {
                    var q = this.getColumn(u);
                    p.columns[u] = this.copyColumn(q)
                }
                p.cells = [];
                for (var s = 0; s < this.cells.rows; s++) {
                    for (var u = 0; u < this.cells.columns; u++) {
                        p.cells.push(this.getCell(u, s).toJson())
                    }
                }
                return p
            },
            fromJson: function(q) {
                mflayer.callBaseMethod(d, this, "fromJson", [q]);
                this.captionHeight = q.captionHeight;
                this.currentScrollRow = q.currentScrollRow;
                this.connectionStyle = q.connectionStyle;
                this.captionBackBrush = q.captionBackBrush;
                if (q.captionFont) {
                    this.captionFont = k.copy(q.captionFont)
                }
                this.setScrollable(q.scrollable);
                if (q.cellFrameStyle !== undefined) {
                    this.cellFrameStyle = q.cellFrameStyle
                }
                this.setEnableStyledText(q.enableStyledText);
                if (q.allowResizeColumns) {
                    this.setAllowResizeColumns(q.allowResizeColumns)
                }
                if (q.allowResizeRows) {
                    this.setAllowResizeRows(q.allowResizeRows)
                }
                if (q.shape) {
                    this.setShape(q.shape)
                }
                this.rows = [];
                for (var s = 0; s < q.rows.length; s++) {
                    this.rows[s] = this.copyRow(q.rows[s])
                }
                this.columns = [];
                for (var t = 0; t < q.columns.length; t++) {
                    this.columns[t] = this.copyColumn(q.columns[t])
                }
                this.cells = new MindFusion.Collections.Grid(q.columns.length, q.rows.length);
                var p = 0;
                for (var s = 0; s < this.cells.rows; s++) {
                    for (var t = 0; t < this.cells.columns; t++) {
                        this.getCell(t, s).fromJson(q.cells[p++])
                    }
                }
            },
            loadFromXml: function(z, p) {
                mflayer.callBaseMethod(d, this, "loadFromXml", [z, p]);
                if (this.getText() == "") {
                    this.setText(p.readString("Caption", z))
                }
                this.setEnableStyledText(p.readBool("EnableStyledText", z));
                this.captionHeight = p.readFloat("CaptionHeight", z);
                this.captionBackBrush = p.readBrush("CaptionBackBrush", z);
                var A = p.readStringFormat("CaptionFormat", z);
                if (A) {
                    this.setTextAlignment(A.alignment);
                    this.setLineAlignment(A.lineAlignment)
                } else {
                    this.setTextAlignment(p.readInt("TextAlignment", z));
                    this.setLineAlignment(p.readInt("TextVerticalAlignment", z))
                }
                this.shape = p.readInt("Shape", z, b.SimpleShape.Rectangle);
                this.connectionStyle = p.readInt("ConnectionStyle", z, this.connectionStyle);
                this.cellFrameStyle = p.readInt("CellFrameStyle", z, this.cellFrameStyle);
                this.currentScrollRow = p.readInt("CurrentScrollRow", z);
                this.setScrollable(p.readBool("Scrollable", z));
                this.setAllowResizeColumns(p.readBool("AllowResizeColumns", z));
                this.setAllowResizeRows(p.readBool("AllowResizeRows", z));
                var r = z.getElementsByTagName("Row");
                var v = z.getElementsByTagName("Column");
                var q = z.getElementsByTagName("Cell");
                if (r.length * v.length != q.length) {
                    throw new Exception("The number of cell elements does not match the number of rows and columns in the table.")
                }
                this.redimTable(v.length, r.length);
                for (var t = 0; t < r.length; ++t) {
                    this.getRow(t).height = p.readFloat("Height", r[t])
                }
                for (var t = 0; t < v.length; ++t) {
                    this.getColumn(t).width = p.readFloat("Width", v[t]);
                    this.getColumn(t).columnStyle = p.readInt("ColumnStyle", v[t])
                }
                var u = 0;
                for (var t = 0; t < r.length; ++t) {
                    for (var s = 0; s < v.length; ++s) {
                        var w = this.getCell(s, t);
                        w.loadFromXml(q[u++], p)
                    }
                }
            },
            saveToXml: function(C, q) {
                mflayer.callBaseMethod(d, this, "saveToXml", [C, q]);
                q.writeBool(this.getEnableStyledText(), "EnableStyledText", C);
                q.writeFloat(this.captionHeight, "CaptionHeight", C);
                q.writeBrush(this.captionBackBrush, "CaptionBackBrush", C);
                q.writeInt(this.getTextAlignment(), "TextAlignment", C);
                q.writeInt(this.getLineAlignment(), "TextVerticalAlignment", C);
                q.writeInt(this.shape, "Shape", C);
                q.writeInt(this.connectionStyle, "ConnectionStyle", C);
                q.writeInt(this.cellFrameStyle, "CellFrameStyle", C);
                q.writeInt(this.currentScrollRow, "CurrentScrollRow", C);
                q.writeBool(this.getScrollable(), "Scrollable", C);
                q.writeBool(this.getAllowResizeColumns(), "AllowResizeColumns", C);
                q.writeBool(this.getAllowResizeRows(), "AllowResizeRows", C);
                var w = q.addChildElement("Cells", C);
                for (var v = 0; v < this.rows.length; v++) {
                    for (var t = 0; t < this.columns.length; t++) {
                        var A = q.addChildElement("Cell", w);
                        var B = this.getCell(t, v);
                        B.saveToXml(A, q)
                    }
                }
                var z = q.addChildElement("Rows", C);
                for (var v = 0; v < this.rows.length; v++) {
                    var u = q.addChildElement("Row", z);
                    var D = this.getRow(v);
                    q.writeFloat(D.height, "Height", u)
                }
                var p = q.addChildElement("Columns", C);
                for (var v = 0; v < this.columns.length; v++) {
                    var r = q.addChildElement("Column", p);
                    var s = this.getColumn(v);
                    q.writeFloat(s.width, "Width", r);
                    q.writeInt(s.columnStyle, "ColumnStyle", r)
                }
            },
            getCell: function(q, r) {
                var p = this.cells.get(q, r);
                if (!p) {
                    p = this.createCell();
                    this.cells.set(q, r, p)
                }
                return p
            },
            getTooltip: function(p) {
                var q = this.cellFromPoint(p);
                if (q && q.cell.tooltip) {
                    return q.cell.tooltip
                }
                return mflayer.callBaseMethod(d, this, "getTooltip", [p])
            },
            createCell: function() {
                var p = new b.Cell();
                p.parent = this;
                return p
            },
            getRow: function(q) {
                if (q >= this.rows.length) {
                    return undefined
                }
                var p = this.rows[q];
                if (!p) {
                    p = this.createRow();
                    this.rows[q] = p
                }
                return p
            },
            setRowHeight: function(q, p) {
                var r;
                if (typeof q === "number") {
                    r = q;
                    q = this.getRow(q)
                }
                if (q.height == p) {
                    return
                }
                q.height = p;
                this.updateLinksPos(r || o.indexOf(this.rows, q));
                this.invalidate()
            },
            createRow: function() {
                return {
                    height: 6,
                    incomingLinks: [],
                    outgoingLinks: []
                }
            },
            copyRow: function(p) {
                return {
                    height: p.height,
                    incomingLinks: [],
                    outgoingLinks: []
                }
            },
            getColumn: function(p) {
                var q = this.columns[p];
                if (!q) {
                    q = this.createColumn();
                    this.columns[p] = q
                }
                return q
            },
            setColumnWidth: function(p, q) {
                if (typeof p === "number") {
                    p = this.getColumn(p)
                }
                if (p.width == q) {
                    return
                }
                p.width = q;
                this.calcAutoWidths();
                this.invalidate()
            },
            setColumnStyle: function(p, q) {
                if (typeof p === "number") {
                    p = this.getColumn(p)
                }
                if (p.columnStyle == q) {
                    return
                }
                p.columnStyle = q;
                this.calcAutoWidths();
                this.invalidate()
            },
            createColumn: function() {
                return {
                    width: 18,
                    columnStyle: b.ColumnStyle.FixedWidth
                }
            },
            copyColumn: function(p) {
                return {
                    width: p.width,
                    columnStyle: p.columnStyle
                }
            },
            setParent: function(q) {
                this.parent = q;
                for (var p = 0; p < this.cells.rows; p++) {
                    for (var s = 0; s < this.cells.columns; s++) {
                        this.getCell(s, p).parent.parent = q
                    }
                }
            },
            containsPoint: function(p) {
                var q = this.getRotatedBounds();
                if (!q.containsPoint(p)) {
                    return false
                }
                if (b.Utils.pointInPolygon(p, this.getOutline())) {
                    return true
                }
                if (this.selected && this.handleAtPoint(p)) {
                    return true
                }
                return false
            },
            getOutline: function() {
                if (this.graphicsContainer.invalidParent) {
                    this.updateCanvasElements();
                    this.graphicsContainer.invalidParent = null
                }
                var q = [];
                q.push(this.bounds.topLeft());
                q.push(this.bounds.topRight());
                q.push(this.bounds.bottomRight());
                q.push(this.bounds.bottomLeft());
                b.Utils.rotatePointsAt(q, b.Utils.getCenter(this.bounds), this.rotationAngle);
                return q
            },
            updateCanvasElements: function() {
                if (this.updateScrollerContent) {
                    this.updateScrollerContent = false;
                    if (this.scroller) {
                        this.scroller.updateContent()
                    }
                }
                var z = this.graphicsContainer.content = [];
                var M = this.getEffectiveStroke();
                var G = this.getEffectiveStrokeThickness();
                var T = this.getEffectiveStrokeDashStyle();
                var W = this.getEffectiveBrush();
                var s = {
                    brush: W,
                    phase: n.BeforeFill
                };
                this.applyEffects(z, s);
                if (s.brush) {
                    W = s.brush
                }
                this.graphicsContainer.rotationAngle = this.rotationAngle;
                this.graphicsContainer.pivot = this.bounds.center();
                var O = this.bounds.clone();
                var p = O;
                if (this.shape == b.SimpleShape.RoundedRectangle) {
                    var C = a.getMillimeter(this.parent.measureUnit);
                    var X = C * 2.5;
                    p = new f();
                    p.addRoundRect(O, X);
                    p.done()
                }
                var L = p.clone();
                L.pen = null;
                L.brush = W;
                L.shadow = this.createShadow();
                z.push(L);
                O = O.clone();
                O.height = this.captionHeight;
                if (this.captionBackBrush) {
                    var Y = O.clone();
                    Y.brush = this.captionBackBrush;
                    Y.pen = null;
                    if (this.shape == b.SimpleShape.RoundedRectangle) {
                        var A = new MindFusion.Drawing.Container();
                        A.clip = p;
                        A.content.push(Y);
                        z.push(A)
                    } else {
                        z.push(Y)
                    }
                }
                this.applyEffects(z, {
                    phase: n.AfterFill
                });
                this.text.setBounds(O, 0);
                this.text.font = this.captionFont ? this.captionFont : this.getEffectiveFont();
                this.text.pen = this.getEffectiveTextColor();
                this.text.stroke = this.getEffectiveTextStroke();
                this.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                this.text.ignoreTransform = this.rotationAngle != 0;
                z.push(this.text);
                var I = new MindFusion.Drawing.Container();
                I.clip = p;
                z.push(I);
                var aa = this.cells.rows;
                var F = this.cells.columns;
                var Q = O.bottom();
                var D = false;
                var U = this.getEnableStyledText();
                this.calcAutoWidths();
                for (var V = this.currentScrollRow; V < aa; V++) {
                    var t = this.getRow(V).height;
                    var J = V == aa - 1 || Q + t > this.bounds.bottom();
                    var R = O.x;
                    for (var ac = 0; ac < F; ac++) {
                        var E = ac == F - 1;
                        var N = this.getCell(ac, V);
                        var K = this.getColumn(ac).width;
                        if (K <= 0) {
                            continue
                        }
                        var S = N.columnSpan > 1 || N.rowSpan > 1;
                        if (S && !D) {
                            this.markCoveredCells();
                            D = true
                        }
                        if (E) {
                            K += O.right() - (R + K)
                        }
                        var P = new c(R, Q, K, t);
                        if (S) {
                            var w = this.getSpanningCellSize(ac, V);
                            P.width = w.width;
                            P.height = w.height
                        }
                        R += K;
                        var ab = !(D && N.covered);
                        if (ab) {
                            if (N.brush) {
                                var H = P.clone();
                                H.pen = null;
                                H.brush = N.brush;
                                I.content.push(H)
                            }
                            var u = N.image;
                            if (u) {
                                var Z = P.clone();
                                if (N.imagePadding) {
                                    N.imagePadding.applyTo(Z)
                                }
                                u.setBounds(Z, 0);
                                u.imageAlign = N.getImageAlign();
                                I.content.push(u)
                            }
                            if (N.text) {
                                N.text.setBounds(P);
                                N.text.font = N.font ? N.font : this.getEffectiveFont();
                                N.text.fitInBounds = true;
                                N.text.pen = N.textColor ? N.textColor : this.getEffectiveTextColor();
                                N.text.stroke = this.getEffectiveTextStroke();
                                N.text.strokeThickness = this.getEffectiveTextStrokeThickness();
                                N.text.ignoreTransform = this.rotationAngle != 0;
                                N.text.enableStyledText = U;
                                N.text.clipToBounds = U;
                                I.content.push(N.text)
                            }
                            if (this.cellFrameStyle == b.CellFrameStyle.Simple) {
                                if (!E) {
                                    var q = new g(P.right(), P.y, P.right(), P.bottom());
                                    q.setPen(M);
                                    q.strokeDashStyle = T;
                                    I.content.push(q)
                                }
                                var ad = new g(P.x, P.bottom(), P.right(), P.bottom());
                                ad.setPen(M);
                                ad.strokeDashStyle = T;
                                I.content.push(ad)
                            }
                            if (this.cellFrameStyle == b.CellFrameStyle.System3D) {
                                var B = new j(P);
                                I.content.push(B)
                            }
                        }
                        if (R > O.right()) {
                            break
                        }
                    }
                    Q += t;
                    if (Q > this.bounds.bottom()) {
                        break
                    }
                }
                p.pen = M;
                p.strokeThickness = G;
                p.strokeDashStyle = T;
                p.brush = null;
                z.push(p);
                O = this.bounds;
                if (this.captionHeight > 0 && this.captionHeight < O.height) {
                    var Q = O.y + this.captionHeight;
                    var v = new g(O.x, Q, O.right(), Q);
                    v.setPen(M);
                    v.strokeThickness = G;
                    v.strokeDashStyle = T;
                    if (this.shape == b.SimpleShape.RoundedRectangle && (Q < X || Q > O.height - X)) {
                        v.clipPath = p
                    }
                    z.push(v)
                }
                this.addManipulatorVisuals(z);
                if (this.onUpdateVisuals) {
                    this.onUpdateVisuals(this)
                }
            },
            setShape: function(p) {
                if (this.shape != p) {
                    this.shape = p;
                    this.invalidate()
                }
            },
            getShape: function() {
                if (this.shape === undefined) {
                    return b.SimpleShape.Rectangle
                }
                return this.shape
            },
            setCaptionHeight: function(p) {
                if (this.captionHeight != p) {
                    this.captionHeight = p;
                    this.invalidate()
                }
            },
            getCaptionHeight: function() {
                return this.captionHeight
            },
            setCellFrameStyle: function(p) {
                if (this.cellFrameStyle != p) {
                    this.cellFrameStyle = p;
                    this.invalidate()
                }
            },
            getCellFrameStyle: function() {
                return this.cellFrameStyle
            },
            setConnectionStyle: function(p) {
                if (this.connectionStyle != p) {
                    this.connectionStyle = p;
                    this.invalidate()
                }
            },
            getConnectionStyle: function() {
                return this.connectionStyle
            },
            redimTable: function(p, q) {
                if (q < this.rows.length) {
                    this.deleteRowLinks(q, this.rows.length - 1)
                }
                this.cells.resize(p, q);
                this.rows.length = q;
                this.columns.length = p;
                this.updateScrollerContent = true;
                this.invalidate()
            },
            getRowCount: function() {
                return this.cells.rows
            },
            setRowCount: function(p) {
                if (p < 0) {
                    return
                }
                if (this.cells.rows == p) {
                    return
                }
                var q = this.cells.columns;
                this.redimTable(q, p)
            },
            getColumnCount: function() {
                return this.cells.columns
            },
            setColumnCount: function(p) {
                if (p < 0) {
                    return
                }
                if (this.cells.columns == p) {
                    return
                }
                var q = this.cells.rows;
                this.redimTable(p, q)
            },
            deleteColumn: function(p) {
                this.cells.deleteColumn(p);
                this.columns.splice(p, 1);
                this.invalidate()
            },
            insertColumn: function(p) {
                var q = this.createColumn();
                this.cells.insertColumn(p);
                this.columns.splice(p, 0, q);
                this.invalidate();
                return q
            },
            deleteRow: function(p) {
                if (p >= this.rows.length) {
                    return
                }
                this.deleteRowLinks(p, p);
                this.cells.deleteRow(p);
                this.rows.splice(p, 1);
                this.updateLinksIndices(p);
                this.updateLinksPos(p);
                this.invalidate()
            },
            insertRow: function(q) {
                var p = this.createRow();
                this.cells.insertRow(q);
                this.rows.splice(q, 0, p);
                this.updateLinksIndices(q);
                this.updateLinksPos(q);
                this.updateScrollerContent = true;
                this.invalidate();
                return p
            },
            addColumn: function() {
                return this.insertColumn(this.cells.columns)
            },
            addRow: function() {
                return this.insertRow(this.cells.rows)
            },
            deleteRowLinks: function(v, u) {
                if (this.parent) {
                    var p = [];
                    for (var s = v; s <= u; s++) {
                        var t = this.rows[s];
                        if (!t) {
                            continue
                        }
                        this.copyLinks(t.incomingLinks, p);
                        this.copyLinks(t.outgoingLinks, p)
                    }
                    var q = this.parent;
                    o.forEach(p, function(r) {
                        q.removeItem(r)
                    })
                }
            },
            getScrollable: function() {
                return this.scroller ? true : false
            },
            setScrollable: function(q) {
                var p = this.getScrollable();
                if (p == q) {
                    return
                }
                if (q) {
                    this.scroller = this.useScrollBars ? new b.ScrollBar(this) : new b.Scroller(this);
                    this.addManipulator(this.scroller)
                } else {
                    this.removeManipulator(this.scroller);
                    delete this.scroller
                }
                this.invalidate()
            },
            canScrollUp: function() {
                return this.currentScrollRow > 0
            },
            canScrollDown: function() {
                return this.currentScrollRow < this.cells.rows - 1
            },
            onUpdateBounds: function() {
                mflayer.callBaseMethod(d, this, "onUpdateBounds", []);
                if (this.scroller) {
                    this.scroller.updateContent()
                }
            },
            createConnectionPoint: function(s, p, q, r) {
                var u = r ? undefined : this.rowFromPoint(p);
                var t = new b.TableConnectionPoint(this, s, q, u);
                if (t.anchorPointDetails.row) {
                    t.saveEndRelative()
                } else {
                    t.anchorPointDetails.anchorPattern = this.anchorPattern;
                    t.anchorPointDetails.point = p
                }
                return t
            },
            addRowIncomingLink: function(s, r) {
                var q = this.getRow(s);
                if (!q) {
                    return
                }
                var p = q.incomingLinks;
                if (!o.contains(p, r)) {
                    p.push(r)
                }
            },
            addRowOutgoingLink: function(s, r) {
                var q = this.getRow(s);
                if (!q) {
                    return
                }
                var p = q.outgoingLinks;
                if (!o.contains(p, r)) {
                    p.push(r)
                }
            },
            removeRowIncomingLink: function(s, r) {
                var q = this.getRow(s);
                if (!q) {
                    return
                }
                var p = q.incomingLinks;
                o.remove(p, r)
            },
            removeRowOutgoingLink: function(s, r) {
                var q = this.getRow(s);
                if (!q) {
                    return
                }
                var p = q.outgoingLinks;
                o.remove(p, r)
            },
            copyLinks: function(q, p) {
                o.forEach(q, function(r) {
                    if (!o.contains(p, r)) {
                        p.push(r)
                    }
                })
            },
            getAllIncomingLinks: function(p) {
                mflayer.callBaseMethod(d, this, "getAllIncomingLinks", [p]);
                for (var q = 0; q < this.rows.length; q++) {
                    var r = this.getRow(q);
                    this.copyLinks(r.incomingLinks, p)
                }
            },
            getAllOutgoingLinks: function(p) {
                mflayer.callBaseMethod(d, this, "getAllOutgoingLinks", [p]);
                for (var q = 0; q < this.rows.length; q++) {
                    var r = this.getRow(q);
                    this.copyLinks(r.outgoingLinks, p)
                }
            },
            getRowRect: function(s) {
                var r = this.bounds.clone();
                if (s < this.currentScrollRow) {
                    r.height = this.captionHeight;
                    return r
                }
                var p = this.bounds.y;
                p += this.captionHeight;
                for (var q = this.currentScrollRow; q < s; q++) {
                    p += this.getRow(q).height
                }
                return new c(r.x, p, r.width, this.getRow(s).height)
            },
            rowFromPoint: function(p) {
                var s = p.y - this.bounds.y;
                if (this.bounds.height < s || this.rows.length == 0) {
                    return -1
                }
                var r = this.captionHeight;
                if (s < this.captionHeight) {
                    return this.currentScrollRow
                }
                for (var q = this.currentScrollRow; q < this.rows.length; ++q) {
                    r += this.getRow(q).height;
                    if (s < r) {
                        return q
                    }
                }
                return this.rows.length - 1
            },
            getRowIntersection: function(r, t, p) {
                var s = this.getRowRect(r).center();
                var q = new l((p.x + t.x) / 2, (p.y + t.y) / 2);
                s.x = s.x < q.x ? this.bounds.right() : this.bounds.left();
                return s
            },
            updateLinksPos: function(s) {
                for (var p = s; p < this.rows.length; ++p) {
                    var q = this.getRow(p);
                    o.forEach(q.incomingLinks, function(r) {
                        r.updatePosFromOrgAndDest();
                        if (r.autoRoute) {
                            r.route()
                        }
                    });
                    o.forEach(q.outgoingLinks, function(r) {
                        r.updatePosFromOrgAndDest();
                        if (r.autoRoute) {
                            r.route()
                        }
                    })
                }
            },
            updateLinksIndices: function(s) {
                for (var p = s; p < this.rows.length; ++p) {
                    var q = this.getRow(p);
                    o.forEach(q.incomingLinks, function(r) {
                        r.destinationConnection.row = p
                    });
                    o.forEach(q.outgoingLinks, function(r) {
                        r.originConnection.row = p
                    })
                }
            },
            getCurrentScrollRow: function() {
                return this.currentScrollRow
            },
            setCurrentScrollRow: function(p) {
                if (p < 0) {
                    return
                }
                if (p >= this.rows.length) {
                    return
                }
                this.currentScrollRow = p;
                if (this.scroller) {
                    this.scroller.updateContent()
                }
                this.updateLinksPos(0);
                this.updateScrollerContent = true;
                this.invalidate()
            },
            setCurrScrollRow: function(p) {
                this.setCurrentScrollRow(p)
            },
            scrollDown: function() {
                this.setCurrentScrollRow(this.currentScrollRow + 1);
                this.invalidate()
            },
            scrollUp: function() {
                this.setCurrentScrollRow(this.currentScrollRow - 1);
                this.invalidate(this)
            },
            calcAutoWidths: function() {
                var q = 0;
                var p = 0;
                for (var u = 0; u < this.columns.length; u++) {
                    var s = this.getColumn(u);
                    var r = s.columnStyle;
                    if (r == b.ColumnStyle.AutoWidth) {
                        q++
                    } else {
                        p += s.width
                    }
                }
                if (q == 0) {
                    return
                }
                var t = (this.bounds.width - p) / q;
                for (var u = 0; u < this.columns.length; u++) {
                    var s = this.getColumn(u);
                    if (s.columnStyle == b.ColumnStyle.AutoWidth) {
                        s.width = t
                    }
                }
            },
            markCoveredCells: function() {
                var w = this.cells.columns;
                var B = this.cells.rows;
                for (var p = B - 1; p >= 0; p--) {
                    for (var u = w - 1; u >= 0; u--) {
                        var A = this.getCell(u, p);
                        var t = A.columnSpan;
                        if (!t) {
                            t = 1
                        }
                        var v = A.rowSpan;
                        if (!v) {
                            v = 1
                        }
                        A.covered = false;
                        if (t <= 1 && v <= 1) {
                            continue
                        }
                        for (var s = p; s < p + v; s++) {
                            for (var q = u; q < u + t; q++) {
                                if (p == s && u == q) {
                                    continue
                                }
                                var z = this.getCell(q, s);
                                z.covered = true
                            }
                        }
                    }
                }
            },
            getSpanningCellSize: function(s, B) {
                var w = this.getCell(s, B);
                var A = w.columnSpan;
                if (!A) {
                    A = 1
                }
                var q = 0;
                for (var t = s; t < s + A; t++) {
                    q += this.getColumn(t).width
                }
                if (t == this.cells.columns) {
                    var v = 0;
                    for (var t = 0; t < this.cells.columns; t++) {
                        v += this.getColumn(t).width
                    }
                    q += this.bounds.width - v
                }
                var u = w.rowSpan;
                if (!u) {
                    u = 1
                }
                var z = 0;
                for (var p = B; p < B + u; p++) {
                    z += this.getRow(p).height
                }
                return {
                    width: q,
                    height: z
                }
            },
            cellFromPoint: function(E) {
                E = this.removeRotation(E);
                var B = this.bounds.clone();
                B.height = this.captionHeight;
                var I = this.cells.rows;
                var A = this.cells.columns;
                var z = B.bottom();
                var v = false;
                this.calcAutoWidths();
                for (var q = this.currentScrollRow; q < I; q++) {
                    var s = this.getRow(q).height;
                    var H = q == I - 1 || z + s > this.bounds.bottom();
                    var C = B.x;
                    for (var w = 0; w < A; w++) {
                        var G = w == A - 1;
                        var F = this.getCell(w, q);
                        var u = this.getColumn(w).width;
                        if (u <= 0) {
                            continue
                        }
                        var p = F.columnSpan > 1 || F.rowSpan > 1;
                        if (p && !v) {
                            this.markCoveredCells();
                            v = true
                        }
                        if (G) {
                            u += B.right() - (C + u)
                        }
                        var D = new c(C, z, u, s);
                        if (p) {
                            var t = this.getSpanningCellSize(w, q);
                            D.width = t.width;
                            D.height = t.height
                        }
                        C += u;
                        if (D.containsPoint(E)) {
                            return {
                                cell: F,
                                cellRect: D,
                                column: w,
                                row: q
                            }
                        }
                        if (C > B.right()) {
                            break
                        }
                    }
                    z += s;
                    if (z > this.bounds.bottom()) {
                        break
                    }
                }
                return null
            },
            cellFromElement: function(s) {
                var q = this.bounds.clone();
                q.height = this.captionHeight;
                var z = this.cells.rows;
                var B = this.cells.columns;
                var w = q.bottom();
                var D = false;
                this.calcAutoWidths();
                for (var C = 0; C < z; C++) {
                    var t = this.getRow(C).height;
                    var G = C == z - 1 || w + t > this.bounds.bottom();
                    var A = q.x;
                    for (var I = 0; I < B; I++) {
                        var v = I == B - 1;
                        var p = this.getCell(I, C);
                        var J = this.getColumn(I).width;
                        if (J <= 0) {
                            continue
                        }
                        var H = p.columnSpan > 1 || p.rowSpan > 1;
                        if (H && !D) {
                            this.markCoveredCells();
                            D = true
                        }
                        if (v) {
                            J += q.right() - (A + J)
                        }
                        var E = new c(A, w, J, t);
                        if (H) {
                            var u = this.getSpanningCellSize(I, C);
                            E.width = u.width;
                            E.height = u.height
                        }
                        A += J;
                        if (p === s) {
                            var F = q.bottom() + t * (C - this.currentScrollRow);
                            if (C < this.currentScrollRow || F >= this.bounds.bottom()) {
                                return {
                                    cell: p,
                                    cellRect: q,
                                    column: -1,
                                    row: -1
                                }
                            } else {
                                E.y = F;
                                return {
                                    cell: p,
                                    cellRect: E,
                                    column: I,
                                    row: C
                                }
                            }
                        }
                        if (A > q.right()) {
                            break
                        }
                    }
                    w += t
                }
                return null
            },
            getObjectToEdit: function(p, r) {
                if (r && (mflayer.isInstanceOfType(b.Cell, r))) {
                    var q = this.cellFromElement(r);
                    if (q) {
                        return new b.CellEditor(this, q)
                    }
                    return this
                }
                var q = this.cellFromPoint(p);
                if (q) {
                    return new b.CellEditor(this, q)
                }
                return this
            },
            getEditRect: function(p) {
                var r = this.bounds.clone();
                r.height = this.captionHeight;
                if (this.rotationAngle == 0) {
                    return r
                } else {
                    var q = this.rotateRect(this.bounds.clone());
                    return q.transformRect(r)
                }
            },
            setCaptionBackBrush: function(p) {
                if (this.captionBackBrush !== p) {
                    this.captionBackBrush = p;
                    this.invalidate()
                }
            },
            getCaptionBackBrush: function() {
                return this.captionBackBrush
            },
            setCaptionFont: function(p) {
                if (this.captionFont !== p) {
                    this.captionFont = p;
                    this.invalidate()
                }
            },
            getCaptionFont: function() {
                return this.captionFont
            },
            setEnableStyledText: function(p) {
                if (this.text.enableStyledText != p) {
                    this.text.enableStyledText = p;
                    this.invalidate()
                }
            },
            getEnableStyledText: function() {
                return this.text.enableStyledText
            },
            resolveInheritedStyle: function(q, r) {
                var p = r.styles["std:TableNode"];
                if (p) {
                    if (q.apply(p)) {
                        return p
                    }
                }
                return mflayer.callBaseMethod(d, this, "resolveInheritedStyle", [q, r])
            },
            getColumnRect: function(q) {
                var s = this.bounds.clone();
                if (q >= this.columns.length) {
                    return s
                }
                var p = s.left();
                for (var r = 0; r < q; ++r) {
                    var t = this.getColumn(r);
                    p += t.width
                }
                s.x = p;
                s.width = this.getColumn(q).width;
                return s
            },
            hitTestManipulators: function(A) {
                var w = mflayer.callBaseMethod(d, this, "hitTestManipulators", [A]);
                if (w != null) {
                    return w
                }
                var p = b.Utils.normalizeRect(this.bounds);
                var q = a.getMillimeter(this.parent.measureUnit) * (this.cellFrameStyle == b.CellFrameStyle.System3D ? 2 : 1);
                if (this.getRotationAngle() != 0) {
                    A = b.Utils.rotatePointAt(A, this.bounds.center(), -this.getRotationAngle())
                }
                if (this.allowResizeColumns) {
                    for (var s = 0; s < this.cells.columns - 1; s++) {
                        var t = this.getColumnRect(s);
                        if (t.left() >= p.right()) {
                            break
                        }
                        var z = t.clone();
                        z.width = q;
                        z.x = t.right() - z.width / 2;
                        z.y += this.getCaptionHeight();
                        var u = 0;
                        for (var r = this.rows.length - 1; r >= 0; r--) {
                            u = this.getRowRect(r).bottom();
                            if (u != 0) {
                                break
                            }
                        }
                        if (u != 0) {
                            z.height = Math.min(t.bottom(), u) - z.y
                        }
                        if (z.containsPoint(A)) {
                            return new b.ColumnResizer(this, s)
                        }
                    }
                }
                if (this.allowResizeRows) {
                    for (var s = this.currentScrollRow; s < this.cells.rows; s++) {
                        var v = this.getRowRect(s);
                        if (v.top() >= p.bottom()) {
                            break
                        }
                        var z = v.clone();
                        z.height = q;
                        z.y = v.bottom() - z.height / 2;
                        if (z.containsPoint(A)) {
                            return new b.RowResizer(this, s)
                        }
                    }
                }
                return null
            },
            getAllowResizeColumns: function() {
                return this.allowResizeColumns
            },
            setAllowResizeColumns: function(p) {
                if (p != this.allowResizeColumns) {
                    this.allowResizeColumns = p
                }
            },
            getAllowResizeRows: function() {
                return this.allowResizeRows
            },
            setAllowResizeRows: function(p) {
                if (p != this.allowResizeRows) {
                    this.allowResizeRows = p
                }
            },
            saveState: function() {
                var p = mflayer.callBaseMethod(d, this, "saveState", []);
                p.captionHeight = this.captionHeight;
                p.currentScrollRow = this.currentScrollRow;
                p.connectionStyle = this.connectionStyle;
                p.captionBackBrush = this.captionBackBrush;
                p.captionFont = this.captionFont;
                p.scrollable = this.getScrollable();
                p.allowResizeColumns = this.allowResizeColumns;
                p.allowResizeRows = this.allowResizeRows;
                p.cells = this.cells.clone();
                return p
            },
            restoreState: function(p) {
                mflayer.callBaseMethod(d, this, "restoreState", [p]);
                this.captionHeight = p.captionHeight;
                this.currentScrollRow = p.currentScrollRow;
                this.connectionStyle = p.connectionStyle;
                this.captionBackBrush = p.captionBackBrush;
                this.captionFont = p.captionFont;
                this.setScrollable(p.scrollable);
                this.setAllowResizeColumns(p.allowResizeColumns);
                this.setAllowResizeRows(p.allowResizeRows);
                this.cells = p.cells
            },
            useScrollBars: false,
            init: function() {
                if (!b.TableNodeBuilder) {
                    b.TableNodeBuilder = new MindFusion.Builder(d.prototype, null, this)
                } else {
                    b.TableNodeBuilder.setInstance(this)
                }
                return b.TableNodeBuilder
            },
            resizeToFitText: function(p, I) {
                if (this.cells.columns === 0 || this.cells.rows === 0) {
                    return
                }
                var v;
                var z = this.getEffectiveFont();
                var D;
                var C;
                var q = [];
                for (var r = 0; r < this.cells.columns; ++r) {
                    q.push([]);
                    for (var u = 0; u < this.cells.rows; ++u) {
                        v = this.getCell(r, u).getText();
                        C = new c(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
                        var s = this.parent.measureString(v, z, C, D);
                        if (this.getCell(r, u).getColumnSpan() == 1) {
                            if (s.width != 0) {
                                this.getCell(r, u).text.padding.addToRect(s);
                                s.width += this.getCell(r, u).text.padding.right + 1
                            }
                            q[r].push(new e(s.width, s.height))
                        }
                    }
                }
                var G = 0;
                var E = [];
                for (var r = 0; r < this.columns.length; ++r) {
                    var F = 0;
                    for (var u = 0; u < this.rows.length; ++u) {
                        if (q[r][u]) {
                            if (F < q[r][u].width) {
                                F = q[r][u].width
                            }
                        }
                    }
                    E.push(F);
                    this.getColumn(r).width = F;
                    G += F
                }
                for (var r = 0; r < this.columns.length; ++r) {
                    for (var u = 0; u < this.rows.length; ++u) {
                        if (this.getCell(r, u).getColumnSpan() > 1) {
                            var t = 0;
                            var B = this.getCell(r, u).getColumnSpan();
                            for (var H = r; H <= r + B - 1; H++) {
                                t += E[H];
                                this.getCell(H, u).text.padding
                            }
                            v = this.getCell(r, u).getText();
                            var s = this.parent.measureString(v, z, undefined, D);
                            this.getCell(r, u).text.padding.addToRect(s);
                            if (t < s.width) {
                                var w = E[r + B - 1];
                                G -= w;
                                E[r + B - 1] = s.width - (t - w) + this.getCell(r, u).text.padding.left + this.getCell(r, u).text.padding.right + 1;
                                G += E[r + B - 1];
                                this.getColumn(r + B - 1).width = E[r + B - 1]
                            }
                        }
                    }
                }
                var J = 0;
                for (var u = 0; u < this.rows.length; ++u) {
                    var A = 0;
                    for (var r = 0; r < this.cells.columns; ++r) {
                        if (A < this.rows[0].height) {
                            A = this.rows[0].height
                        }
                    }
                    this.rows.height = A;
                    J += A
                }
                if (!p) {}
                J += this.getCaptionHeight();
                this.bounds = new c(this.bounds.x, this.bounds.y, G, J);
                if (this.scroller) {
                    this.scroller.updateContent()
                }
                this.updateCanvasElements()
            }
        };
        d.With = function(p) {
            if (!b.TableNodeBuilder) {
                b.TableNodeBuilder = new MindFusion.Builder(d.prototype, p)
            } else {
                b.TableNodeBuilder.setInstance(null)
            }
            return b.TableNodeBuilder
        };
        b.TableNodeBuilder = null;
        MindFusion.registerClass(d, "MindFusion.Diagramming.TableNode", b.DiagramNode)
    })(MindFusion.Diagramming);
    (function(a) {
        var d = MindFusion.Collections.Dictionary;
        var b = a.Theme = function() {
            mflayer.initializeBase(b, this);
            this.styles = {}
        };
        b.prototype = {
            fromJson: function(h) {
                if (h.linkStyle) {
                    var k = new a.Style(h.linkStyle);
                    this.styles["std:DiagramLink"] = k
                }
                if (h.nodeStyle) {
                    var f = new a.Style(h.nodeStyle);
                    this.styles["std:DiagramNode"] = f
                }
                if (h.containerStyle) {
                    var n = new a.Style(h.containerStyle);
                    this.styles["std:ContainerNode"] = n
                }
                if (h.shapeStyle) {
                    var l = new a.Style(h.shapeStyle);
                    this.styles["std:ShapeNode"] = l
                }
                if (h.tableStyle) {
                    var e = new a.Style(h.tableStyle);
                    this.styles["std:TableNode"] = e
                }
                if (h.freeformStyle) {
                    var j = new a.Style(h.freeformStyle);
                    this.styles["std:FreeFormNode"] = j
                }
                if (h.diagramStyle) {
                    var g = new a.Style(h.diagramStyle);
                    this.styles["std:Diagram"] = g
                }
            },
            toJson: function() {
                return {
                    linkStyle: this.styles["std:DiagramLink"] ? this.styles["std:DiagramLink"].toJson() : null,
                    nodeStyle: this.styles["std:DiagramNode"] ? this.styles["std:DiagramNode"].toJson() : null,
                    containerStyle: this.styles["std:ContainerNode"] ? this.styles["std:ContainerNode"].toJson() : null,
                    shapeStyle: this.styles["std:ShapeNode"] ? this.styles["std:ShapeNode"].toJson() : null,
                    tableStyle: this.styles["std:TableNode"] ? this.styles["std:TableNode"].toJson() : null,
                    freeformStyle: this.styles["std:FreeFormNode"] ? this.styles["std:FreeFormNode"].toJson() : null,
                    diagramStyle: this.styles["std:Diagram"] ? this.styles["std:Diagram"].toJson() : null
                }
            },
            saveToXml: function(g, f) {
                for (var h in this.styles) {
                    if (this.styles.hasOwnProperty(h)) {
                        var e = f.addChildElement("Style", g);
                        e.setAttribute("TargetType", h);
                        f.writeStyleContent(e, this.styles[h], h + "Style")
                    }
                }
            },
            loadFromXml: function(h, g) {
                this.styles = {};
                for (var f = 0; f < h.childNodes.length; f++) {
                    var e = h.childNodes[f];
                    if (e.nodeType !== 1) {
                        continue
                    }
                    var k = e.getAttribute("TargetType");
                    var j = g.readStyleContent(e);
                    this.styles[k] = j
                }
            }
        };
        (function c() {
            b.Default = new b();
            var h = b.Default.styles;
            var o = "white";
            var q = "black";
            var f = "rgb(220, 220, 255)";
            var g = "rgb(180, 160, 160)";
            var e = "rgb(170, 170, 200)";
            var k = new a.Style();
            k.setBrush(o);
            k.setStroke(q);
            k.setStrokeThickness(0);
            k.setTextColor(q);
            k.setFontName("sans-serif");
            k.setFontSize(4);
            k.setShadowColor("gray");
            var j = new a.Style(k);
            h["std:DiagramLink"] = j;
            var s = new a.Style(k);
            h["std:DiagramNode"] = s;
            var r = new a.Style(k);
            h["std:ContainerNode"] = r;
            var n = new a.Style(k);
            n.setBrush(f);
            h["std:ShapeNode"] = n;
            var l = new a.Style(k);
            l.setBrush(f);
            h["std:FreeFormNode"] = l;
            var p = new a.Style(k);
            p.setBrush(g);
            h["std:TableNode"] = p;
            var t = new a.Style(k);
            t.setBackBrush(e);
            h["std:Diagram"] = t
        })();
        MindFusion.registerClass(b, "MindFusion.Diagramming.Theme")
    })(MindFusion.Diagramming);
    (function(b) {
        var g = MindFusion.Drawing.Point;
        var c = MindFusion.Drawing.Rect;
        var a = MindFusion.Drawing.GraphicsUnit;
        var f = MindFusion.Drawing.Font;
        var l = MindFusion.Drawing.Thickness;
        var d = MindFusion.Drawing.Size;
        var h = MindFusion.Collections.Dictionary;
        var j = b.XmlPersistContext = function(o, n) {
            this.diagram = o;
            this.document = n;
            this.items = [];
            this.brushes = [];
            this.images = [];
            this.styles = [];
            this.svgs = [];
            this.effects = [];
            this.brushesMap = new h();
            this.imagesMap = new h();
            this.stylesMap = new h();
            this.svgsMap = new h();
            this.effectsMap = new h()
        };
        j.prototype = {
            saveItemToXml: function(q, r, o) {
                var p = this.document.createElement(o);
                r.appendChild(p);
                var n = q.constructor.xmlInfo;
                if (n != null) {
                    p.setAttribute("Class", n.classId);
                    p.setAttribute("Id", q.instanceId.toString());
                    p.setAttribute("Version", n.classVersion.toString());
                    q.saveToXml(p, this)
                } else {
                    throw new Error("Item cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            saveHeaderToXml: function(r, q, o) {
                var p = this.document.createElement(o);
                q.appendChild(p);
                var n = r.constructor.xmlInfo;
                if (n != null) {
                    p.setAttribute("Class", n.classId);
                    p.setAttribute("Version", n.classVersion.toString());
                    r.saveToXml(p, this)
                } else {
                    throw new Error("Header cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            addChildElement: function(n, o, q) {
                var p = this.document.createElement(n);
                o.appendChild(p);
                if (k(q)) {
                    p.appendChild(this.document.createTextNode(q))
                }
                return p
            },
            instantiateItem: function(s, p) {
                var q = b.Diagram.xmlClassMap[s];
                if (!q) {
                    throw new Error("Item classId [" + s + "] is not registered.")
                }
                if (mflayer.inheritsFrom(q, b.DiagramNode)) {
                    var r = new q(this.diagram)
                } else {
                    if (q == b.DiagramLink || mflayer.inheritsFrom(q, b.DiagramLink)) {
                        var u = p.getElementsByTagName("Origin")[0];
                        var t = p.getElementsByTagName("Destination")[0];
                        var n = this.items[parseInt(u.getAttribute("Id"))];
                        var o = this.items[parseInt(t.getAttribute("Id"))];
                        var r = new q(this.diagram, n, o)
                    }
                }
                r.setParent(this.diagram);
                return r
            },
            instantiateObject: function(n) {
                switch (n) {
                    case "std:Header":
                        return new b.Lanes.Header();
                    default:
                        return null
                }
            },
            instantiateEffect: function(o) {
                switch (o) {
                    case "std:GlassEffect":
                        var n = new b.GlassEffect();
                        break;
                    case "std:AeroEffect":
                        var n = new b.AeroEffect();
                        break;
                    default:
                        return null
                }
                return n
            },
            loadItemFromXml: function(o) {
                var q = o.getAttribute("Class");
                var r = parseInt(o.getAttribute("Id"));
                var n = parseInt(o.getAttribute("Version"));
                if (this.items[r] !== undefined) {
                    var p = this.items[r]
                } else {
                    var p = this.instantiateItem(q, o);
                    this.items[r] = p
                }
                this.classVersion = n;
                p.loadFromXml(o, this);
                return p
            },
            loadHeaderFromXml: function(o) {
                var q = null;
                if (!o.hasAttribute("Class")) {
                    q = new b.Lanes.Header()
                } else {
                    var p = o.getAttribute("Class");
                    var n = 1;
                    if (o.hasAttribute("Version")) {
                        varsion = parseInt(o.getAttribute("Version"))
                    }
                    q = this.instantiateObject(p);
                    this.classVersion = n
                }
                q.loadFromXml(o, this);
                return q
            },
            writeItemReference: function(r, o, p) {
                if (r == null) {
                    return null
                }
                var q = this.addChildElement(o, p);
                q.setAttribute("Id", r.instanceId.toString());
                var n = r.constructor.xmlInfo;
                q.setAttribute("ClassId", n.classId);
                q.setAttribute("Version", n.classVersion.toString());
                return q
            },
            readItemReference: function(n) {
                var q = parseInt(n.getAttribute("Id"));
                var o = this.items[q];
                if (o) {
                    return o
                }
                var p = n.getAttribute("ClassId");
                var o = this.instantiateItem(p, n);
                this.items[q] = o;
                return o
            },
            writeResources: function(n) {
                if (!this.inplaceResources) {
                    var o = this.addChildElement("Resources", n);
                    this.writeBrushes(o);
                    this.writeImages(o);
                    this.writeEffects(o);
                    this.writeStyles(o);
                    this.writeSvgs(o)
                }
            },
            readResources: function(n) {
                var o = e("Resources", n);
                if (o) {
                    this.readBrushes(o);
                    this.readImages(o);
                    this.readEffects(o);
                    this.readStyles(o);
                    this.readSvgs(o)
                }
            },
            writeResource: function(p, n, o, q, t) {
                if (p == null) {
                    return null
                }
                var s = this.addChildElement(n, o);
                if (this.inplaceResources) {
                    q.apply(this, [s, p]);
                    return s
                }
                var r = t.getCount();
                if (t.contains(p)) {
                    r = t.get(p)
                } else {
                    t.set(p, r)
                }
                s.setAttribute("Id", r.toString());
                return s
            },
            writeBrushes: function(n) {
                if (this.inplaceResources) {
                    return
                }
                var o = this.addChildElement("Brushes", n);
                this.brushesMap.forEach(function(p, r) {
                    var q = this.addChildElement("Brush", o);
                    q.setAttribute("Index", r);
                    this.writeBrushContent(q, p)
                }, this)
            },
            readBrushes: function(n) {
                var s = e("Brushes", n);
                if (!s) {
                    throw new Error("Brushes section not found.")
                }
                var t = s.getElementsByTagName("Brush");
                for (var r = 0; r < t.length; r++) {
                    var q = t[r];
                    var p = parseInt(q.getAttribute("Index"));
                    var o = this.readBrushContent(q);
                    this.brushes[p] = o
                }
            },
            writeBrush: function(p, n, o) {
                return this.writeResource(p, n, o, this.writeBrushContent, this.brushesMap)
            },
            readBrush: function(n, p, o) {
                var r = e(n, p);
                if (!r) {
                    return o
                }
                if (!r.hasAttribute("Id") || this.inplaceResources) {
                    return this.readBrushContent(r)
                }
                var q = parseInt(r.getAttribute("Id"));
                return this.brushes[q]
            },
            writeBrushContent: function(r, q) {
                if (q.type === "SolidBrush" || typeof q === "string") {
                    r.setAttribute("Type", "Solid");
                    this.writeColor(q.type === "SolidBrush" ? q.color : q, "Color", r)
                } else {
                    if (q.type === "LinearGradientBrush") {
                        r.setAttribute("Type", "Gradient");
                        this.writeFloat(q.angle, "Angle", r);
                        if (q.colorStops.length == 2) {
                            this.writeColor(q.colorStops[0].color, "Color1", r);
                            this.writeColor(q.colorStops[1].color, "Color2", r)
                        } else {
                            var n = this.addChildElement("ColorBlend", r);
                            var p = [],
                                o = [];
                            for (var s = 0; s < q.colorStops.length; s++) {
                                position[s] = q.colorStops[s].position;
                                p[s] = q.colorStops[s].color
                            }
                            this.writeFloatArray(o, "Positions", "Pos", n);
                            this.writeColorArray(p, "Colors", "Color", n)
                        }
                    }
                }
            },
            readBrushContent: function(o) {
                var t = "rgba(255, 0, 0, 0.4)";
                var u = o.getAttribute("Type");
                switch (u) {
                    case "Solid":
                        t = this.readColor("Color", o);
                        break;
                    case "Gradient":
                        t = {
                            type: "LinearGradientBrush",
                            colorStops: []
                        };
                        t.angle = this.readFloat("Angle", o);
                        var v = e("ColorBlend", o);
                        if (v) {
                            var s = this.readFloatArray("Positions", "Pos", v);
                            var n = this.readColorArray("Colors", "Color", v);
                            if (s && n) {
                                for (var r = 0; r < s.length; r++) {
                                    t.colorStops.push({
                                        position: s[r],
                                        color: n[r]
                                    })
                                }
                            }
                        } else {
                            var q = this.readColor("Color1", o);
                            var p = this.readColor("Color2", o);
                            t.colorStops.push({
                                position: 0,
                                color: q
                            });
                            t.colorStops.push({
                                position: 1,
                                color: p
                            })
                        }
                        break
                }
                return t
            },
            writeImages: function(n) {
                if (this.inplaceResources) {
                    return
                }
                var o = this.addChildElement("Images", n);
                o.setAttribute("Count", this.imagesMap.getCount());
                this.imagesMap.forEach(function(r, p) {
                    var q = this.addChildElement("Image", o, r);
                    q.setAttribute("Index", p.toString())
                }, this)
            },
            readImages: function(n) {
                var q = e("Images", n);
                if (!q) {
                    throw new Error("Images section not found.")
                }
                var r = q.getElementsByTagName("Image");
                for (var p = 0; p < r.length; p++) {
                    var t = r[p];
                    var o = parseInt(t.getAttribute("Index"));
                    var s = this.innerText(t);
                    if (s) {
                        this.images[o] = s
                    }
                }
            },
            writeImage: function(p, n, o) {
                return this.writeResource(p, n, o, this.writeImageContent, this.imagesMap)
            },
            readImage: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return null
                }
                var p = parseInt(q.getAttribute("Id"));
                return this.images[p]
            },
            writeStyles: function(n) {
                if (this.inplaceResources) {
                    return
                }
                var o = this.addChildElement("Styles", n);
                this.stylesMap.forEach(function(r, q) {
                    var p = this.addChildElement("Style", o);
                    if (q >= 0) {
                        p.setAttribute("Index", q.toString())
                    }
                    this.writeStyleContent(p, r)
                }, this)
            },
            readStyles: function(p) {
                var s = e("Styles", p);
                if (!s) {
                    return
                }
                var o = s.getElementsByTagName("Style");
                for (var r = 0; r < o.length; r++) {
                    var n = o[r];
                    var q = parseInt(n.getAttribute("Index"));
                    var t = new b.Style();
                    t.loadFromXml(n, this);
                    this.styles[q] = t
                }
            },
            writeStyle: function(p, n, o, q) {
                if (p != null) {
                    p.classId = q
                }
                return this.writeResource(p, n, o, this.writeStyleContent, this.stylesMap)
            },
            readStyle: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return undefined
                }
                var p = parseInt(q.getAttribute("Id"));
                return this.styles[p]
            },
            writeStyleContent: function(n, o, p) {
                if (!p) {
                    p = o.classId
                }
                n.setAttribute("Class", p);
                n.setAttribute("Version", "1");
                o.saveToXml(n, this)
            },
            readStyleContent: function(n) {
                var o = new b.Style();
                o.loadFromXml(n, this);
                return o
            },
            writeEffects: function(n) {
                if (this.inplaceResources) {
                    return
                }
                var o = this.addChildElement("Effects", n);
                this.effectsMap.forEach(function(r, q) {
                    var p = this.addChildElement("Effect", o);
                    if (q >= 0) {
                        p.setAttribute("Index", q.toString())
                    }
                    this.writeEffectContent(p, r)
                }, this)
            },
            readEffects: function(n) {
                var r = e("Effects", n);
                if (!r) {
                    return
                }
                var t = r.getElementsByTagName("Effect");
                for (var q = 0; q < t.length; q++) {
                    var p = t[q];
                    var o = parseInt(p.getAttribute("Index"));
                    var s = this.readEffectContent(p);
                    if (s) {
                        this.effects[o] = s
                    }
                }
            },
            writeEffect: function(p, n, o) {
                if (p == null) {
                    return this.addChildElement(n, o)
                }
                return this.writeResource(p, n, o, this.writeEffectContent, this.effectsMap)
            },
            readEffect: function(o) {
                if (!o.hasAttribute("Id") || this.inplaceResources) {
                    return this.readEffectContent(o)
                }
                var n = parseInt(o.getAttribute("Id"));
                if (this.effects.length <= n) {
                    return null
                }
                return this.effects[n]
            },
            writeEffectContent: function(o, p) {
                var n = p.constructor.xmlInfo;
                if (n) {
                    o.setAttribute("Class", n.classId);
                    o.setAttribute("Version", n.classVersion);
                    p.saveToXml(o, this)
                } else {
                    throw new Error("Effect cannot be serialized because it does not implement getXmlInfo().")
                }
            },
            readEffectContent: function(n) {
                if (!n.hasAttribute("Class")) {
                    return null
                }
                var p = n.getAttribute("Class");
                var o = this.instantiateEffect(p);
                if (!o) {
                    return null
                }
                o.loadFromXml(n, this);
                return o
            },
            readPen: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return undefined
                }
                var p = this.readBrush("Brush", q);
                if (!p) {
                    p = this.readColor("Color", q)
                }
                var s = this.readInt("DashStyle", q);
                var r = this.readFloat("Width", q);
                return {
                    brush: p,
                    dashStyle: s,
                    width: r
                }
            },
            writePen: function(q, n, o) {
                var p = this.addChildElement(n, o);
                if (q) {
                    if (typeof q == "string") {
                        this.writeBrush(q, "Color", p)
                    } else {
                        if (q.brush) {
                            this.writeBrush(q.brush, "Brush", p)
                        }
                        if (q.dashStyle) {
                            this.writeInt(q.dashStyle, "DashStyle", p)
                        }
                        if (q.width) {
                            this.writeFloat(q.width, "Width", p)
                        }
                    }
                }
                return p
            },
            writeSvgs: function(n) {
                if (this.inplaceResources) {
                    return
                }
                var o = this.addChildElement("Svgs", n);
                o.setAttribute("Count", this.svgsMap.getCount());
                this.svgsMap.forEach(function(p, q) {
                    var r = this.addChildElement("Svg", o);
                    if (q >= 0) {
                        r.setAttibute("Index", q.toString())
                    }
                    this.writeSvgContent(r, p)
                }, this)
            },
            readSvgs: function(o) {
                var s = e("Svgs", o);
                if (!s) {
                    return
                }
                var n = s.getElementsByTagName("Svg");
                for (var r = 0; r < n.length; r++) {
                    var t = n[r];
                    var q = parseInt(t.getAttribute("Index"));
                    var p = this.readSvgContent(t);
                    this.svgs[q] = p
                }
            },
            writeSvgContent: function(o, n) {
                o.appendChild(this.document.importNode(n.svgElement, true))
            },
            readSvgContent: function(n) {
                if (n.children.length == 0) {
                    return null
                }
                return n.innerHTML
            },
            readStringFormat: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return undefined
                }
                var r = this.readInt("Alignment", q);
                var p = this.readInt("LineAlignment", q);
                return {
                    alignment: r,
                    lineAlignment: p
                }
            },
            writeStringFormat: function(p, n, o) {
                var q = this.addChildElement(n, o);
                if (p) {
                    if (p.alignment) {
                        this.writeInt(p.alignment, "Alignment", q)
                    }
                    if (p.lineAlignment) {
                        this.writeInt(p.lineAlignment, "LineAlignment", q)
                    }
                }
                return q
            },
            writeString: function(o, n, p) {
                return this.addChildElement(n, p, o)
            },
            readString: function(n, p, o) {
                if (o === undefined) {
                    o = ""
                }
                var q = e(n, p);
                if (!q) {
                    return o
                }
                return this.innerText(q)
            },
            writeFloat: function(p, n, o) {
                return this.addChildElement(n, o, p.toString())
            },
            readFloat: function(n, p, o) {
                if (o === undefined) {
                    o = 0
                }
                var q = e(n, p);
                if (!q) {
                    return o
                }
                return parseFloat(this.innerText(q))
            },
            writeInt: function(p, n, o) {
                var q = p.toString();
                if (q.indexOf(".") != -1) {
                    q = Math.round(p).toString()
                }
                return this.addChildElement(n, o, q)
            },
            readInt: function(n, p, o) {
                if (o === undefined) {
                    o = 0
                }
                var q = e(n, p);
                if (!q) {
                    return o
                }
                return parseInt(this.innerText(q))
            },
            writeBool: function(p, n, o) {
                if (typeof p === "undefined" || p === null) {
                    p = false
                }
                return this.addChildElement(n, o, p.toString())
            },
            readBool: function(n, p, o) {
                if (o === undefined) {
                    o = false
                }
                var q = e(n, p);
                if (!q) {
                    return o
                }
                return this.innerText(q).toLowerCase() == "true"
            },
            writeFloatArray: function(p, n, s, o) {
                if (p == null) {
                    return null
                }
                var r = this.addChildElement(n, o);
                for (var q = 0; q < p.length; q++) {
                    this.writeFloat(p[q], s, r)
                }
                return r
            },
            readFloatArray: function(o, s, p) {
                var r = e(o, p);
                if (!r) {
                    return null
                }
                var n = r.getElementsByTagName(s);
                var t = [];
                for (var q = 0; q < n.length; q++) {
                    t[q] = parseFloat(this.innerText(n[q]))
                }
                return t
            },
            writeColorArray: function(s, n, r, o) {
                if (s == null) {
                    return null
                }
                var q = this.addChildElement(n, o);
                for (var p = 0; p < s.length; p++) {
                    this.writeColor(s[p], r, q)
                }
                return q
            },
            readColorArray: function(o, s, p) {
                var r = e(o, p);
                if (!r) {
                    return null
                }
                var n = r.getElementsByTagName(s);
                var t = [];
                for (var q = 0; q < n.length; q++) {
                    t[q] = this.readColorValue(n[q], "white")
                }
                return t
            },
            writeColor: function(p, n, o) {
                return this.addChildElement(n, o, b.Utils.colorStringToHex(p))
            },
            readColor: function(n, p, o) {
                if (o === undefined) {
                    o = "black"
                }
                var q = e(n, p);
                if (!q) {
                    return o
                }
                return this.readColorValue(q, o)
            },
            readColorValue: function(q, p) {
                var t = this.innerText(q);
                if (t.length != 9) {
                    return p
                }
                if (t[0] != "#") {
                    return p
                }
                var w = t.substring(1, 3);
                if (w == "FF") {
                    return "#" + t.substring(3)
                }
                var o = parseInt(w, 16) / 256;
                var v = parseInt(t.substring(3, 5), 16);
                var u = parseInt(t.substring(5, 7), 16);
                var n = parseInt(t.substring(7, 9), 16);
                return b.Utils.rgbToString(v, u, n, o)
            },
            writeFont: function(p, n, o) {
                var q = this.addChildElement(n, o);
                if (p) {
                    this.writeString(p.name, "Name", q);
                    this.writeFloat(p.size, "Size", q);
                    this.writeBool(p.bold, "Bold", q);
                    this.writeBool(p.italic, "Italic", q);
                    this.writeBool(p.underline, "Underline", q)
                }
                return q
            },
            readFont: function(v, t) {
                var p = e(v, t);
                if (!p) {
                    return undefined
                }
                var n = this.readString("Name", p);
                if (n == "") {
                    return undefined
                }
                var u = this.readFloat("Size", p);
                var s = this.readInt("Unit", p);
                if (s != 0) {
                    u = a.convert(u, s, this.diagram.measureUnit)
                }
                var r = this.readBool("Bold", p);
                var q = this.readBool("Italic", p);
                var o = this.readBool("Underline", p);
                return new f(n, u, r, q, o)
            },
            writeAnchorPattern: function(u, v, s) {
                if (u == null) {
                    return null
                }
                var p = this.addChildElement(v, s);
                p.setAttribute("Id", (typeof u.patternId == "string") ? u.patternId : "");
                if (!u.patternId) {
                    var o = this.addChildElement("Points", p);
                    o.setAttribute("Count", u.points.length);
                    for (var q = 0; q < u.points.length; q++) {
                        var r = u.points[q];
                        var t = this.addChildElement("AnchorPoint", o);
                        var n = r.constructor.xmlInfo;
                        if (n) {
                            t.setAttribute("Class", n.classId);
                            t.setAttribute("Version", n.classVersion)
                        }
                        r.saveToXml(t, this)
                    }
                }
            },
            readAnchorPattern: function(z, v, o) {
                var q = e(z, v);
                if (!q) {
                    return null
                }
                var t = q.getAttribute("Id");
                if (t == "" || o) {
                    var s = new b.AnchorPattern();
                    var n = e("Points", q);
                    if (!n) {
                        return null
                    }
                    var r = n.getElementsByTagName("AnchorPoint");
                    for (var p = 0; p < r.length; p++) {
                        var w = r[p];
                        var u = new b.AnchorPoint(0, 0);
                        u.allowIncoming = this.readBool("AllowIncoming", w);
                        u.allowOutgoing = this.readBool("AllowOutgoing", w);
                        u.color = this.readColor("Color", w);
                        u.col = this.readInt("Column", w);
                        u.markStyle = this.readInt("MarkStyle", w);
                        u.tag = this.readTag(u, "Tag", w);
                        u.x = this.readFloat("X", w);
                        u.y = this.readFloat("Y", w);
                        s.points.push(u)
                    }
                    return s
                } else {
                    return b.AnchorPattern.fromId(t)
                }
            },
            writeShape: function(p, n, o) {
                if (p == null) {
                    return null
                }
                var q = this.addChildElement(n, o);
                q.setAttribute("Id", p.id ? p.id : "Rectangle");
                return q
            },
            readShape: function(n, o) {
                var p = e(n, o);
                if (!p) {
                    return undefined
                }
                return p.attributes.getNamedItem("Id").value || "RoundRect"
            },
            readArrowheadV13: function(n, o) {
                var p = ["None", "Arrow", "Triangle", "Circle", "Tetragon", "Rhombus", "BowArrow", "PointerArrow", "PentagonArrow", "DoubleArrow", "Reversed", "RevTriangle", "Quill", "RevWithLine", "RevWithCirc", "BackSlash", "Slash", "DefaultFlow"];
                var q = this.readInt(n, o);
                return p[q]
            },
            innerText: function(n) {
                if (n.childNodes.length == 0) {
                    return ""
                }
                return n.childNodes[0].nodeValue
            },
            writeSizeF: function(p, n, o) {
                var q = p.width.toString() + ", " + p.height.toString();
                return this.addChildElement(n, o, q)
            },
            readSizeF: function(n, o) {
                var p = e(n, o);
                if (!p) {
                    return undefined
                }
                var r = this.innerText(p);
                var q = r.split(",");
                return new d(parseFloat(q[0]), parseFloat(q[1]))
            },
            writeRectangleF: function(p, n, o) {
                var q = "0, 0, 1, 1";
                if (p) {
                    q = p.x.toString() + ", " + p.y.toString() + ", " + p.width.toString() + ", " + p.height.toString()
                }
                return this.addChildElement(n, o, q)
            },
            readRectangleF: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return undefined
                }
                var s = this.innerText(q);
                var r = s.split(",");
                for (var p = 0; p < r.length; p++) {
                    r[p] = parseFloat(r[p])
                }
                return c.fromArgs(r)
            },
            writeThickness: function(p, n, o) {
                var q = "0, 0, 0, 0";
                if (p) {
                    q = p.left.toString() + ", " + p.top.toString() + ", " + p.right.toString() + ", " + p.bottom.toString()
                }
                return this.addChildElement(n, o, q)
            },
            readThickness: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return new l(0, 0, 0, 0)
                }
                var s = this.innerText(q);
                var r = s.split(",");
                for (var p = 0; p < r.length; p++) {
                    r[p] = parseFloat(r[p])
                }
                return new l(r[0], r[1], r[2], r[3])
            },
            writePointF: function(o, n, p) {
                var q = "0, 0";
                if (o) {
                    q = o.x.toString() + ", " + o.y.toString()
                }
                return this.addChildElement(n, p, q)
            },
            readPointValue: function(o) {
                var q = o.childNodes[0].nodeValue;
                var p = q.split(",");
                for (var n = 0; n < p.length; n++) {
                    p[n] = parseFloat(p[n])
                }
                return new g(p[0], p[1])
            },
            writePointCollection: function(r, n, o) {
                if (r == null) {
                    return null
                }
                var q = this.addChildElement(n, o);
                for (var p = 0; p < r.length; p++) {
                    this.writePointF(r[p], "Point", q)
                }
                return q
            },
            readPoints: function(n, o) {
                var r = e(n, o);
                if (!r) {
                    return []
                }
                var q = r.getElementsByTagName("Point");
                var s = [];
                for (var p = 0; p < q.length; p++) {
                    s.push(this.readPointValue(q[p]))
                }
                return s
            },
            writeTheme: function(q, n, o) {
                if (q == null) {
                    return null
                }
                var p = this.addChildElement(n, o);
                this.writeThemeContent(p, q);
                return p
            },
            writeThemeContent: function(n, o) {
                o.saveToXml(n, this)
            },
            readTheme: function(n, o) {
                var p = e(n, o);
                if (p == null) {
                    return null
                }
                return this.readThemeContent(p)
            },
            readThemeContent: function(n) {
                var o = new b.Theme();
                o.loadFromXml(n, this);
                return o
            },
            selectNode: function(n, o) {
                return e(o, n)
            },
            selectNodes: function(s, o) {
                var r = [];
                if (this.document.evaluate) {
                    var n = this.document.evaluate(s, o, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                    var q = n.iterateNext();
                    while (q) {
                        r.push(q);
                        q = n.iterateNext()
                    }
                } else {
                    for (var p = 0; p < o.childNodes.length; p++) {
                        if (o.childNodes[p].tagName == s) {
                            r.push(o.childNodes[p])
                        }
                    }
                }
                return r
            },
            writeGroup: function(s, n, p) {
                if (!s == null) {
                    return null
                }
                var q = this.addChildElement(n, p);
                this.writeItemReference(s.mainItem, "MainItem", q);

                function o(A, D, t, B) {
                    if (!A) {
                        return
                    }
                    for (var v = 0; v < A.length; v++) {
                        var C = A[v];
                        var z = D.addChildElement("Attachment", t);
                        D.writeItemReference(C, "Item", z);
                        D.writeInt(0, "Type", z);
                        D.writeInt(0, "Data", z);
                        D.writeString("0, 0, 0, 0", "Percents", z);
                        if (B) {
                            var u = D.addChildElement("Traits", z);
                            var w = D.addChildElement("Pair", u);
                            w.setAttribute("IsTraits", "1");
                            D.addChildElement("Key", w, "std:ContainmentKeys:InContainer");
                            D.addChildElement("Value", w, "True").setAttribute("Type", "2")
                        }
                    }
                }
                var r = this.addChildElement("Attachments", q);
                o(s.attachedNodes, this, r, false);
                o(s.children, this, r, true);
                this.writeBool(true, "Visible", q);
                this.writeRectangleF(s.mainItem.getBounds(), "PrevRect", q);
                return q
            },
            readGroup: function(A, v) {
                var q = e(A, v);
                if (!q) {
                    return null
                }
                var o = e("Attachments", q);
                if (!q) {
                    return null
                }
                var u = {
                    children: [],
                    attachedNodes: []
                };
                var z = q.getElementsByTagName("Attachment");
                for (var r = 0; r < z.length; r++) {
                    var s = z[r];
                    var n = e("Item", s);
                    if (n) {
                        var w = this.readItemReference(n);
                        var p = e("Traits", s);
                        var t = p ? u.children : u.attachedNodes;
                        t.push(w)
                    }
                }
                return u
            },
            writeObject: function(p, n, o, s) {
                if (p == null) {
                    return null
                }
                var r = 0;
                var q = null;
                if (typeof p === "string") {
                    if (p.length === 1) {
                        r = 4
                    } else {
                        r = 1
                    }
                    q = this.writeString(p, n, o)
                } else {
                    if (typeof p === "boolean") {
                        r = 2;
                        q = this.writeBool(p, n, o)
                    } else {
                        if (typeof p === "number") {
                            if (b.Utils.isFloat(p)) {
                                r = 6;
                                q = this.writeFloat(p, n, o)
                            } else {
                                r = 9;
                                q = this.writeInt(p, n, o)
                            }
                        }
                    }
                }
                if (q != null) {
                    q.setAttribute("Type", r)
                }
                return q
            },
            readObject: function(n, o) {
                var p = e(n, o);
                if (!p) {
                    return null
                }
                var q = parseInt(p.getAttribute("Type"));
                if (q == 1) {
                    return this.readString(n, o)
                }
                if (q == 2) {
                    return this.readBool(n, o)
                }
                if (q == 3) {
                    return this.readInt(n, o)
                }
                if (q == 4) {
                    return this.readString(n, o)
                }
                if (q == 5) {
                    return this.readInt(n, o)
                }
                if (q == 6) {
                    return this.readFloat(n, o)
                }
                if (q == 7) {
                    return this.readInt(n, o)
                }
                if (q == 8) {
                    return this.readInt(n, o)
                }
                if (q == 9) {
                    return this.readInt(n, o)
                }
                if (q == 10) {
                    return this.readInt(n, o)
                }
                if (q == 11) {
                    return this.readFloat(n, o)
                }
                if (q == 12) {
                    return this.readInt(n, o)
                }
                if (q == 13) {
                    return this.readInt(n, o)
                }
                if (q == 14) {
                    return this.readInt(n, o)
                }
                return null
            },
            writeTag: function(q, s, n, o) {
                if (s == null) {
                    return null
                }
                var p = this.addChildElement(n, o);
                var r = false;
                if (this.diagram) {
                    r = this.diagram.raiseSerializeTag({
                        item: q,
                        tag: s,
                        propertyName: n,
                        element: p,
                        context: this
                    })
                }
                if (!r) {
                    o.removeChild(p);
                    this.writeObject(s, n, o, false)
                }
                return p
            },
            readTag: function(q, n, o) {
                var p = e(n, o);
                if (!p) {
                    return null
                }
                var s = {
                    item: q,
                    tag: null,
                    propertyName: n,
                    element: p,
                    context: this
                };
                var r = this.diagram.raiseDeserializeTag(s);
                if (!r) {
                    return this.readObject(n, o)
                }
                return s.tag
            },
            readSvg: function(n, o) {
                var q = e(n, o);
                if (!q) {
                    return null
                }
                var p = parseInt(q.getAttribute("Id"));
                return this.svgs[p]
            },
            selectSingleNode: e
        };

        function e(n, o) {
            var p = o.getElementsByTagName(n);
            if (p.length < 1) {
                return null
            }
            if (p[0].parentNode != o) {
                return null
            }
            return p[0]
        }

        function k(n) {
            return (typeof n != "undefined") && n !== null
        }
        MindFusion.registerClass(j, "MindFusion.Diagramming.XmlPersistContext")
    })(MindFusion.Diagramming);
    (function(b) {
        var a = MindFusion.Collections.ArrayList;
        var c = MindFusion.Drawing.Rect;
        var f = MindFusion.Drawing.Font;
        var d = MindFusion.Drawing.Thickness;
        var e = b.Cell = function() {
            this.text = new MindFusion.Drawing.Text("", new c(0, 0, 1, 1));
            this.tooltip = "";
            this.text.lineAlignment = b.Alignment.Center
        };
        e.prototype = {
            clone: function() {
                var g = new this.constructor();
                g.parent = this.parent;
                g.text = this.text.clone();
                g.font = this.font;
                g.brush = this.brush;
                g.textColor = this.textColor;
                g.rowSpan = this.rowSpan;
                g.columnSpan = this.columnSpan;
                g.tooltip = this.tooltip;
                g.imageLocation = this.imageLocation;
                g.setImageContent(this.imageContent);
                g.imageAlign = this.imageAlign;
                if (this.image) {
                    g.setImage(this.getImage())
                }
                g.imagePadding = this.imagePadding;
                g.setTag(this.getTag());
                return g
            },
            toJson: function() {
                var g = {
                    text: this.getText(),
                    textAlignment: this.getTextAlignment(),
                    lineAlignment: this.getLineAlignment(),
                    imageLocation: this.getImageLocation(),
                    imageAlign: this.getImageAlign(),
                    imagePadding: this.imagePadding,
                    brush: this.brush,
                    textColor: this.textColor,
                    rowSpan: this.rowSpan,
                    columnSpan: this.columnSpan,
                    tooltip: this.tooltip,
                    font: this.font,
                    tag: this.tag || null
                };
                if (this.imageContent) {
                    if (this.parent.parent.saveImage) {
                        g.imageIndex = this.parent.parent.saveImage(this.imageContent)
                    } else {
                        g.imageData = this.imageContent
                    }
                }
                return g
            },
            fromJson: function(g) {
                this.setText(g.text);
                this.setTextAlignment(g.textAlignment);
                this.setLineAlignment(g.lineAlignment);
                this.setImageLocation(g.imageLocation);
                this.setImageAlign(g.imageAlign);
                if (g.imagePadding) {
                    this.setImagePadding(d.copy(g.imagePadding))
                }
                this.brush = g.brush;
                this.textColor = g.textColor;
                this.rowSpan = g.rowSpan;
                this.columnSpan = g.columnSpan;
                this.tooltip = g.tooltip;
                if (g.font) {
                    this.font = f.copy(g.font)
                }
                if (g.imageIndex != undefined) {
                    this.setImageContent(this.parent.parent.images[g.imageIndex])
                }
                if (g.imageData != undefined) {
                    this.setImageContent(g.imageData)
                }
                this.setTag(g.tag)
            },
            loadFromXml: function(j, h) {
                this.font = h.readFont("Font", j);
                this.textColor = h.readBrush("TextBrush", j);
                this.setText(h.readString("Text", j));
                this.columnSpan = h.readInt("ColumnSpan", j);
                this.rowSpan = h.readInt("RowSpan", j);
                this.tooltip = h.readString("ToolTip", j);
                var g = h.readStringFormat("TextFormat", j);
                if (g) {
                    this.setTextAlignment(g.alignment);
                    this.setLineAlignment(g.lineAlignment)
                } else {
                    this.setTextAlignment(h.readInt("TextAlignment", j));
                    this.setLineAlignment(h.readInt("TextVerticalAlignment", j))
                }
                this.imageAlign = h.readInt("ImageAlign", j);
                this.setImageContent(h.readImage("Image", j));
                var k = h.selectNode(j, "ImagePadding");
                if (k) {
                    this.imagePadding = h.readThickness("ImagePadding", j)
                }
            },
            saveToXml: function(h, g) {
                g.writeFont(this.font, "Font", h);
                g.writeBrush(this.textColor, "TextBrush", h);
                g.writeString(this.getText(), "Text", h);
                g.writeInt(this.getColumnSpan(), "ColumnSpan", h);
                g.writeInt(this.getRowSpan(), "RowSpan", h);
                g.writeString(this.getTooltip(), "ToolTip", h);
                g.writeInt(this.getTextAlignment(), "TextAlignment", h);
                g.writeInt(this.getLineAlignment(), "TextVerticalAlignment", h);
                g.writeInt(this.getImageAlign(), "ImageAlign", h);
                g.writeImage(this.getImageContent(), "Image", h);
                if (this.imagePadding) {
                    g.writeThickness(this.imagePadding, "ImagePadding", h)
                }
            },
            setText: b.DiagramItem.prototype.setText,
            getText: b.DiagramItem.prototype.getText,
            setTextAlignment: b.DiagramItem.prototype.setTextAlignment,
            getTextAlignment: b.DiagramItem.prototype.getTextAlignment,
            setLineAlignment: b.DiagramItem.prototype.setLineAlignment,
            getLineAlignment: b.DiagramItem.prototype.getLineAlignment,
            setImage: b.ShapeNode.prototype.setImage,
            getImage: b.ShapeNode.prototype.getImage,
            setImageLocation: b.ShapeNode.prototype.setImageLocation,
            getImageLocation: b.ShapeNode.prototype.getImageLocation,
            setImageContent: b.ShapeNode.prototype.setImageContent,
            getImageContent: b.ShapeNode.prototype.getImageContent,
            loadImage: b.ShapeNode.prototype.loadImage,
            setImageAlign: b.ShapeNode.prototype.setImageAlign,
            getImageAlign: b.ShapeNode.prototype.getImageAlign,
            setImagePadding: b.ShapeNode.prototype.setImagePadding,
            getImagePadding: b.ShapeNode.prototype.getImagePadding,
            setFont: function(g) {
                if (this.font !== g) {
                    this.font = g;
                    this.invalidate()
                }
            },
            getFont: function() {
                return this.font
            },
            setBrush: function(g) {
                if (this.brush !== g) {
                    this.brush = g;
                    this.invalidate()
                }
            },
            getBrush: function() {
                return this.brush
            },
            setTextColor: function(g) {
                if (this.textColor !== g) {
                    this.textColor = g;
                    this.invalidate()
                }
            },
            getTextColor: function() {
                return this.textColor
            },
            setColumnSpan: function(g) {
                if (this.columnSpan != g) {
                    this.columnSpan = g;
                    this.invalidate()
                }
            },
            getColumnSpan: function() {
                if (this.columnSpan === undefined) {
                    return 1
                }
                return this.columnSpan
            },
            setRowSpan: function(g) {
                if (this.rowSpan != g) {
                    this.rowSpan = g;
                    this.invalidate()
                }
            },
            getRowSpan: function() {
                if (this.rowSpan === undefined) {
                    return 1
                }
                return this.rowSpan
            },
            setTag: function(g) {
                if (this.tag !== g) {
                    this.tag = g
                }
            },
            getTag: function() {
                return this.tag
            },
            setTooltip: function(g) {
                if (this.tooltip !== g) {
                    this.tooltip = g;
                    this.setDiagramDirty()
                }
            },
            getTooltip: function() {
                return this.tooltip
            },
            invalidate: function() {
                if (this.parent) {
                    this.parent.invalidate()
                }
            },
            setDiagramDirty: function() {
                if (this.parent) {
                    this.parent.setDiagramDirty()
                }
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.Cell")
    })(MindFusion.Diagramming);
    (function(a) {
        var k = MindFusion.Collections.ArrayList;
        var f = MindFusion.Drawing.Path;
        var b = MindFusion.Drawing.Matrix;
        var c = MindFusion.Drawing.Rect;
        var h = MindFusion.Diagramming.Utils;
        var j = MindFusion.Diagramming.EffectPhase;
        var d = MindFusion.Diagramming.GlassEffectType;
        var g = a.GlassEffect = function() {
            mflayer.initializeBase(g, this);
            this.type = d.Type1;
            this.glowColor = "white";
            this.reflectionColor = "white"
        };
        g.prototype = {
            fromJson: function(l) {
                this.type = l.type;
                this.glowColor = l.glowColor;
                this.usePenAsGlow = l.usePenAsGlow;
                this.reflectionColor = l.reflectionColor
            },
            toJson: function() {
                var l = {
                    typeName: this.constructor.__typeName,
                    type: this.type,
                    glowColor: this.glowColor,
                    usePenAsGlow: this.usePenAsGlow,
                    reflectionColor: this.reflectionColor
                };
                return l
            },
            saveToXml: function(n, l) {
                l.writeInt(this.type, "Type", n);
                l.writeColor(this.glowColor, "GlowColor", n);
                l.writeBool(this.usePenAsGlow, "UsePenAsGlow", n);
                l.writeColor(this.reflectionColor, "ReflectionColor", n)
            },
            loadFromXml: function(n, l) {
                this.type = l.readInt("Type", n);
                this.glowColor = l.readColor("GlowColor", n);
                this.usePenAsGlow = l.readBool("UsePenAsGlow", n);
                this.reflectionColor = l.readColor("ReflectionColor", n)
            },
            clone: function() {
                var l = new this.constructor();
                l.type = this.type;
                l.glowColor = this.glowColor;
                l.usePenAsGlow = this.usePenAsGlow;
                l.reflectionColor = this.reflectionColor;
                return l
            },
            getTransform: function(p) {
                var q = new c(0, 0, 100, 100);
                var o = p.getBounds();
                var l = o.width / q.width;
                var r = o.height / q.height;
                var n = new b();
                n.translate(o.x - o.width / 2, o.y - o.height / 2);
                n.scale(l, r);
                n.translate(o.width / l - q.x - q.width / 2, o.height / r - q.y - q.height / 2);
                if (p.shapeOrientation > 0) {
                    n.rotateAt(p.shapeOrientation, q.x + q.width / 2, q.y + q.height / 2)
                }
                if (p.rotationAngle !== 0) {
                    n.rotateAt(p.rotationAngle, q.x + q.width / 2, q.y + q.height / 2)
                }
                return n
            },
            getClip: function(n) {
                if (n.shapeRenderer) {
                    return n.shapeRenderer.getOutline()
                } else {
                    var o = new f();
                    var l = n.getBounds();
                    o.addRect(l.x, l.y, l.width, l.height);
                    return o
                }
            },
            apply: function(O, R, X) {
                if (X.phase == j.AfterFill) {
                    var U = new c(0, 0, 100, 100);
                    var B = O.getBounds();
                    if (O.shapeRenderer) {
                        var M = O.shapeRenderer.getOutline()
                    } else {
                        var M = new f();
                        M.addRect(U.x, U.y, U.width, U.height)
                    }
                    var H = new MindFusion.Drawing.Container();
                    H.clip = this.getClip(O);
                    var S = this.getTransform(O);
                    var Z = h.parseColor((X.usePenAsGlow) ? O.getEffectivePen() : this.glowColor);
                    var v = h.rgbToString(Z.red, Z.green, Z.blue, 0.7);
                    var q = h.rgbToString(Z.red, Z.green, Z.blue, 0);
                    var p = h.rgbToString(Z.red, Z.green, Z.blue, 0.5);
                    var o = h.rgbToString(Z.red, Z.green, Z.blue, 0.2);
                    var n = h.rgbToString(Z.red, Z.green, Z.blue, 0.1);
                    Z = h.rgbToString(Z.red, Z.green, Z.blue);
                    var G = h.parseColor(this.reflectionColor);
                    var Q = h.rgbToString(G.red, G.green, G.blue, 0.3);
                    var N = h.rgbToString(G.red, G.green, G.blue, 0);
                    var L = h.rgbToString(G.red, G.green, G.blue, 0.5);
                    G = h.rgbToString(G.red, G.green, G.blue);
                    if (this.type == d.Type1) {
                        var aa = new f();
                        aa.arcTo(50, 100, 50, 0, 6.28318530717959 / 2, 1);
                        var E = {
                            type: "RadialGradientBrush",
                            color1: v,
                            color2: q,
                            y1: 100,
                            y2: 100,
                            radius2: 50
                        };
                        aa.setBrush(E);
                        aa.setPen(q);
                        aa.transform = S.clone();
                        k.add(H.content, aa);
                        var P = U.x;
                        var I = U.y;
                        var K = U.right();
                        var Y = U.y + U.height * 35 / 100;
                        var F = K - P;
                        var T = Y - I;
                        var D = new f();
                        if (X.isEllipse) {
                            D.addEllipse(U.x + U.width / 2, U.y + ((U.height * 70 / 100) / 2) - U.height * 20 / 100, U.width, U.height * 70 / 100)
                        } else {
                            D.lineTo(P, I, K, I);
                            D.lineTo(K, I, K, Y);
                            D.lineTo(K, Y, P + F / 2, Y);
                            D.lineTo(P + F / 2, Y);
                            D.bezierTo(P + F / 3, Y, P, Y, P, I + T / 2);
                            D.lineTo(P, I + T / 2, P, I)
                        }
                        var z = {
                            type: "SolidBrush",
                            color: Q
                        };
                        D.setBrush(z);
                        D.setPen(N);
                        D.transform = S.clone();
                        k.add(H.content, D)
                    } else {
                        if (this.type == d.Type2) {
                            var aa = new f();
                            aa.addRect(U.x, U.y + U.height / 2, U.width, U.height / 2);
                            var E = {
                                type: "LinearGradientBrush",
                                x1: 50,
                                y1: 49.5,
                                x2: 50,
                                y2: 101.5,
                                color1: q,
                                color2: Z
                            };
                            aa.setBrush(E);
                            aa.setPen(q);
                            aa.transform = S.clone();
                            k.add(H.content, aa);
                            var D = new f();
                            D.addRect(U.x, U.y, U.width, U.height / 3);
                            var z = {
                                type: "LinearGradientBrush",
                                x1: 50,
                                y1: 33.5,
                                x2: 50,
                                y2: 0,
                                color1: q,
                                color2: p
                            };
                            D.setBrush(z);
                            D.setPen(q);
                            D.transform = S.clone();
                            k.add(H.content, D);
                            var P = U.x;
                            var I = U.y;
                            var K = U.right();
                            var Y = U.y + U.height * 40 / 100;
                            var F = K - P;
                            var T = Y - I;
                            var C = new f();
                            C.lineTo(P, I, K, I);
                            C.lineTo(K, I, K, Y);
                            C.lineTo(K, I, K, Y);
                            C.lineTo(K, Y);
                            C.bezierTo(K - F / 3, Y - T / 4, P + F / 3, Y - T / 4, P, Y);
                            C.lineTo(P, Y, P, I);
                            var u = {
                                type: "SolidBrush",
                                color: Q
                            };
                            C.setBrush(u);
                            C.setPen(N);
                            C.transform = S.clone();
                            k.add(H.content, C)
                        } else {
                            if (this.type == d.Type3) {
                                var aa = new f();
                                aa.arcTo(50, 100, 100, 0, 6.28318530717959 / 2, 1);
                                var E = {
                                    type: "RadialGradientBrush",
                                    color1: v,
                                    color2: q,
                                    y1: 100,
                                    y2: 100,
                                    raduis1: 50,
                                    radius2: 100
                                };
                                aa.setBrush(E);
                                aa.setPen(q);
                                aa.transform = S.clone();
                                k.add(H.content, aa);
                                var D = new f();
                                D.addRect(U.x, U.y, U.width, U.height / 4);
                                var z = {
                                    type: "LinearGradientBrush",
                                    x1: 50,
                                    y1: 0,
                                    x2: 50,
                                    y2: 25.5,
                                    color1: L,
                                    color2: N
                                };
                                D.setBrush(z);
                                D.setPen(N);
                                D.transform = S.clone();
                                k.add(H.content, D);
                                var C = M.clone();
                                var A = new c(B.x, B.y, B.width, B.height / 4);
                                var W = new MindFusion.Drawing.Container();
                                W.clip = A;
                                var u = {
                                    type: "LinearGradientBrush",
                                    x1: 50,
                                    y1: 0,
                                    x2: 50,
                                    y2: 100,
                                    color1: G,
                                    color2: N
                                };
                                C.setBrush("transparent");
                                C.setPen(u);
                                var J = 1 - (((O.getEffectiveStrokeThickness() || 1) / O.parent.scale) / 100);
                                var V = S.clone();
                                V.scaleAtCenter(J, J, U);
                                C.transform = V.clone();
                                k.add(W.content, C);
                                k.add(H.content, W)
                            } else {
                                if (this.type == d.Type4) {
                                    var aa = new f();
                                    aa.addRect(U.x, U.y, U.width, U.height / 2);
                                    var E = {
                                        type: "LinearGradientBrush",
                                        x1: 50,
                                        y1: 0,
                                        x2: 50,
                                        y2: 50.5,
                                        color1: L,
                                        color2: Q
                                    };
                                    E.colorStops = [];
                                    E.colorStops.push({
                                        position: 0,
                                        color: N
                                    });
                                    E.colorStops.push({
                                        position: 0.2,
                                        color: Q
                                    });
                                    E.colorStops.push({
                                        position: 0.4,
                                        color: L
                                    });
                                    aa.setBrush(E);
                                    aa.setPen(N);
                                    aa.transform = S.clone();
                                    k.add(H.content, aa);
                                    var D = new f();
                                    D.addRect(U.x, U.y, U.width, U.height);
                                    var z = {
                                        type: "LinearGradientBrush",
                                        color1: Z,
                                        color2: Z
                                    };
                                    z.colorStops = [];
                                    z.colorStops.push({
                                        position: 0,
                                        color: o
                                    });
                                    z.colorStops.push({
                                        position: 0.037,
                                        color: n
                                    });
                                    z.colorStops.push({
                                        position: 0.143,
                                        color: q
                                    });
                                    z.colorStops.push({
                                        position: 0.4,
                                        color: n
                                    });
                                    z.colorStops.push({
                                        position: 0.857,
                                        color: q
                                    });
                                    z.colorStops.push({
                                        position: 0.963,
                                        color: n
                                    });
                                    z.colorStops.push({
                                        position: 1,
                                        color: o
                                    });
                                    D.setBrush(z);
                                    D.setPen(N);
                                    D.transform = S.clone();
                                    k.add(H.content, D)
                                }
                            }
                        }
                    }
                    k.add(R, H)
                }
            },
            getType: function() {
                return this.type
            },
            setType: function(l) {
                this.type = l
            },
            getGlowColor: function() {
                return this.glowColor
            },
            setGlowColor: function(l) {
                this.glowColor = l
            },
            getUsePenAsGlow: function() {
                return this.usePenAsGlow
            },
            setUsePenAsGlow: function(l) {
                this.usePenAsGlow = l
            },
            getReflectionColor: function() {
                return this.reflectionColor
            },
            setReflectionColor: function(l) {
                this.reflectionColor = l
            }
        };
        MindFusion.registerClass(g, "MindFusion.Diagramming.GlassEffect");
        var e = a.AeroEffect = function() {
            mflayer.initializeBase(e, this);
            this.opacity = 0.4;
            this.shadeColor = "black";
            this.innerOutlineColor = "white"
        };
        e.prototype = {
            fromJson: function(l) {
                this.opacity = l.opacity;
                this.shadeColor = l.shadeColor;
                this.innerOutlineColor = l.innerOutlineColor
            },
            toJson: function() {
                var l = {
                    typeName: this.constructor.__typeName,
                    opacity: this.opacity,
                    shadeColor: this.shadeColor,
                    innerOutlineColor: this.innerOutlineColor
                };
                return l
            },
            saveToXml: function(n, l) {
                l.writeFloat(this.opacity, "Opacity", n);
                l.writeColor(this.shadeColor, "ShadeColor", n);
                l.writeColor(this.innerOutlineColor, "InnerOutlineColor", n)
            },
            loadFromXml: function(n, l) {
                this.opacity = l.readFloat("Opacity", n);
                this.shadeColor = l.readColor("ShadeColor", n);
                this.innerOutlineColor = l.readColor("InnerOutlineColor", n)
            },
            clone: function() {
                var l = new this.constructor();
                l.opacity = this.opacity;
                l.shadeColor = this.shadeColor;
                l.innerOutlineColor = this.innerOutlineColor;
                return l
            },
            getTransform: function(p) {
                var q = new c(0, 0, 100, 100);
                var o = p.getBounds();
                var l = o.width / q.width;
                var r = o.height / q.height;
                var n = new b();
                n.translate(o.x - o.width / 2, o.y - o.height / 2);
                n.scale(l, r);
                n.translate(o.width / l - q.x - q.width / 2, o.height / r - q.y - q.height / 2);
                if (p.shapeOrientation > 0) {
                    n.rotateAt(p.shapeOrientation, q.x + q.width / 2, q.y + q.height / 2)
                }
                if (p.rotationAngle !== 0) {
                    n.rotateAt(p.rotationAngle, q.x + q.width / 2, q.y + q.height / 2)
                }
                return n
            },
            apply: function(q, A, s) {
                var u = new c(0, 0, 100, 100);
                var l = q.getBounds();
                if (q.shapeRenderer) {
                    var C = q.shapeRenderer.getOutline()
                } else {
                    var C = new f();
                    C.addRect(u.x, u.y, u.width, u.height)
                }
                var n = new MindFusion.Drawing.Container();
                var D = this.getTransform(q);
                var z = s.unitsPerPixel;
                var v = z * 3;
                var B = s.brush;
                if (s.phase == j.BeforeFill) {
                    if (typeof(s.brush) == "string") {
                        B = {
                            type: "SolidBrush",
                            color: h.parseColor(s.brush)
                        }
                    } else {
                        if (B.type == "SolidBrush") {
                            B.color = h.parseColor(B.color)
                        }
                    }
                    if (B.type == "LinearGradientBrush" || B.type == "RadialGradientBrush") {
                        B.color1 = h.parseColor(B.color1);
                        B.color2 = h.parseColor(B.color2)
                    }
                    if (B.type == "SolidBrush") {
                        B.color = h.rgbToString(B.color.red, B.color.green, B.color.blue, this.opacity)
                    } else {
                        if (B.type == "LinearGradientBrush" || B.type == "RadialGradientBrush") {
                            B.color1 = h.rgbToString(B.color1.red, B.color1.green, B.color1.blue, this.opacity);
                            B.color2 = h.rgbToString(B.color2.red, B.color2.green, B.color2.blue, this.opacity)
                        }
                    }
                    s.brush = B;
                    var p = C.clone();
                    p.setBrush("transparent");
                    var o = h.parseColor(this.shadeColor);
                    var r = D.clone();
                    r.scaleAtCenter(1.01, 1.01, u);
                    var F = 15;
                    for (var w = 10; w >= 0; w -= 2) {
                        epath2 = p.clone();
                        epath2.lineJoin = "round";
                        epath2.setPen(h.rgbToString(o.red, o.green, o.blue, 0.1));
                        F -= 3;
                        epath2.strokeThickness = F;
                        epath2.transform = r.clone();
                        k.add(n.content, epath2)
                    }
                    k.add(A, n);
                    return
                }
                var p = C.clone();
                p.setBrush("transparent");
                p.setPen(this.innerOutlineColor);
                p.strokeThickness = q.getEffectiveStrokeThickness() + v;
                var E = D.clone();
                E.scaleAtCenter(0.99, 0.99, u);
                p.transform = E.clone();
                k.add(n.content, p);
                k.add(A, n)
            },
            getOpacity: function() {
                return this.opacity
            },
            setOpacity: function(l) {
                this.opacity = l
            },
            getShadeColor: function() {
                return this.shadeColor
            },
            setShadeColor: function(l) {
                this.shadeColor = l
            },
            getInnerOutlineColor: function() {
                return this.innerOutlineColor
            },
            setInnerOutlineColor: function(l) {
                this.innerOutlineColor = l
            }
        };
        MindFusion.registerClass(e, "MindFusion.Diagramming.AeroEffect")
    })(MindFusion.Diagramming);
    (function(b) {
        var a = MindFusion.Collections.ArrayList;
        var c = b.CompositeCommand = function(d) {
            mflayer.initializeBase(c, this, [d]);
            this.commands = [];
            this.name = "CompositeCommand"
        };
        c.prototype = {
            execute: function() {
                a.forEach(this.commands, function(d) {
                    d.execute()
                }, this)
            },
            undo: function() {
                for (var d = this.commands.length - 1; d >= 0; d--) {
                    this.commands[d].undo()
                }
            },
            redo: function() {
                a.forEach(this.commands, function(d) {
                    d.redo()
                }, this)
            },
            getCommands: function() {
                return this.commands
            }
        };
        MindFusion.registerClass(c, "MindFusion.Diagramming.CompositeCommand", b.Command)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.AddItemCommand = function(c, d) {
            mflayer.initializeBase(a, this, [c]);
            this.item = d;
            this.name = "AddItemCommand"
        };
        a.prototype = {
            execute: function() {
                this.diagram.doAddItem(this.item)
            },
            undo: function() {
                this.diagram.doRemoveItem(this.item, false)
            },
            redo: function() {
                this.diagram.doAddItem(this.item)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.AddItemCommand", b.Command)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.RemoveItemCommand = function(c, d) {
            mflayer.initializeBase(b, this, [c]);
            this.item = d;
            this.name = "RemoveItemCommand"
        };
        b.prototype = {
            execute: function() {
                this.diagram.doRemoveItem(this.item)
            },
            undo: function() {
                this.diagram.doAddItem(this.item)
            },
            redo: function() {
                this.diagram.doRemoveItem(this.item)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.RemoveItemCommand", a.Command)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.ChangeItemCommand = function(c, d) {
            mflayer.initializeBase(a, this, [c]);
            this.state = d.saveState();
            this.item = d
        };
        a.prototype = {
            undo: function() {
                this.exchangeStates()
            },
            redo: function() {
                this.exchangeStates()
            },
            execute: function() {},
            exchangeStates: function() {
                var c = this.item.saveState();
                this.item.restoreState(this.state);
                this.state = c
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.ChangeItemCommand", b.Command)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.FoldContainerCommand = function(d, c) {
            mflayer.initializeBase(b, this, [d]);
            this.container = c;
            this.folded = this.container.folded;
            this.name = "FoldContainerCommand"
        };
        b.prototype = {
            execute: function() {
                this.container.setFolded(!this.container.getFolded())
            },
            undo: function() {
                if (this.folded) {
                    this.container.doFold()
                } else {
                    this.container.doUnfold()
                }
            },
            redo: function() {
                if (!this.folded) {
                    this.container.doFold()
                } else {
                    this.container.doUnfold()
                }
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.FoldContainerCommand", a.Command)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.ScrollTableCommand = function(c, d) {
            mflayer.initializeBase(b, this, [c]);
            this.table = d;
            this.oldRow = d.currentScrollRow;
            this.name = "ScrollTableCommand"
        };
        b.prototype = {
            execute: function() {
                this.newRow = this.table.currentScrollRow
            },
            undo: function() {
                this.table.setCurrentScrollRow(this.oldRow)
            },
            redo: function() {
                this.table.setCurrentScrollRow(this.newRow)
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.ScrollTableCommand", a.Command)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.ResizeTableColumnCommand = function(c, e, d) {
            mflayer.initializeBase(a, this, [c]);
            this.table = e;
            this.column = d;
            this.oldWidth = this.column.width;
            this.oldStyle = this.column.columnStyle;
            this.name = "ResizeTableColumnCommand"
        };
        a.prototype = {
            execute: function() {
                this.newWidth = this.column.width;
                this.newStyle = this.column.columnStyle
            },
            undo: function() {
                this.table.setColumnWidth(this.column, this.oldWidth);
                this.table.setColumnStyle(this.column, this.oldStyle)
            },
            redo: function() {
                this.table.setColumnStyle(this.column, this.newStyle);
                this.table.setColumnWidth(this.column, this.newWidth)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.ResizeTableColumnCommand", b.Command)
    })(MindFusion.Diagramming);
    (function(b) {
        var a = b.ResizeTableRowCommand = function(c, d, e) {
            mflayer.initializeBase(a, this, [c]);
            this.table = d;
            this.row = e;
            this.oldHeight = this.row.height;
            this.name = "ResizeTableRowCommand"
        };
        a.prototype = {
            execute: function() {
                this.newHeight = this.row.height
            },
            undo: function() {
                this.table.setRowHeight(this.row, this.oldHeight)
            },
            redo: function() {
                this.table.setRowHeight(this.row, this.newHeight)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.ResizeTableRowCommand", b.Command)
    })(MindFusion.Diagramming);
    (function(a) {
        var b = a.UndoManager = function(c) {
            this.diagram = c;
            this.undoHistory = [];
            this.undoIndex = -1;
            this.currentComposite = null;
            this.startCompositeCounter = 0
        };
        b.prototype = {
            executeCommand: function(c) {
                c.execute();
                if (this.currentComposite == null) {
                    this.addToHistory(c)
                } else {
                    this.currentComposite.commands.push(c)
                }
            },
            addToHistory: function(c) {
                if (this.undoIndex < this.undoHistory.length - 1) {
                    this.undoHistory.splice(this.undoIndex + 1, this.undoHistory.length - this.undoIndex - 1)
                }
                this.undoHistory.push(c);
                ++this.undoIndex;
                this.diagram.updateCanUndo()
            },
            startComposite: function() {
                if (this.currentComposite == null) {
                    this.currentComposite = new a.CompositeCommand(this.diagram)
                }
                this.startCompositeCounter++;
                return this.currentComposite
            },
            endComposite: function(c) {
                this.startCompositeCounter--;
                if (this.startCompositeCounter == 0) {
                    if (c != false) {
                        this.addToHistory(this.currentComposite)
                    }
                    this.currentComposite = null
                }
            },
            undo: function() {
                if (this.canUndo()) {
                    var d = this.undoHistory[this.undoIndex];
                    d.undo();
                    --this.undoIndex;
                    this.diagram.updateCanUndo()
                }
            },
            redo: function() {
                if (this.canRedo()) {
                    ++this.undoIndex;
                    var d = this.undoHistory[this.undoIndex];
                    d.redo();
                    this.diagram.updateCanUndo()
                }
            },
            canUndo: function() {
                return this.undoIndex >= 0
            },
            canRedo: function() {
                return this.undoIndex < this.undoHistory.length - 1
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.UndoManager")
    })(MindFusion.Diagramming);
    (function(n) {
        var g = MindFusion.Collections.ArrayList;
        var L = MindFusion.Geometry;
        var w = MindFusion.Graphs.Graph;
        var B = MindFusion.Drawing.GraphicsUnit;
        var v = MindFusion.Drawing.Rect;
        var j = MindFusion.Collections.Set;
        var u = n.Router = function(b) {
            this.diagram = b;
            A = this.diagram.routeMargin
        };
        u.prototype = {
            route: function(l) {
                this.markObstacles();
                var b = this.routeInternal(l);
                l.invalidate();
                l.copyPoints(b, 0, 0, false)
            },
            routeLinks: function(b) {
                this.markObstacles();
                for (var l = 0; l < b.length; l++) {
                    var r = b[l];
                    r._mf_route = this.routeInternal(r)
                }
                this.pullLinksApart(b);
                for (var l = 0; l < b.length; l++) {
                    var r = b[l];
                    r.invalidate();
                    r.copyPoints(r._mf_route, 0, 0, false);
                    delete r._mf_route
                }
            },
            routeInternal: function(U) {
                A = this.diagram.routeMargin;
                var X = U.getOrigin().getRotatedBounds();
                var ab = U.getStartPoint();
                var ap = U.getDestination().getRotatedBounds();
                var W = U.getEndPoint();
                if (n.ContainerNode.usingContainerNodes) {
                    var am = n.ContainerNode.getFoldedContainer(U.getOrigin());
                    var t = n.ContainerNode.getFoldedContainer(U.getDestination());
                    if (am != t) {
                        if (am) {
                            X = am.getRotatedBounds()
                        }
                        if (t) {
                            ap = t.getRotatedBounds()
                        }
                    }
                }
                var Z = X.center();
                var ak = ap.center();
                var af = -[0, 90, 180, 270][d(Z, ak)];
                if (af != 0) {
                    X = P(X, Z, af);
                    ab = n.Utils.rotatePointAt(ab, Z, af);
                    ap = P(ap, Z, af);
                    W = n.Utils.rotatePointAt(W, Z, af)
                }
                var an = G(X, ab) + G(ap, W);
                var ai = h[an](X, ab, ap, W);
                if (af != 0) {
                    n.Utils.rotatePointsAt(ai, Z, -af)
                }
                var ad = O(this.diagram, U, ai);
                if (ad.length > 0) {
                    var r = [];
                    var aa = D(ad);
                    for (var aj = 0; aj < ai.length - 1; ++aj) {
                        var ah = [];
                        var l = ai[aj];
                        var b = ai[aj + 1];
                        g.forEach(aa, function(ar) {
                            g.addRange(ah, S(l, b, ar, aj))
                        });
                        ah.sort(function(au, ar) {
                            var av = L.distance(l, au);
                            var at = L.distance(l, ar);
                            if (av < at) {
                                return -1
                            }
                            if (av > at) {
                                return 1
                            }
                            return 0
                        });
                        g.addRange(r, ah)
                    }
                    var aq = [];
                    for (var aj = 0; aj < r.length; ++aj) {
                        var al = r[aj];
                        for (var ag = aj + 1; ag < r.length; ++ag) {
                            var V = r[ag];
                            if (V.node == al.node) {
                                aq.push(al);
                                aq.push(V);
                                aj = ag;
                                break
                            }
                        }
                    }
                    if (aq.length > 0) {
                        var ao = [];
                        var Y = -1;
                        for (var ac = 0; ac < aq.length - 1; ac += 2) {
                            var al = aq[ac];
                            var ae = aq[ac + 1];
                            while (Y != al.segment) {
                                ao.push(ai[++Y])
                            }
                            c(ao, al.node, al, ae);
                            Y = ae.segment
                        }
                        while (Y != ai.length - 1) {
                            ao.push(ai[++Y])
                        }
                        ai = ao
                    }
                    k(U, ad);
                    I(ai, ad)
                }
                return ai
            },
            segmentsFromPoints: function(r) {
                var b = [];
                for (var l = 0; l < r.length - 1; l++) {
                    var t = {
                        index: l,
                        points: r,
                        horizontal: function() {
                            return this.points[this.index].y == this.points[this.index + 1].y
                        },
                        xint: function() {
                            var V = this.points[this.index].x;
                            var U = this.points[this.index + 1].x;
                            return V < U ? [V, U] : [U, V]
                        },
                        yint: function() {
                            var V = this.points[this.index].y;
                            var U = this.points[this.index + 1].y;
                            return V < U ? [V, U] : [U, V]
                        }
                    };
                    b.push(t)
                }
                return b
            },
            pullLinksApart: function(b) {
                for (var l = 0; l < b.length; l++) {
                    var r = b[l];
                    r._mf_segments = this.segmentsFromPoints(r._mf_route)
                }
                this.splitPaths(b, true);
                this.splitPaths(b, false)
            },
            splitPaths: function(r, al) {
                var ad = [];
                for (var ah = 0; ah < r.length; ah++) {
                    var Y = r[ah];
                    var ab = Y._mf_segments;
                    for (var af = 0; af < ab.length; af++) {
                        var l = ab[af];
                        if (l.horizontal() == al) {
                            ad.push(l)
                        }
                    }
                }
                ad.sort(al ? o : p);
                var an = -(Number.MAX_VALUE - 1);
                var ao = [];
                var X = ad.length;
                for (var ah = 0; ah <= X; ++ah) {
                    var l = ah < X ? ad[ah] : null;
                    if (l == null || q(l, al) != an) {
                        if (ao.length > 1) {
                            var b = f(ao, al);
                            for (var aj = 0; aj < b.length; aj++) {
                                var Z = b[aj];
                                if (Z.length < 2) {
                                    continue
                                }
                                var U = q(Z[0], al);
                                Z.sort(al ? z : s);
                                var ae = U - A / 2;
                                var ag = U + A / 2;
                                var ai = A / 8;
                                var ac = (ae + ag) / 2;
                                var ak = Math.min((ag - ae) / 2, (Z.length - 1) * 3 * ai);
                                var W = ak / (Z.length - 1);
                                var V = U - ak / 2 >= ae + W ? U - ak / 2 : ac - ak / 2;
                                for (var am = 0; am < Z.length; am++) {
                                    var aa = Z[am];
                                    var t = V - q(aa, al);
                                    if (al) {
                                        aa.points[aa.index].y = V;
                                        aa.points[aa.index + 1].y = V
                                    } else {
                                        aa.points[aa.index].x = V;
                                        aa.points[aa.index + 1].x = V
                                    }
                                    V += W
                                }
                            }
                        }
                        ao.length = 0
                    }
                    if (l != null) {
                        an = q(l, al);
                        if (l.index > 0 && l.index < l.points.length - 1) {
                            ao.push(l)
                        }
                    }
                }
            },
            markObstacles: function() {}
        };
        var A = 8;
        var h = {
            rl: function(l, U, b, t) {
                var r = M(K(l), N(b));
                return [U, {
                    x: r,
                    y: U.y
                }, {
                    x: r,
                    y: t.y
                }, t]
            },
            rt: function(l, U, b, t) {
                if (U.y < H(b) - A) {
                    return [U, {
                        x: t.x,
                        y: U.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: r,
                    y: U.y
                }, {
                    x: r,
                    y: H(b) - A
                }, {
                    x: t.x,
                    y: H(b) - A
                }, t]
            },
            rb: function(l, U, b, t) {
                if (U.y > Q(b) + A) {
                    return [U, {
                        x: t.x,
                        y: U.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: r,
                    y: U.y
                }, {
                    x: r,
                    y: Q(b) + A
                }, {
                    x: t.x,
                    y: Q(b) + A
                }, t]
            },
            rr: function(l, U, b, t) {
                if (U.y < H(b) - A || U.y > Q(b) + A) {
                    return [U, {
                        x: K(b) + A,
                        y: U.y
                    }, {
                        x: K(b) + A,
                        y: t.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: r,
                    y: U.y
                }, {
                    x: r,
                    y: Q(b) + A
                }, {
                    x: K(b) + A,
                    y: Q(b) + A
                }, {
                    x: K(b) + A,
                    y: t.y
                }, t]
            },
            bl: function(l, U, b, t) {
                if (Q(l) < t.y - A) {
                    return [U, {
                        x: U.x,
                        y: t.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: U.x,
                    y: Q(l) + A
                }, {
                    x: r,
                    y: Q(l) + A
                }, {
                    x: r,
                    y: t.y
                }, t]
            },
            bt: function(r, V, l, U) {
                if (Q(r) < H(l) - 2 * A) {
                    var b = M(Q(r), H(l));
                    return [V, {
                        x: V.x,
                        y: b
                    }, {
                        x: U.x,
                        y: b
                    }, U]
                }
                var t = M(K(r), N(l));
                return [V, {
                    x: V.x,
                    y: Q(r) + A
                }, {
                    x: t,
                    y: Q(r) + A
                }, {
                    x: t,
                    y: H(l) - A
                }, {
                    x: U.x,
                    y: H(l) - A
                }, U]
            },
            bb: function(r, U, l, t) {
                var b = Math.max(Q(r), Q(l)) + A;
                return [U, {
                    x: U.x,
                    y: b
                }, {
                    x: t.x,
                    y: b
                }, t]
            },
            br: function(r, U, l, t) {
                var b = Q(r) < H(l) - 2 * A ? M(Q(r), H(l)) : Math.max(Q(r), Q(l)) + A;
                return [U, {
                    x: U.x,
                    y: b
                }, {
                    x: K(l) + A,
                    y: b
                }, {
                    x: K(l) + A,
                    y: t.y
                }, t]
            },
            tl: function(l, U, b, t) {
                if (t.y < H(l) - A) {
                    return [U, {
                        x: U.x,
                        y: t.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: U.x,
                    y: H(l) - A
                }, {
                    x: r,
                    y: H(l) - A
                }, {
                    x: r,
                    y: t.y
                }, t]
            },
            tt: function(l, U, b, t) {
                var r = Math.min(H(l), H(b));
                return [U, {
                    x: U.x,
                    y: r - A
                }, {
                    x: t.x,
                    y: r - A
                }, t]
            },
            tb: function(r, V, l, U) {
                if (H(r) > Q(l) + 2 * A) {
                    var b = M(H(r), Q(l));
                    return [V, {
                        x: V.x,
                        y: b
                    }, {
                        x: U.x,
                        y: b
                    }, U]
                }
                var t = M(K(r), N(l));
                return [V, {
                    x: V.x,
                    y: H(r) - A
                }, {
                    x: t,
                    y: H(r) - A
                }, {
                    x: t,
                    y: Q(l) + A
                }, {
                    x: U.x,
                    y: Q(l) + A
                }, U]
            },
            tr: function(r, U, l, t) {
                var b = H(r) > Q(l) + 2 * A ? M(H(r), Q(l)) : Math.min(H(r), H(l)) - A;
                return [U, {
                    x: U.x,
                    y: b
                }, {
                    x: K(l) + A,
                    y: b
                }, {
                    x: K(l) + A,
                    y: t.y
                }, t]
            },
            ll: function(l, U, b, t) {
                if (H(l) > t.y + A || Q(l) < t.y - A) {
                    return [U, {
                        x: N(l) - A,
                        y: U.y
                    }, {
                        x: N(l) - A,
                        y: t.y
                    }, t]
                }
                var r = M(K(l), N(b));
                return [U, {
                    x: N(l) - A,
                    y: U.y
                }, {
                    x: N(l) - A,
                    y: H(l) - A
                }, {
                    x: r,
                    y: H(l) - A
                }, {
                    x: r,
                    y: t.y
                }, t]
            },
            lt: function(r, V, l, U) {
                if (Q(r) < H(l) - 2 * A) {
                    var b = M(Q(r), H(l));
                    return [V, {
                        x: N(r) - A,
                        y: V.y
                    }, {
                        x: N(r) - A,
                        y: b
                    }, {
                        x: U.x,
                        y: b
                    }, U]
                }
                var t = Math.min(H(r), H(l));
                return [V, {
                    x: N(r) - A,
                    y: V.y
                }, {
                    x: N(r) - A,
                    y: t - A
                }, {
                    x: U.x,
                    y: t - A
                }, U]
            },
            lb: function(t, V, r, U) {
                if (H(t) > Q(r) + 2 * A) {
                    var l = M(H(t), Q(r));
                    return [V, {
                        x: N(t) - A,
                        y: V.y
                    }, {
                        x: N(t) - A,
                        y: l
                    }, {
                        x: U.x,
                        y: l
                    }, U]
                }
                var b = Math.max(Q(t), Q(r));
                return [V, {
                    x: N(t) - A,
                    y: V.y
                }, {
                    x: N(t) - A,
                    y: b + A
                }, {
                    x: U.x,
                    y: b + A
                }, U]
            },
            lr: function(r, U, l, t) {
                var b = 0;
                if (H(r) > Q(l) + 2 * A) {
                    b = M(H(r), Q(l))
                } else {
                    if (Q(r) < H(l) - 2 * A) {
                        b = M(Q(r), H(l))
                    } else {
                        b = Math.min(H(r), H(l)) - A
                    }
                }
                return [U, {
                    x: N(r) - A,
                    y: U.y
                }, {
                    x: N(r) - A,
                    y: b
                }, {
                    x: K(l) + A,
                    y: b
                }, {
                    x: K(l) + A,
                    y: t.y
                }, t]
            }
        };

        function G(V, Y) {
            var r = V.getCornerPoints();
            var W = [];
            var b = ["t", "r", "b", "l"];
            var U = "t";
            for (var l = 0; l < 4; ++l) {
                var t = new MindFusion.Drawing.DistanceToSegment(Y, r[l], r[(l + 1) % 4]);
                W.push(t.distanceToSegment())
            }
            var X = Number.MAX_VALUE;
            for (var l = 0; l < 4; ++l) {
                if (W[l] < X) {
                    X = W[l];
                    U = b[l]
                }
            }
            return U
        }

        function d(r, l) {
            var b = l.x - r.x;
            var t = l.y - r.y;
            if (Math.abs(b) > Math.abs(t) && b >= 0) {
                return 0
            }
            if (Math.abs(b) > Math.abs(t) && b < 0) {
                return 2
            }
            if (t > 0) {
                return 1
            }
            return 3
        }

        function P(aa, W, ab) {
            var X = aa.getCornerPoints();
            n.Utils.rotatePointsAt(X, W, ab);
            var V = Math.min(X[0].x, Math.min(X[1].x, X[2].x));
            var Y = Math.min(X[0].y, Math.min(X[1].y, X[2].y));
            var Z = Math.max(X[0].x, Math.max(X[1].x, X[2].x));
            var U = Math.max(X[0].y, Math.max(X[1].y, X[2].y));
            return v.fromLTRB(V, Y, Z, U)
        }

        function F(l, b, t, r) {
            var X = b.x - l.x;
            var W = b.y - l.y;
            var V = r.x - t.x;
            var U = r.y - t.y;
            if (X == 0 && V == 0) {
                return null
            }
            if (W == 0 && U == 0) {
                return null
            }
            if (V == 0 && T(t.x, l.x, b.x) && E(l.y, t.y, r.y)) {
                return {
                    x: t.x,
                    y: l.y
                }
            }
            if (X == 0 && E(l.x, t.x, r.x) && T(t.y, l.y, b.y)) {
                return {
                    x: l.x,
                    y: t.y
                }
            }
            return null
        }

        function S(Y, X, r, V) {
            var W = r.routeBounds;
            var l = [];
            var U = W.getCornerPoints();
            for (var t = 0; t < 4; ++t) {
                var b = F(Y, X, U[t], U[(t + 1) % 4]);
                if (b) {
                    b.node = r;
                    b.segment = V;
                    b.side = t;
                    l.push(b);
                    r.routeIntersections++
                }
            }
            return l
        }

        function E(l, U, t) {
            var r = Math.min(U, t);
            var b = Math.max(U, t);
            return r < l && l < b
        }

        function T(l, U, t) {
            var r = Math.min(U, t);
            var b = Math.max(U, t);
            return r <= l && l <= b
        }

        function O(l, t, r) {
            var b = [];
            var U = v.boundingRect(r);
            l.nodes.forEach(function(W) {
                if (W == t.getOrigin() || W == t.getDestination()) {
                    return
                }
                if (!W.getObstacle()) {
                    return
                }
                if (W.containsRecursively) {
                    if (W.containsRecursively(t.getOrigin()) || W.containsRecursively(t.getDestination())) {
                        return
                    }
                }
                if (n.ContainerNode.usingContainerNodes) {
                    var X = n.ContainerNode.getFoldedContainer(W);
                    if (X != null) {
                        return
                    }
                }
                var V = n.Utils.inflate(W.getRotatedBounds(), A, A);
                W.routeBounds = V;
                W.routeIntersections = 0;
                if (V.intersectsWith(U)) {
                    b.push(W)
                }
            });
            return b
        }

        function k(r, b) {
            var l = [];
            l.push(r.getOrigin());
            if (r.getOrigin() != r.getDestination()) {
                l.push(r.getDestination())
            }
            g.forEach(l, function(U) {
                if (!U.getObstacle()) {
                    return
                }
                var t = n.Utils.inflate(U.getRotatedBounds(), A, A);
                U.routeBounds = t;
                U.routeIntersections = 0;
                b.push(U)
            })
        }

        function D(t) {
            if (t.length == 1) {
                return t
            }
            var b = [];
            var X = new w;
            g.forEach(t, function(Y) {
                Y.rvertex = X.createVertex(null, Y)
            });
            for (var V = 0; V < t.length - 1; ++V) {
                var r = t[V];
                for (var U = V + 1; U < t.length; ++U) {
                    var l = t[U];
                    if (r.routeBounds.intersectsWith(l.routeBounds.inflate(-A / 4))) {
                        X.createEdge(r.rvertex, l.rvertex)
                    }
                }
            }
            var W = X.getConnectedComponents();
            g.forEach(W, function(Y) {
                if (Y.vertices.length == 1) {
                    b.push(Y.vertices[0].owner)
                } else {
                    var Z = null;
                    Y.vertices.forEach(function(aa) {
                        Z = aa.owner.routeBounds.union(Z)
                    });
                    b.push({
                        routeBounds: Z,
                        routeIntersections: 0
                    })
                }
            });
            g.forEach(t, function(Y) {
                delete Y.rvertex
            });
            return b
        }

        function c(t, U, X, l) {
            var b = U.routeBounds.getCornerPoints();
            var W = [];
            W.push(X);
            var r = X.side;
            while (r != l.side) {
                r = (r + 1) % 4;
                W.push(b[r])
            }
            W.push(l);
            var V = [];
            V.push(X);
            var r = X.side;
            while (r != l.side) {
                V.push(b[r]);
                r = r - 1;
                if (r < 0) {
                    r = 3
                }
            }
            V.push(l);
            if (W.length < V.length) {
                g.addRange(t, W)
            } else {
                if (W.length > V.length) {
                    g.addRange(t, V)
                } else {
                    g.addRange(t, J(W) < J(V) ? W : V)
                }
            }
        }

        function J(r) {
            var b = 0;
            for (var l = 0; l < r.length - 1; ++l) {
                b += L.distance(r[l], r[l + 1])
            }
            return b
        }

        function N(b) {
            return b.x
        }

        function H(b) {
            return b.y
        }

        function K(b) {
            return b.x + b.width
        }

        function Q(b) {
            return b.y + b.height
        }

        function M(l, b) {
            return (l + b) / 2
        }

        function C(l, b) {
            return b[l].y == b[l + 1].y
        }

        function e(l, b) {
            var t = b[l];
            var r = b[l + 1];
            if (t.x == r.x) {
                return r.y - t.y
            } else {
                return r.x - t.x
            }
        }

        function R(Y, X, l) {
            for (var r = 0; r < l.length; ++r) {
                var t = l[r];
                var W = t.routeBounds.inflate(-A / 8);
                if (W.containsPoint(Y) && W.containsPoint(X)) {
                    return true
                }
                var V = W.getCornerPoints();
                for (var U = 0; U < 4; ++U) {
                    var b = F(Y, X, V[U], V[(U + 1) % 4]);
                    if (b) {
                        return true
                    }
                }
            }
            return false
        }

        function I(aa, l) {
            for (var U = 1; U < aa.length - 4; ++U) {
                var V = U;
                var t = U + 1;
                var ab = U + 2;
                var Y = e(V, aa);
                var b = e(ab, aa);
                var X = C(V, aa);
                var Z = C(t, aa);
                var r = C(ab, aa);
                if (X != Z && X == r && Y * b < 0) {
                    if (Math.abs(Y) < Math.abs(b)) {
                        var W = X ? {
                            x: aa[V].x,
                            y: aa[ab].y
                        } : {
                            x: aa[ab].x,
                            y: aa[V].y
                        };
                        if (!R(aa[V], W, l)) {
                            aa.splice(V, 3, W);
                            U = Math.max(1, U - 2)
                        }
                    } else {
                        var W = X ? {
                            x: aa[ab + 1].x,
                            y: aa[V].y
                        } : {
                            x: aa[V].x,
                            y: aa[ab + 1].y
                        };
                        if (!R(W, aa[ab + 1], l)) {
                            aa.splice(t, 3, W);
                            U = Math.max(1, U - 2)
                        }
                    }
                }
            }
        }

        function p(l, b) {
            var t = l.points[l.index];
            var r = b.points[b.index];
            if (t.x < r.x) {
                return -1
            }
            if (t.x > r.x) {
                return 1
            }
            return 0
        }

        function o(l, b) {
            var t = l.points[l.index];
            var r = b.points[b.index];
            if (t.y < r.y) {
                return -1
            }
            if (t.y > r.y) {
                return 1
            }
            return 0
        }

        function s(Y, W) {
            var Z = Y.points[0];
            var X = W.points[0];
            if (Z.x < X.x) {
                return -1
            }
            if (Z.x > X.x) {
                return 1
            }
            var V = Y.points[Y.index];
            var U = W.points[W.index];
            var l = Y.points[Y.index + 1];
            var b = W.points[W.index + 1];
            var t = V.y > l.y;
            var r = U.y > b.y;
            if (t && r) {
                if (V.y < U.y) {
                    return -1
                }
                if (V.y > U.y) {
                    return 1
                }
            }
            if (!t && !r) {
                if (V.y < U.y) {
                    return 1
                }
                if (V.y > U.y) {
                    return -1
                }
            }
            if (t && !r) {
                return -1
            }
            if (!t && r) {
                return 1
            }
            return 0
        }

        function z(l, b) {
            var t = l.points[0];
            var r = b.points[0];
            if (t.y < r.y) {
                return -1
            }
            if (t.y > r.y) {
                return 1
            }
            return 0
        }

        function q(r, l) {
            var b = r.points[r.index];
            return l ? b.y : b.x
        }

        function f(V, b) {
            var ad = new MindFusion.Graphs.Graph();
            var Z = [];
            for (var U = 0; U < V.length; U++) {
                var Y = V[U];
                var X = ad.createVertex(null, Y);
                Z.push(X)
            }
            for (var U = 0; U < V.length - 1; U++) {
                for (var t = U + 1; t < V.length; t++) {
                    var r = b ? V[U].xint() : V[U].yint();
                    var l = b ? V[t].xint() : V[t].yint();
                    if (a(r, l)) {
                        ad.createEdge(Z[U], Z[t])
                    }
                }
            }
            var W = ad.getConnectedComponents();
            var ae = [];
            for (var U = 0; U < W.length; U++) {
                var aa = W[U];
                var ac = [];
                for (var ab = 0; ab < aa.vertices.length; ab++) {
                    var X = aa.vertices[ab];
                    ac.push(X.owner)
                }
                ae.push(ac)
            }
            return ae
        }

        function a(l, b) {
            if (l[0] >= b[1]) {
                return false
            }
            if (b[0] >= l[1]) {
                return false
            }
            return true
        }
        MindFusion.registerClass(u, "MindFusion.Diagramming.Router")
    })(MindFusion.Diagramming);
    (function(c) {
        var l = MindFusion.Collections.ArrayList;
        var h = MindFusion.Geometry;
        var k = MindFusion.Graphs.Graph;
        var b = MindFusion.Drawing.GraphicsUnit;
        var d = MindFusion.Drawing.Rect;
        var j = MindFusion.Drawing.Point;
        var n = MindFusion.Collections.Set;
        var f = MindFusion.Collections.PriorityQueue;
        var g = MindFusion.Collections.Grid;
        var a = c.GridRouter = function(o) {
            mflayer.initializeBase(a, this, [o]);
            this.grid = new g();
            this.gridSize = 4;
            this.nodeVicinitySize = 12;
            this.crossingCost = 4;
            this.lengthCost = 2;
            this.nodeVicinityCost = 2;
            this.turnCost = 4
        };
        a.prototype = {
            routeInternal: function(t) {
                var u = t.getStartPoint();
                var v = t.getEndPoint();
                var p = this.aStar(this.diagramToGrid(u), this.diagramToGrid(v));
                if (p) {
                    var o = p.length - 1;
                    var s = p[0].y == p[1].y;
                    var q = p[o].y == p[o - 1].y;
                    for (var r = 0; r < p.length; r++) {
                        p[r] = this.gridToDiagram(p[r])
                    }
                    p[0] = u;
                    if (s) {
                        p[1].y = u.y
                    } else {
                        p[1].x = u.x
                    }
                    p[o] = v;
                    if (q) {
                        p[o - 1].y = v.y
                    } else {
                        p[o - 1].x = v.x
                    }
                }
                return p
            },
            nearestFree: function(p) {
                var o = [];
                o[0] = this.freeInDir(p, 1, 0);
                o[1] = this.freeInDir(p, 0, 1);
                o[2] = this.freeInDir(p, -1, 0);
                o[3] = this.freeInDir(p, 0, -1);
                var r = Number.MAX_VALUE;
                var s = null;
                for (var q = 0; q < 4; q++) {
                    if (r > o[q].d) {
                        r = o[q].d;
                        s = o[q]
                    }
                }
                return new j(s.x, s.y)
            },
            freeInDir: function(r, q, p) {
                var o = r.x;
                var t = r.y;
                var s = 0;
                while (this.grid.get(o, t) == 255) {
                    o += q;
                    t += p;
                    s++
                }
                return {
                    x: o,
                    y: t,
                    d: s
                }
            },
            aStar: function(I, z) {
                var B = I.clone();
                var E = z.clone();
                I = this.nearestFree(I);
                z = this.nearestFree(z);
                var S = this.grid;
                var P = new g(S.columns, S.rows);
                var J = new g(S.columns, S.rows);
                S.set(I.x, I.y, 0);
                S.set(z.x, z.y, 0);
                var G = new f(e);
                var H = [];
                var q = {
                    x: I.x,
                    y: I.y,
                    children: [],
                    g: 0,
                    h: this.routeHeuristics(I, z)
                };
                q.f = q.g + q.h;
                G.add(q);
                J.set(q.x, q.y, q);
                var w = this.lengthCost;
                var o = this.turnCost;
                var U = null;
                var p = false;
                while (true) {
                    if (G.empty()) {
                        break
                    }
                    var C = G.popMin();
                    J.set(C.x, C.y, null);
                    P.set(C.x, C.y, C);
                    U = C;
                    if (U.x == z.x && U.y == z.y) {
                        p = true;
                        break
                    }
                    var R = U.x;
                    var Q = U.y;
                    var T = [
                        [1, 0],
                        [0, 1],
                        [-1, 0],
                        [0, -1]
                    ];
                    for (var Y = 0; Y < 4; Y++) {
                        var W = R + T[Y][0];
                        var V = Q + T[Y][1];
                        if (W < 0 || V < 0 || W >= S.columns || V >= S.columns) {
                            continue
                        }
                        var A = S.get(W, V) || 0;
                        if (A == 255) {
                            continue
                        }
                        var Z = U.g + w + A;
                        var K = U.parent == null || (U.parent.y == U.y && T[Y][1] == 0) || (U.parent.x == U.x && T[Y][0] == 0);
                        if (!K) {
                            Z += o
                        }
                        var F = J.get(W, V);
                        if (F != null) {
                            U.children.push(F);
                            if (Z < F.g) {
                                F.parent = U;
                                F.g = Z;
                                F.f = Z + F.h;
                                G.changePriority(F)
                            }
                        } else {
                            F = P.get(W, V);
                            if (F != null) {
                                U.children.push(F);
                                if (Z < F.g) {
                                    F.parent = U;
                                    F.g = Z;
                                    F.f = Z + F.h;
                                    var M = F.children.length;
                                    var u;
                                    for (var X = 0; X < M; X++) {
                                        u = F.children[X];
                                        var t = w;
                                        K = F.parent == null || (F.parent.y == F.y && F.y == u.y) || (F.parent.x == F.x && F.x == u.x);
                                        if (!K) {
                                            t += o
                                        }
                                        if (Z + t < u.g) {
                                            var r = J.get(u.x, u.y) != null;
                                            u.g = Z + t;
                                            u.f = u.g + u.h;
                                            u.parent = F;
                                            H.push(u);
                                            if (r) {
                                                G.changePriority(u)
                                            }
                                        }
                                    }
                                    var s;
                                    while (H.length > 0) {
                                        s = H.pop();
                                        M = s.children.length;
                                        for (var X = 0; X < M; X++) {
                                            u = s.children[X];
                                            var t = w;
                                            K = s.parent == null || (s.parent.y == s.y && s.y == u.y) || (s.parent.x == s.x && s.x == u.x);
                                            if (!K) {
                                                t += o
                                            }
                                            if (s.g + t < u.g) {
                                                var r = J.get(u.x, u.y) != null;
                                                u.g = s.g + t;
                                                u.f = u.g + u.h;
                                                u.parent = s;
                                                H.push(u);
                                                if (r) {
                                                    G.changePriority(u)
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                var D = new j(W, V);
                                var v = {
                                    x: D.x,
                                    y: D.y,
                                    parent: U,
                                    children: [],
                                    g: Z,
                                    h: this.routeHeuristics(D, z)
                                };
                                v.f = v.g + v.h;
                                G.add(v);
                                J.set(v.x, v.y, v);
                                U.children.push(v)
                            }
                        }
                    }
                }
                if (p) {
                    var D = [];
                    D.push(E);
                    if (!z.equals(E)) {
                        D.push(z)
                    }
                    while (U != null) {
                        D.push(new j(U.x, U.y));
                        U = U.parent
                    }
                    if (!I.equals(B)) {
                        D.push(I)
                    }
                    D.push(B);
                    D.reverse();
                    var O, N, L;
                    for (var Y = 1; Y < D.length - 1;) {
                        O = D[Y - 1];
                        N = D[Y];
                        L = D[Y + 1];
                        if (O.x == N.x && N.x == L.x) {
                            D.splice(Y, 1)
                        } else {
                            if (O.y == N.y && N.y == L.y) {
                                D.splice(Y, 1)
                            } else {
                                Y++
                            }
                        }
                    }
                    return D
                }
                return null
            },
            routeHeuristics: function(p, o) {
                return j.distance(p, o)
            },
            cost: function(q, o) {
                var p = this.grid.get(q, o);
                return p || 0
            },
            markObstacles: function() {
                var M = this.diagram;
                var B = this.gridSize;
                var o = this.grid;
                var p = M.getContentBounds().union(M.getBounds());
                this.gridOffsetLeft = p.left();
                this.gridOffsetTop = p.top();
                var L = Math.floor(p.width / B);
                var C = Math.floor(p.height / B);
                o.clear();
                o.resize(L, C);
                for (var J = 0; J < M.nodes.length; J++) {
                    var I = M.nodes[J];
                    if (I.obstacle && !mflayer.isInstanceOfType(c.ContainerNode, I)) {
                        var s = I.getRotatedBounds();
                        var t = s.left() - p.left();
                        t = Math.floor(t / B);
                        var G = s.top() - p.top();
                        G = Math.floor(G / B);
                        var z = s.right() - p.left();
                        z = Math.ceil(z / B);
                        var q = s.bottom() - p.top();
                        q = Math.ceil(q / B);
                        for (var N = t; N <= z; N++) {
                            for (var D = G; D <= q; D++) {
                                o.set(N, D, 255)
                            }
                        }
                    }
                }
                for (var J = 0; J < M.nodes.length; J++) {
                    var I = M.nodes[J];
                    if (I.obstacle && !mflayer.isInstanceOfType(c.ContainerNode, I)) {
                        if (this.nodeVicinityCost == 0) {
                            continue
                        }
                        var s = I.getRotatedBounds();
                        var H = this.diagramToGrid(s.topLeft());
                        var A = this.diagramToGrid(s.bottomRight());
                        var w = Math.floor(this.nodeVicinitySize / this.gridSize);
                        for (var O = 1; O <= w; ++O) {
                            var K = this.nodeVicinityCost / O;
                            var F = Math.max(0, H.x - O);
                            var E = Math.min(L - 1, A.x + O);
                            var v = Math.max(0, H.y - O);
                            var u = Math.min(C - 1, A.y + O);
                            var D = H.y - O;
                            if (D >= 0) {
                                for (var N = F; N <= E; ++N) {
                                    if (this.cost(N, D) < K) {
                                        this.grid.set(N, D, K)
                                    }
                                }
                            }
                            D = A.y + O;
                            if (D <= u) {
                                for (var N = F; N <= E; ++N) {
                                    if (this.cost(N, D) < K) {
                                        this.grid.set(N, D, K)
                                    }
                                }
                            }
                            var N = H.x - O;
                            if (N >= 0) {
                                for (D = v; D <= u; ++D) {
                                    if (this.cost(N, D) < K) {
                                        this.grid.set(N, D, K)
                                    }
                                }
                            }
                            N = A.x + O;
                            if (N <= E) {
                                for (D = v; D <= u; ++D) {
                                    if (this.cost(N, D) < K) {
                                        this.grid.set(N, D, K)
                                    }
                                }
                            }
                        }
                    }
                }
            },
            diagramToGrid: function(p) {
                var o = p.x - this.gridOffsetLeft;
                o = Math.floor(o / this.gridSize);
                var q = p.y - this.gridOffsetTop;
                q = Math.floor(q / this.gridSize);
                return new j(o, q)
            },
            gridToDiagram: function(p) {
                var o = p.x * this.gridSize + this.gridSize / 2;
                o = o + this.gridOffsetLeft;
                var q = p.y * this.gridSize + this.gridSize / 2;
                q = q + this.gridOffsetTop;
                return new j(o, q)
            },
            setGridSize: function(o) {
                this.gridSize = o
            },
            getGridSize: function() {
                return this.gridSize
            },
            setNodeVicinitySize: function(o) {
                this.nodeVicinitySize = o
            },
            getNodeVicinitySize: function() {
                return this.nodeVicinitySize
            },
            setCrossingCost: function(o) {
                this.crossingCost = o
            },
            getCrossingCost: function() {
                return this.crossingCost
            },
            setLengthCost: function(o) {
                this.lengthCost = o
            },
            getLengthCost: function() {
                return this.lengthCost
            },
            setNodeVicinityCost: function(o) {
                this.nodeVicinityCost = o
            },
            getNodeVicinityCost: function() {
                return this.nodeVicinityCost
            },
            setTurnCost: function(o) {
                this.turnCost = o
            },
            getTurnCost: function() {
                return this.turnCost
            }
        };

        function e(p, o) {
            if (o == null) {
                return 1
            }
            if (p == o) {
                return 0
            }
            if (p.f > o.f) {
                return 1
            }
            if (p.f < o.f) {
                return -1
            }
            if (p.x > o.x) {
                return 1
            }
            if (p.x < o.x) {
                return -1
            }
            if (p.y > o.y) {
                return 1
            }
            if (p.y < o.y) {
                return -1
            }
            return 0
        }
        MindFusion.registerClass(a, "MindFusion.Diagramming.GridRouter", c.Router)
    })(MindFusion.Diagramming);
    MindFusion.registerNamespace("MindFusion.Diagramming.Lanes");
    MindFusion.Diagramming.Lanes.ResizeType = {
        Fixed: 0,
        Proportional: 1
    };
    (function(a) {
        var b = a.Cell = function(c) {
            mflayer.initializeBase(b, this);
            this.parent = c;
            this.style = new a.Style();
            this.text = ""
        };
        b.prototype = {
            setIndex: function(c, d) {
                this.column = c;
                this.row = d
            },
            getObjectToEdit: function() {
                return this
            },
            getTextToEdit: function() {
                return this.getText()
            },
            getEditRect: function(c) {
                return this.getInplaceEditBounds()
            },
            createEditArgs: function(c, d) {
                return new MindFusion.Diagramming.CellEventArgs({
                    cell: this,
                    oldText: c,
                    newText: d,
                    column: this.column,
                    row: this.row
                })
            },
            setEditedText: function(c) {
                this.setText(c)
            },
            getDiagramItem: function() {
                return null
            },
            fromJson: function(c) {
                if (c.style) {
                    this.style.fromJson(c.style)
                }
                this.text = c.text
            },
            toJson: function() {
                var c = {
                    style: this.style.toJson(),
                    text: this.text
                };
                return c
            },
            saveToXml: function(g, f) {
                var c = f.addChildElement("Style", g);
                this.style.saveToXml(c, f);
                f.writeString(this.text, "Text", g);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var d = {};
                    if (this.style.fontName) {
                        d.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        d.size = this.style.fontSize
                    }
                    f.writeFont(d, "Font", g)
                }
                if (this.style && (this.style.textAlignment != undefined || this.style.lineAlignment != undefined)) {
                    var e = {};
                    if (this.style.textAlignment !== undefined) {
                        e.alignment = this.style.textAlignment
                    }
                    if (this.style.lineAlignment != undefined) {
                        e.lineAlignment = this.style.lineAlignment
                    }
                    f.writeStringFormat(e, "Format", g)
                }
                if (this.style && this.style.textColor != undefined) {
                    f.writeColor(this.style.textColor, "Color", g)
                }
            },
            loadFromXml: function(h, g) {
                var c = g.selectSingleNode("Style", h);
                this.style.loadFromXml(c, g);
                this.text = g.readString("Text", h);
                var e = g.readFont("Font", h);
                if (e) {
                    if (e.name) {
                        this.style.fontName = e.name
                    }
                    if (e.size) {
                        this.style.fontSize = e.size
                    }
                }
                var f = g.readStringFormat("Format", h);
                if (f) {
                    if (f.alignment) {
                        this.style.textAlignment = f.alignment
                    }
                    if (f.lineAlignment) {
                        this.style.lineAlignment = f.lineAlignment
                    }
                }
                var d = g.readColor("Color", h);
                if (d) {
                    this.style.textColor = d
                }
            },
            getStyle: function() {
                return this.style
            },
            setStyle: function(c) {
                if (!c) {
                    throw new Error("The style of a cell cannot be null.")
                }
                if (this.style === c) {
                    return
                }
                this.style = c;
                this.parent.grid.invalidate()
            },
            getText: function() {
                return this.text
            },
            setText: function(c) {
                if (this.text === c) {
                    return
                }
                this.text = c;
                this.parent.grid.invalidate()
            },
            getInplaceEditBounds: function() {
                return this.inplaceEditBounds
            },
            setInplaceEditBounds: function(c) {
                this.inplaceEditBounds = c
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.Lanes.Cell")
    })(MindFusion.Diagramming.Lanes);
    (function(b) {
        var a = b.CellCluster = function(d, c, h, f, g) {
            mflayer.initializeBase(a, this);
            this.grid = d;
            var j = this;
            var e = function() {
                j.valid = false;
                j.grid.removeEventListener(b.Events.invalidated, e)
            };
            this.grid.addEventListener(b.Events.invalidated, e);
            this.columnStart = c;
            this.columnEnd = h;
            this.rowStart = f;
            this.rowEnd = g;
            this.valid = true
        };
        a.prototype = {
            getStyle: function() {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return new b.CellClusterStyle(this)
            },
            setStyle: function(e) {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var f = this.columnStart; f <= this.columnEnd; f++) {
                    for (var d = this.rowStart; d <= this.rowEnd; d++) {
                        this.grid.get(f, d).setStyle(e)
                    }
                }
            },
            getText: function() {
                if (!this.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return this.grid.get(this.columnStart, this.columnEnd).getText()
            },
            setText: function(e) {
                if (!valid) {
                    throw new InvalidOperationException("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var f = this.columnStart; f <= this.columnEnd; f++) {
                    for (var d = this.rowStart; d <= this.rowEnd; d++) {
                        this.grid.get(f, d).setText(e)
                    }
                }
            },
            getColumnStart: function() {
                return this.columnStart
            },
            getColumnEnd: function() {
                return this.columnEnd
            },
            getRowStart: function() {
                return this.rowStart
            },
            getRowEnd: function() {
                return this.rowEnd
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Lanes.CellCluster")
    })(MindFusion.Diagramming.Lanes);
    (function(b) {
        var a = b.CellClusterStyle = function(g, c, f, d, e) {
            mflayer.initializeBase(a, this);
            this.cellCluster = g;
            this.grid = g.grid;
            this.columnStart = g.columnStart;
            this.columnEnd = g.columnEnd;
            this.rowStart = g.rowStart;
            this.rowEnd = g.rowEnd
        };
        a.prototype = {
            getPropertyValue: function(c) {
                if (!this.cellCluster.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                return c.apply(this.grid.get(this.columnStart, this.rowStart).getStyle())
            },
            setPropertyValue: function(g, e) {
                if (!this.cellCluster.valid) {
                    throw new Error("Cannot query or modify the state of a cell cluster after its underlying grid's structure has changed.")
                }
                for (var f = this.columnStart; f <= this.columnEnd; f++) {
                    for (var d = this.rowStart; d <= this.rowEnd; d++) {
                        g.apply(this.grid.get(f, d).getStyle(), [e])
                    }
                }
            },
            getBackgroundBrush: function() {
                return this.getPropertyValue(b.Style.prototype.getBackgroundBrush)
            },
            setBackgroundBrush: function(c) {
                this.setPropertyValue(b.Style.prototype.setBackgroundBrush, c)
            },
            getLeftBorderPen: function() {
                return this.getPropertyValue(b.Style.prototype.getLeftBorderPen)
            },
            setLeftBorderPen: function(c) {
                this.setPropertyValue(b.Style.prototype.setLeftBorderPen, c)
            },
            getLeftBorderThickness: function() {
                return this.getPropertyValue(b.Style.prototype.getLeftBorderThickness)
            },
            setLeftBorderThickness: function(c) {
                this.setPropertyValue(b.Style.prototype.setLeftBorderThickness, c)
            },
            getTopBorderPen: function() {
                return this.getPropertyValue(b.Style.prototype.getTopBorderPen)
            },
            setTopBorderPen: function(c) {
                this.setPropertyValue(b.Style.prototype.setTopBorderPen, c)
            },
            getTopBorderThickness: function() {
                return this.getPropertyValue(b.Style.prototype.getTopBorderThickness)
            },
            setTopBorderThickness: function(c) {
                this.setPropertyValue(b.Style.prototype.setTopBorderThickness, c)
            },
            getRightBorderPen: function() {
                return this.getPropertyValue(b.Style.prototype.getRightBorderPen)
            },
            setRightBorderPen: function(c) {
                this.setPropertyValue(b.Style.prototype.setRightBorderPen, c)
            },
            getRightBorderThickness: function() {
                return this.getPropertyValue(b.Style.prototype.getRightBorderThickness)
            },
            setRightBorderThickness: function(c) {
                this.setPropertyValue(b.Style.prototype.setRightBorderThickness, c)
            },
            getBottomBorderPen: function() {
                return this.getPropertyValue(b.Style.prototype.getBottomBorderPen)
            },
            setBottomBorderPen: function(c) {
                this.setPropertyValue(b.Style.prototype.setBottomBorderPen, c)
            },
            getBottomBorderThickness: function() {
                return this.getPropertyValue(b.Style.prototype.getBottomBorderThickness)
            },
            setBottomBorderThickness: function(c) {
                this.setPropertyValue(b.Style.prototype.setBottomBorderThickness, c)
            },
            getTextColor: function() {
                return this.getPropertyValue(b.Style.prototype.getTextColor)
            },
            setTextColor: function(c) {
                this.setPropertyValue(b.Style.prototype.setTextColor, c)
            },
            getFontName: function() {
                return this.getPropertyValue(b.Style.prototype.getFontName)
            },
            setFontName: function(c) {
                this.setPropertyValue(b.Style.prototype.setFontName, c)
            },
            getFontSize: function() {
                return this.getPropertyValue(b.Style.prototype.getFontSize)
            },
            setFontSize: function(c) {
                this.setPropertyValue(b.Style.prototype.setFontSize, c)
            },
            getTextAlignment: function() {
                return this.getPropertyValue(b.Style.prototype.getTextAlignment)
            },
            setTextAlignment: function(c) {
                this.setPropertyValue(b.Style.prototype.setTextAlignment, c)
            },
            getLineAlignment: function() {
                return this.getPropertyValue(b.Style.prototype.getLineAlignment)
            },
            setLineAlignment: function(c) {
                this.setPropertyValue(b.Style.prototype.setLineAlignment, c)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Lanes.CellClusterStyle")
    })(MindFusion.Diagramming.Lanes);
    (function(a) {
        var b = a.CellMatrix = function(c) {
            mflayer.initializeBase(b, this);
            this.grid = c;
            this.data = [
                []
            ];
            this.rowCount = 0;
            this.columnCount = 0
        };
        b.prototype = {
            fromJson: function(e) {
                this.data = [];
                this.rowCount = e.rowCount;
                this.columnCount = e.columnCount;
                var f;
                for (var d = 0; d < e.data.length; d++) {
                    if (d % this.rowCount === 0) {
                        if (f) {
                            this.data.push(f)
                        }
                        f = []
                    }
                    var c = new a.Cell(this);
                    c.fromJson(e.data[d]);
                    f.push(c)
                }
                if (e.data.length > 0) {
                    this.data.push(f)
                }
            },
            toJson: function() {
                var c = {
                    data: this.serializeData(),
                    rowCount: this.rowCount,
                    columnCount: this.columnCount
                };
                return c
            },
            saveToXml: function(g, f) {
                g.setAttribute("ColumnCount", this.columnCount);
                g.setAttribute("RowCount", this.rowCount);
                for (var k = 0, e = this.columnCount; k < e; k++) {
                    for (var h = 0, j = this.rowCount; h < j; h++) {
                        var d = f.addChildElement("Cell", g);
                        d.setAttribute("Row", h);
                        d.setAttribute("Column", k);
                        this.data[k][h].saveToXml(d, f)
                    }
                }
            },
            loadFromXml: function(g, f) {
                this.columnCount = parseInt(g.getAttribute("ColumnCount"));
                this.rowCount = parseInt(g.getAttribute("RowCount"));
                this.data = [];
                for (var e = 0; e < this.columnCount; e++) {
                    this.data.push([])
                }
                var j = f.selectNodes("Cell", g);
                for (var e = 0; e < j.length; e++) {
                    var d = new a.Cell(this);
                    d.loadFromXml(j[e], f);
                    var k = parseInt(j[e].getAttribute("Column"));
                    var h = parseInt(j[e].getAttribute("Row"));
                    this.data[k][h] = d
                }
            },
            serializeData: function() {
                var d = [];
                for (var h = 0, e = this.columnCount; h < e; h++) {
                    for (var f = 0, g = this.rowCount; f < g; f++) {
                        d.push(this.data[h][f].toJson())
                    }
                }
                return d
            },
            insertColumns: function(e, h) {
                if (h <= 0) {
                    return
                }
                var d = this.getRowCount();
                for (var j = 0; j < h; j++) {
                    var f = [];
                    for (var g = 0; g < d; g++) {
                        f.push(new a.Cell(this))
                    }
                    this.data.splice(e + j, 0, f)
                }
                this.columnCount += h
            },
            insertRows: function(d, f) {
                if (f <= 0) {
                    return
                }
                var g = this.getColumnCount();
                for (var h = 0; h < g; h++) {
                    for (var e = 0; e < f; e++) {
                        this.data[h].splice(d + e, 0, new a.Cell(this))
                    }
                }
                this.rowCount += f
            },
            removeColumns: function(c, d) {
                if (d <= 0) {
                    return
                }
                this.data.splice(c, d);
                this.columnCount -= d
            },
            removeRows: function(d, e) {
                if (e <= 0) {
                    return
                }
                var f = this.getColumnCount();
                for (var g = 0; g < f; g++) {
                    this.data[g].splice(d, e)
                }
                this.rowCount -= e
            },
            get: function(c, d) {
                return this.data[c][d]
            },
            getColumnCount: function() {
                return this.columnCount
            },
            getRowCount: function() {
                return this.rowCount
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.Lanes.CellMatrix")
    })(MindFusion.Diagramming.Lanes);
    MindFusion.Diagramming.Lanes.Events = {
        invalidated: "invalidated"
    };
    (function(e) {
        var b = MindFusion.Drawing.Rect;
        var d = MindFusion.Drawing.Point;
        var c = MindFusion.Collections.Dictionary;
        var a = e.Grid = function(f) {
            mflayer.initializeBase(a, this);
            this.parent = f;
            this.columnHeader = new e.MasterHeader(this, false);
            this.rowHeader = new e.MasterHeader(this, true);
            this.leftMargin = 0;
            this.topMargin = 0;
            this.minHeaderSize = 10;
            this.topLeftAreaText = "";
            this.allowInplaceEdit = false;
            this.allowResizeHeaders = true;
            this.hookHeaders = true;
            this.headersOnTop = true;
            this.rowWidths = [];
            this.columnHeights = [];
            this.cells = new e.CellMatrix(this);
            this.style = new e.Style();
            this.style.setLeftBorderThickness(1);
            this.style.setTopBorderThickness(1);
            this.style.setRightBorderThickness(1);
            this.style.setBottomBorderThickness(1);
            this.style.setTextAlignment(MindFusion.Diagramming.Alignment.Center);
            this.style.setLineAlignment(MindFusion.Diagramming.Alignment.Center);
            this.eventHandlers = mflayer.eventHandlerList()
        };
        a.prototype = {
            fromJson: function(f) {
                this.columnHeader.fromJson(f.columnHeader);
                this.rowHeader.fromJson(f.rowHeader);
                this.leftMargin = f.leftMargin;
                this.topMargin = f.topMargin;
                this.minHeaderSize = f.minHeaderSize;
                this.topLeftAreaText = f.topLeftAreaText;
                this.hookHeaders = f.hookHeaders;
                this.headersOnTop = f.headersOnTop;
                this.rowWidths = f.rowWidths;
                this.columnHeights = f.columnHeights;
                if (f.allowResizeHeaders != undefined) {
                    this.allowResizeHeaders = f.allowResizeHeaders
                }
                if (f.style) {
                    this.style.fromJson(f.style)
                }
                this.cells.fromJson(f.cells);
                this.raiseEvent(e.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            toJson: function() {
                var f = {
                    columnHeader: this.columnHeader.toJson(),
                    rowHeader: this.rowHeader.toJson(),
                    leftMargin: this.leftMargin,
                    topMargin: this.topMargin,
                    minHeaderSize: this.minHeaderSize,
                    topLeftAreaText: this.topLeftAreaText,
                    hookHeaders: this.hookHeaders,
                    headersOnTop: this.headersOnTop,
                    rowWidths: this.rowWidths,
                    columnHeights: this.columnHeights,
                    allowResizeHeaders: this.allowResizeHeaders,
                    style: this.style.toJson(),
                    cells: this.cells.toJson()
                };
                return f
            },
            saveToXml: function(k, h) {
                h.writeFloat(this.leftMargin, "LeftMargin", k);
                h.writeFloat(this.topMargin, "TopMargin", k);
                h.writeFloat(this.minHeaderSize, "MinHeaderSize", k);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var g = {};
                    if (this.style.fontName) {
                        g.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        g.size = this.style.fontSize
                    }
                    h.writeFont(g, "DefaultFont", k)
                }
                h.writeBool(this.hookHeaders, "HookHeaders", k);
                h.writeBool(this.headersOnTop, "HeadersOnTop", k);
                h.writeFloatArray(this.rowWidths, "RowWidths", "Width", k);
                h.writeFloatArray(this.columnHeights, "ColumnHeights", "Height", k);
                h.writeBool(this.allowResizeHeaders, "AllowResizeHeaders", k);
                var l = h.addChildElement("Columns", k);
                this.columnHeader.saveToXml(l, h);
                var j = h.addChildElement("Rows", k);
                this.rowHeader.saveToXml(j, h);
                var f = h.addChildElement("Cells", k);
                this.cells.saveToXml(f, h)
            },
            loadFromXml: function(k, h) {
                this.leftMargin = h.readFloat("LeftMargin", k);
                this.topMargin = h.readFloat("TopMargin", k);
                this.minHeaderSize = h.readFloat("MinHeaderSize", k);
                var g = h.readFont("DefaultFont", k);
                if (g) {
                    if (g.name) {
                        this.style.fontName = g.name
                    }
                    if (g.size) {
                        this.style.fontSize = g.size
                    }
                }
                this.hookHeaders = h.readBool("HookHeaders", k);
                this.headersOnTop = h.readBool("HeadersOnTop", k);
                this.rowWidths = h.readFloatArray("RowWidths", "Width", k);
                this.columnHeights = h.readFloatArray("ColumnHeights", "Height", k);
                this.allowResizeHeaders = h.readBool("AllowResizeHeaders", k);
                var l = h.selectSingleNode("Columns", k);
                this.columnHeader.loadFromXml(l, h);
                var j = h.selectSingleNode("Rows", k);
                this.rowHeader.loadFromXml(j, h);
                var f = h.selectSingleNode("Cells", k);
                this.cells.loadFromXml(f, h)
            },
            addEventListener: function(f, g) {
                mflayer.addHandler(this, f, g)
            },
            removeEventListener: function(f, g) {
                mflayer.removeHandler(this, f, g)
            },
            raiseEvent: function(f, g) {
                var h = mflayer.getHandler(this, f);
                if (h) {
                    h(this, g)
                }
            },
            addColumnHeader: function(k, j, f) {
                if (k.getParent()) {
                    throw new Error("Cannot add a header to more than one parent header at a time.")
                }
                if (!j) {
                    j = this.columnHeader
                }
                if (!j.isColumnHeader()) {
                    throw new Error("The specified header is not a column header.")
                }
                var h = j;
                while (h) {
                    if (k === h) {
                        throw new Error("Cannot add a header to itself or as a direct or indirect child to any of its children.")
                    }
                    h = h.parent
                }
                k.setParent(j);
                var g = j.getSubHeaders();
                if (!f) {
                    g.push(k)
                } else {
                    g.splice(f, 0, k)
                }
                this.onColumnHeaderAdded(k);
                this.invalidate()
            },
            onColumnHeaderAdded: function(h) {
                var f = this.getIndex(h);
                var g = h.getDeepChildCount();
                if (h.getParent().getSubHeaders().length === 1) {
                    if (h.getParent() !== this.columnHeader) {
                        g -= 1
                    }
                }
                this.cells.insertColumns(f, g);
                if (h.getParent().getSubHeaders().length === 1) {
                    h.ensureWidth(Math.max(this.minHeaderSize, h.getParent().getWidth()))
                } else {
                    h.ensureWidth(this.minHeaderSize)
                }
                if (h.getHeight() === 0) {
                    h.height = 20
                }
                this.raiseEvent(e.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            removeColumnHeader: function(j) {
                var h = j.getParent();
                if (!h) {
                    return
                }
                if (!j.isColumnHeader()) {
                    throw new Error("The specified header is not a column header.")
                }
                var g = h.getSubHeaders();
                var f = g.indexOf(j);
                this.onColumnHeaderRemoved(j);
                j.setParent();
                g.splice(f, 1);
                this.invalidate()
            },
            onColumnHeaderRemoved: function(h) {
                var f = this.getIndex(h);
                var g = h.getDeepChildCount();
                if (h.getParent().getSubHeaders().length === 1) {
                    if (h.getParent() !== this.columnHeader) {
                        g -= 1
                    }
                }
                if (h.getParent().getSubHeaders().length === 1 && h.getParent() !== this.columnHeader) {
                    h.getParent().setWidth(h.getWidth())
                }
                h.zeroWidth();
                h.zeroHeight();
                this.cells.removeColumns(f, g);
                this.raiseEvent(e.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            addRowHeader: function(k, j, f) {
                if (k.getParent()) {
                    throw new Error("Cannot add a header to more than one parent header at a time.")
                }
                if (!j) {
                    j = this.rowHeader
                }
                if (!j.isRowHeader()) {
                    throw new Error("The specified header is not a row header.")
                }
                var h = j;
                while (h) {
                    if (k === h) {
                        throw new Error("Cannot add a header to itself or as a direct or indirect child to any of its children.")
                    }
                    h = h.parent
                }
                k.setParent(j);
                var g = j.getSubHeaders();
                if (isNaN(f) || f < 0 || f > g.length) {
                    g.push(k)
                } else {
                    g.splice(f, 0, k)
                }
                this.onRowHeaderAdded(k);
                this.invalidate()
            },
            onRowHeaderAdded: function(h) {
                var f = this.getIndex(h);
                var g = h.getDeepChildCount();
                if (h.getParent().getSubHeaders().length === 1) {
                    if (h.getParent() !== this.rowHeader) {
                        g -= 1
                    }
                }
                this.cells.insertRows(f, g);
                if (h.getParent().getSubHeaders().length === 1) {
                    h.ensureHeight(Math.max(this.minHeaderSize, h.getParent().getHeight()))
                } else {
                    h.ensureHeight(this.minHeaderSize)
                }
                if (h.getWidth() === 0) {
                    h.width = 20
                }
                this.raiseEvent(e.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            removeRowHeader: function(j) {
                var h = j.getParent();
                if (!h) {
                    return
                }
                if (!j.isRowHeader()) {
                    throw new Error("The specified header is not a row header.")
                }
                var g = h.getSubHeaders();
                var f = g.indexOf(j);
                this.onRowHeaderRemoved(j);
                j.setParent();
                g.splice(f, 1);
                this.invalidate()
            },
            onRowHeaderRemoved: function(h) {
                var f = this.getIndex(h);
                var g = h.getDeepChildCount();
                if (h.getParent().getSubHeaders().length === 1) {
                    if (h.getParent() !== this.rowHeader) {
                        g -= 1
                    }
                }
                if (h.getParent().getSubHeaders().length === 1 && h.getParent() !== this.rowHeader) {
                    h.getParent().setHeight(h.getHeight())
                }
                h.zeroWidth();
                h.zeroHeight();
                this.cells.removeRows(f, g);
                this.raiseEvent(e.Events.invalidated, MindFusion.EventArgs.Empty)
            },
            findColumn: function(f) {
                return this.findHeader(this.columnHeader.getSubHeaders(), f)
            },
            findRow: function(f) {
                return this.findHeader(this.rowHeader.getSubHeaders(), f)
            },
            findHeader: function(j, h) {
                for (var g = 0; g < j.length; g++) {
                    var k = j[g];
                    if (k.getTitle() == h) {
                        return k
                    }
                    var f = this.findHeader(k.getSubHeaders(), h);
                    if (f) {
                        return f
                    }
                }
            },
            getIndex: function(f) {
                if (!f.getParent()) {
                    return 0
                }
                return this.getIndex(f.getParent()) + this.getLocalIndex(f)
            },
            getLocalIndex: function(k) {
                var g = 0;
                for (var h = 0, f = k.getParent().getSubHeaders().length; h < f; h++) {
                    var j = k.getParent().getSubHeaders()[h];
                    if (j === k) {
                        break
                    }
                    g += j.getDeepChildCount()
                }
                return g
            },
            getRowLevelCount: function(f) {
                return this.getLevelCount(this.rowHeader.getSubHeaders(), f, 0)
            },
            getColumnLevelCount: function(f) {
                return this.getLevelCount(this.columnHeader.getSubHeaders(), f, 0)
            },
            getLevelCount: function(j, l, h) {
                if (l === h) {
                    return j.length
                }
                if (l < h) {
                    return 0
                }
                var g = 0;
                for (var f = 0; f < j.length; f++) {
                    var k = j[f];
                    g += this.getLevelCount(k.getSubHeaders(), l, h + 1)
                }
                return g
            },
            getRowDepth: function(f) {
                return this.getDepth(this.rowHeader.getSubHeaders(), f)
            },
            getColumnDepth: function(f) {
                return this.getDepth(this.columnHeader.getSubHeaders(), f)
            },
            getDepth: function(j, f) {
                if (j.length === 0) {
                    return 0
                }
                if (j.length === 1) {
                    if (j[0] === f) {
                        return 0
                    }
                }
                var h = 0;
                for (var g = 0; g < j.length; g++) {
                    var k = j[g];
                    if (k === f) {
                        continue
                    }
                    h = Math.max(h, this.getDepth(k.getSubHeaders(), f))
                }
                return h + 1
            },
            collectHeights: function(l, k, o) {
                if (k.length <= o) {
                    k.push(0)
                }
                var j = 0;
                var g = false;
                if (o < this.columnHeights.length) {
                    var f = this.columnHeights[o];
                    if (f > 0) {
                        g = true;
                        j = f
                    }
                }
                var h;
                if (!g) {
                    j = k[o];
                    for (h = 0; h < l.length; h++) {
                        var n = l[h];
                        if (j < n.getHeight()) {
                            j = n.getHeight()
                        }
                    }
                }
                for (h = 0; h < l.length; h++) {
                    this.collectHeights(l[h].getSubHeaders(), k, o + 1)
                }
                k[o] = j
            },
            getTotalColumnHeightIf: function(k, f) {
                var j = [];
                this.collectHeightsIf(this.columnHeader.getSubHeaders(), k, f, j, 0);
                var h = 0;
                for (var g = 0; g < j.length; g++) {
                    h += j[g]
                }
                return h
            },
            collectHeightsIf: function(h, l, g, n, f) {
                if (n.length <= f) {
                    n.push(0)
                }
                var p = 0;
                var o = false;
                var q;
                if (f < this.columnHeights.length) {
                    q = this.columnHeights[f];
                    if (q > 0) {
                        o = true;
                        p = q
                    }
                }
                var j;
                if (!o) {
                    p = n[f];
                    for (j = 0; j < h.length; j++) {
                        var k = h[j];
                        q = k.getHeight();
                        if (k === l) {
                            q = g
                        }
                        if (p < q) {
                            p = q
                        }
                    }
                }
                for (j = 0; j < h.length; j++) {
                    this.collectHeightsIf(h[j].getSubHeaders(), l, g, n, f + 1)
                }
                n[f] = p
            },
            collectWidths: function(l, j, o) {
                if (j.length <= o) {
                    j.push(0)
                }
                var h = 0;
                var k = false;
                if (o < this.rowWidths.length) {
                    var g = this.rowWidths[o];
                    if (g > 0) {
                        k = true;
                        h = g
                    }
                }
                var f;
                if (!k) {
                    h = j[o];
                    for (f = 0; f < l.length; f++) {
                        var n = l[f];
                        if (h < n.getWidth()) {
                            h = n.getWidth()
                        }
                    }
                }
                for (f = 0; f < l.length; f++) {
                    this.collectWidths(l[f].getSubHeaders(), j, o + 1)
                }
                j[o] = h
            },
            getTotalRowWidthIf: function(k, h) {
                var j = [];
                this.collectWidthsIf(this.rowHeader.getSubHeaders(), k, h, j, 0);
                var f = 0;
                for (var g = 0; g < j.length; g++) {
                    f += j[g]
                }
                return f
            },
            collectWidthsIf: function(h, o, p, j, f) {
                if (j.length <= f) {
                    j.push(0)
                }
                var q = 0;
                var n = false;
                var g;
                if (f < this.rowWidths.length) {
                    g = this.rowWidths[f];
                    if (g > 0) {
                        n = true;
                        q = g
                    }
                }
                var k;
                if (!n) {
                    q = j[f];
                    for (k = 0; k < h.length; k++) {
                        var l = h[k];
                        g = l.getWidth();
                        if (l === o) {
                            g = p
                        }
                        if (q < g) {
                            q = g
                        }
                    }
                }
                for (k = 0; k < h.length; k++) {
                    this.collectWidthsIf(h[k].getSubHeaders(), o, p, j, f + 1)
                }
                j[f] = q
            },
            getDepth: function(g) {
                if (g.length === 0) {
                    return 0
                }
                var h = 0;
                for (var f = 0; f < g.length; f++) {
                    h = Math.max(h, this.getDepth(g[f].getSubHeaders()))
                }
                return h + 1
            },
            getColumnLevelHeight: function(n, k, j) {
                if (!k) {
                    if (n < this.columnHeights.length) {
                        var f = this.columnHeights[n];
                        if (f > 0) {
                            return f
                        }
                    }
                    k = this.columnHeader.getSubHeaders()
                }
                if (!j) {
                    j = 0
                }
                var h = 0;
                var g;
                if (n === j) {
                    for (g = 0; g < k.length; g++) {
                        var l = k[g];
                        if (h < l.getHeight()) {
                            h = l.getHeight()
                        }
                    }
                    return h
                }
                for (g = 0; g < k.length; g++) {
                    h = Math.max(h, this.getColumnLevelHeight(n, k[g].getSubHeaders(), j + 1))
                }
                return h
            },
            getRowLevelWidth: function(n, k, j) {
                if (!k) {
                    if (n < this.rowWidths.length) {
                        var g = this.rowWidths[n];
                        if (g > 0) {
                            return g
                        }
                    }
                    k = this.rowHeader.getSubHeaders()
                }
                if (!j) {
                    j = 0
                }
                var h = 0;
                var f;
                if (n === j) {
                    for (f = 0; f < k.length; f++) {
                        var l = k[f];
                        if (h < l.getWidth()) {
                            h = l.getWidth()
                        }
                    }
                    return h
                }
                for (f = 0; f < k.length; f++) {
                    h = Math.max(h, this.getRowLevelWidth(n, k[f].getSubHeaders(), j + 1))
                }
                return h
            },
            collectHeaderBounds: function(h, f, g) {
                if (h === g.header) {
                    g.bounds = f
                } else {
                    if (g.includeSubHeaders) {
                        if (h.isDescendantOf(g.header)) {
                            g.bounds = f.union(g.bounds)
                        }
                    }
                }
            },
            removeLastChildDeep: function(g) {
                if (g.getSubHeaders().length === 0) {
                    return
                }
                var f = g.getSubHeaders()[g.getSubHeaders().length - 1];
                if (f.getSubHeaders().length === 0) {
                    if (g.isColumnHeader()) {
                        this.removeColumnHeader(f)
                    } else {
                        this.removeRowHeader(f)
                    }
                    this.ensureNonEmpty(g);
                    return
                }
                this.removeLastChildDeep(f)
            },
            ensureNonEmpty: function(g) {
                if (g.getSubHeaders().length > 0) {
                    return
                }
                var f = g.getParent();
                if (!f) {
                    return
                }
                if (g.isRowHeader()) {
                    this.removeRowHeader(g)
                } else {
                    this.removeColumnHeader(g)
                }
                this.ensureNonEmpty(f)
            },
            getHeaderBounds: function(n, g) {
                var h = {
                    header: n,
                    includeSubHeaders: g
                };
                var l = this;
                var k = function(q, o, p) {
                    l.collectHeaderBounds(q, o, p)
                };
                var f = 0;
                var j = 0;
                if (this.hookHeaders && this.parent.getScrollX && this.parent.getScrollY) {
                    f = this.parent.getScrollX();
                    j = this.parent.getScrollY()
                }
                this.processRowHeaders(k, f, j, h);
                this.processColumnHeaders(k, f, j, h);
                return h.bounds
            },
            getColumnHeaderBounds: function() {
                return this.getHeaderBounds(this.columnHeader, true)
            },
            getRowHeaderBounds: function() {
                return this.getHeaderBounds(this.rowHeader, true)
            },
            getCellBounds: function(w) {
                var h = -1;
                var t = -1;
                var k = -1;
                var p = -1;
                if (w.getColumnStart && w.getColumnEnd && w.getRowStart && w.getRowEnd) {
                    h = w.getColumnStart();
                    t = w.getColumnEnd();
                    k = w.getRowStart();
                    p = w.getRowEnd()
                } else {
                    for (var q = 0, v = this.cells.getColumnCount(); q < v; q++) {
                        for (var f = 0, o = this.cells.getRowCount(); f < o; f++) {
                            if (this.cells.get(q, f) == w) {
                                h = q;
                                t = q;
                                k = f;
                                p = f;
                                break
                            }
                        }
                        if (h !== -1) {
                            break
                        }
                    }
                }
                if (h !== -1) {
                    var u = this.leftMargin + this.getTotalRowWidth();
                    var s = this.topMargin + this.getTotalColumnHeight();
                    var g = 0;
                    var z = 0;
                    var n;
                    var l;
                    for (n = 0; n < h; n++) {
                        u += this.getColumn(n).getWidth()
                    }
                    for (l = 0; l < k; l++) {
                        s += this.getRow(l).getHeight()
                    }
                    for (n = h; n <= t; n++) {
                        g += this.getColumn(n).getWidth()
                    }
                    for (l = k; l <= p; l++) {
                        z += this.getRow(l).getHeight()
                    }
                    return new b(u, s, g, z)
                }
                return b.empty
            },
            getColumnHeaders: function() {
                return this.columnHeader.getSubHeaders()
            },
            getRowHeaders: function() {
                return this.rowHeader.getSubHeaders()
            },
            getColumnCount: function() {
                var h = 0;
                var j = this.columnHeader.getSubHeaders();
                for (var g = 0, f = j.length; g < f; g++) {
                    var k = j[g];
                    h += k.getDeepChildCount()
                }
                return h
            },
            setColumnCount: function(h) {
                if (h < 0) {
                    return
                }
                var j = this.getColumnCount();
                if (h === j) {
                    return
                }
                if (h > j) {
                    for (var g = 0; g < h - j; g++) {
                        this.addColumnHeader(new e.Header(), this.columnHeader)
                    }
                }
                if (h < j) {
                    var f = j - h;
                    while (f > 0) {
                        this.removeLastChildDeep(this.columnHeader);
                        f--
                    }
                }
            },
            getRowCount: function() {
                var h = 0;
                var j = this.rowHeader.getSubHeaders();
                for (var g = 0, f = j.length; g < f; g++) {
                    var k = j[g];
                    h += k.getDeepChildCount()
                }
                return h
            },
            setRowCount: function(j) {
                if (j < 0) {
                    return
                }
                var f = this.getRowCount();
                if (j == f) {
                    return
                }
                if (j > f) {
                    for (var g = 0; g < j - f; g++) {
                        this.addRowHeader(new e.Header(), this.rowHeader)
                    }
                }
                if (j < f) {
                    var h = f - j;
                    while (h > 0) {
                        this.removeLastChildDeep(this.rowHeader);
                        h--
                    }
                }
            },
            get: function(h, n) {
                if (!isNaN(h) && !isNaN(n)) {
                    return this.cells.get(h, n)
                }
                if (n && n.getSubHeaders && n.getSubHeaders().length === 0 && h && h.getSubHeaders && h.getSubHeaders().length === 0) {
                    var g = this.getIndex(h);
                    var o = this.getIndex(n);
                    return this.cells.get(g, o)
                } else {
                    if (!h || !h.getSubHeaders) {
                        h = this.columnHeader
                    }
                    if (!n || !n.getSubHeaders) {
                        n = this.rowHeader
                    }
                    var l = this.getIndex(h);
                    var j = l + h.getDeepChildCount() - 1;
                    var k = this.getIndex(n);
                    var f = k + n.getDeepChildCount() - 1;
                    return new e.CellCluster(this, l, j, k, f)
                }
            },
            getLeftMargin: function() {
                return this.leftMargin
            },
            setLeftMargin: function(f) {
                if (this.leftMargin === f) {
                    return
                }
                this.leftMargin = f;
                this.invalidate()
            },
            getTopMargin: function() {
                return this.topMargin
            },
            setTopMargin: function(f) {
                if (this.topMargin === f) {
                    return
                }
                this.topMargin = f;
                this.invalidate()
            },
            getMinHeaderSize: function() {
                return this.minHeaderSize
            },
            setMinHeaderSize: function(h) {
                if (h <= 0) {
                    return
                }
                if (this.minHeaderSize === h) {
                    return
                }
                this.minHeaderSize = h;
                for (var g = 0, f = this.columnHeader.getSubHeaders().length; g < f; g++) {
                    var j = this.columnHeader.getSubHeaders()[g];
                    j.ensureWidth(this.minHeaderSize)
                }
            },
            getTotalColumnHeight: function() {
                var h = [];
                this.collectHeights(this.columnHeader.getSubHeaders(), h, 0);
                var g = 0;
                for (var f = 0; f < h.length; f++) {
                    g += h[f]
                }
                return g
            },
            getTotalRowWidth: function() {
                var h = [];
                this.collectWidths(this.rowHeader.getSubHeaders(), h, 0);
                var f = 0;
                for (var g = 0; g < h.length; g++) {
                    f += h[g]
                }
                return f
            },
            getColumnDepth: function() {
                return this.getDepth(this.columnHeader.getSubHeaders())
            },
            getRowDepth: function() {
                return this.getDepth(this.rowHeader.getSubHeaders())
            },
            getTopLeftAreaStyle: function() {
                return this.topLeftAreaStyle
            },
            setTopLeftAreaStyle: function(f) {
                if (this.topLeftAreaStyle === f) {
                    return
                }
                this.topLeftAreaStyle = f;
                this.invalidate()
            },
            getTopLeftAreaText: function() {
                return this.topLeftAreaText
            },
            setTopLeftAreaText: function(f) {
                if (this.topLeftAreaText === f) {
                    return
                }
                this.topLeftAreaText = f;
                this.invalidate()
            },
            getHookHeaders: function() {
                return this.hookHeaders
            },
            setHookHeaders: function(f) {
                if (this.hookHeaders === f) {
                    return
                }
                this.hookHeaders = f;
                this.invalidate()
            },
            getHeadersOnTop: function() {
                return this.headersOnTop
            },
            setHeadersOnTop: function(f) {
                if (this.headersOnTop === f) {
                    return
                }
                this.headersOnTop = f;
                this.invalidate()
            },
            getRowHeadersWidths: function() {
                return this.rowWidths
            },
            setRowHeadersWidths: function(f) {
                if (!f) {
                    throw new Error("The row widths array cannot be null.")
                }
                this.rowWidths = f;
                this.invalidate()
            },
            getColumnHeadersHeights: function() {
                return this.columnHeights
            },
            setColumnHeadersHeights: function(f) {
                if (!f) {
                    throw new Error("The row widths array cannot be null.")
                }
                this.columnHeights = f;
                this.invalidate()
            },
            processColumnHeaders: function(g, v, u, F) {
                var r = this.getTotalColumnHeight();
                var B = this.getTotalRowWidth();
                var I = this.getColumnDepth();
                var n = this.topMargin;
                var t = [];
                var z = new c();
                var C;
                for (var D = 0, w = this.columnHeader.getSubHeaders().length; D < w; D++) {
                    C = this.columnHeader.getSubHeaders()[D];
                    t.push(C);
                    z.set(C, n)
                }
                var f = 0;
                while (t.length > 0) {
                    var o = this.leftMargin + B;
                    var G = this.getColumnLevelHeight(f);
                    var s = [];
                    var H = new c();
                    for (var D = 0; D < t.length; D++) {
                        var C = t[D];
                        if (C.getSubHeaders().length === 0) {
                            if (f !== I - 1) {
                                s.push(C);
                                H.set(C, z.get(C));
                                o += C.getWidth();
                                continue
                            }
                        }
                        var q = o;
                        var p = z.get(C);
                        var k = new MindFusion.Drawing.Rect(q, p, C.getWidth(), n + G - p);
                        k.y += u;
                        g(C, k, F);
                        o += C.getWidth();
                        for (var A = 0, E = C.getSubHeaders().length; A < E; A++) {
                            var h = C.getSubHeaders()[A];
                            s.push(h);
                            H.set(h, n + G)
                        }
                    }
                    n += G;
                    f++;
                    t = s;
                    z = H
                }
            },
            processRowHeaders: function(g, w, v, G) {
                var s = this.getTotalColumnHeight();
                var C = this.getTotalRowWidth();
                var I = this.getRowDepth();
                var p = this.leftMargin;
                var u = [];
                var A = new c();
                var D;
                for (var E = 0, z = this.rowHeader.getSubHeaders().length; E < z; E++) {
                    var D = this.rowHeader.getSubHeaders()[E];
                    u.push(D);
                    A.set(D, p)
                }
                var f = 0;
                while (u.length > 0) {
                    var o = this.topMargin + s;
                    var k = this.getRowLevelWidth(f);
                    var t = [];
                    var H = new c();
                    for (var E = 0; E < u.length; E++) {
                        var D = u[E];
                        if (D.getSubHeaders().length === 0) {
                            if (f !== I - 1) {
                                t.push(D);
                                H.set(D, A.get(D));
                                o += D.getHeight();
                                continue
                            }
                        }
                        var r = A.get(D);
                        var q = o;
                        var n = new MindFusion.Drawing.Rect(r, q, p + k - r, D.getHeight());
                        n.x += w;
                        g(D, n, G);
                        o += D.getHeight();
                        for (var B = 0, F = D.getSubHeaders().length; B < F; B++) {
                            var h = D.getSubHeaders()[B];
                            t.push(h);
                            H.set(h, p + k)
                        }
                    }
                    p += k;
                    f++;
                    u = t;
                    A = H
                }
            },
            drawFirst: function(f) {
                this.drawCells(f);
                if (!this.headersOnTop) {
                    this.drawHeaders(f)
                }
            },
            drawLast: function(f) {
                if (this.headersOnTop) {
                    this.drawHeaders(f)
                }
            },
            drawHeaders: function(g) {
                var h = {
                    context: g
                };
                var l = this;
                var k = function(p, n, o) {
                    l.drawHeader(p, n, o)
                };
                var f = 0;
                var j = 0;
                if (this.hookHeaders && this.parent.getScrollX && this.parent.getScrollY) {
                    f = this.parent.getScrollX();
                    j = this.parent.getScrollY()
                }
                this.processColumnHeaders(k, f, j, h);
                this.processRowHeaders(k, f, j, h);
                if (this.cells.getColumnCount() > 0 && this.cells.getRowCount() > 0) {
                    this.drawTopLeftArea(g, f, j)
                }
            },
            drawTopLeftArea: function(h, n, l) {
                var j = this.getTotalColumnHeight();
                var q = this.getTotalRowWidth();
                var f = new MindFusion.Drawing.Rect(this.leftMargin + n, this.topMargin + l, q, j);
                if (this.topLeftAreaStyle) {
                    this.drawRectangle(h, f, this.topLeftAreaStyle)
                }
                var g = this.getEffectiveFontName(this.topLeftAreaStyle);
                var r = this.getEffectiveFontSize(this.topLeftAreaStyle);
                var p = this.getEffectiveTextColor(this.topLeftAreaStyle);
                var o = this.getEffectiveTextAlignment(this.topLeftAreaStyle);
                var k = this.getEffectiveLineAlignment(this.topLeftAreaStyle);
                this.drawText(h, this.getTopLeftAreaText(), g, r, o, k, p, f, false)
            },
            drawRectangle: function(k, f, g) {
                var h = MindFusion.Diagramming.Utils.getBrush(k, this.getEffectiveBackground(g), f);
                if (h) {
                    k.fillStyle = h;
                    k.fillRect(f.x, f.y, f.width, f.height)
                }
                var l = this.getEffectiveLeftBorderPen(g);
                var o = this.getEffectiveLeftBorderThickness(g);
                if (l && o) {
                    k.beginPath();
                    k.moveTo(f.left(), f.top());
                    k.lineTo(f.left(), f.bottom());
                    k.strokeStyle = l;
                    k.lineWidth = o / k._mf_scale;
                    k.stroke()
                }
                var p = this.getEffectiveTopBorderPen(g);
                var s = this.getEffectiveTopBorderThickness(g);
                if (p && s) {
                    k.beginPath();
                    k.moveTo(f.left(), f.top());
                    k.lineTo(f.right(), f.top());
                    k.strokeStyle = p;
                    k.lineWidth = s / k._mf_scale;
                    k.stroke()
                }
                var n = this.getEffectiveRightBorderPen(g);
                var r = this.getEffectiveRightBorderThickness(g);
                if (n && r) {
                    k.beginPath();
                    k.moveTo(f.right(), f.top());
                    k.lineTo(f.right(), f.bottom());
                    k.strokeStyle = n;
                    k.lineWidth = r / k._mf_scale;
                    k.stroke()
                }
                var q = this.getEffectiveBottomBorderPen(g);
                var j = this.getEffectiveBottomBorderThickness(g);
                if (q && j) {
                    k.beginPath();
                    k.moveTo(f.left(), f.bottom());
                    k.lineTo(f.right(), f.bottom());
                    k.strokeStyle = q;
                    k.lineWidth = j / k._mf_scale;
                    k.stroke()
                }
            },
            drawText: function(h, s, t, j, z, g, u, n, w) {
                if (!s) {
                    return
                }
                h.save();
                h.rect(n.x, n.y, n.width, n.height);
                h.clip();
                var B = 0;
                if (w) {
                    if (n.width < n.height) {
                        B = Math.max(n.width, n.height) / 2
                    } else {
                        B = Math.min(n.width, n.height) / 2
                    }
                    h.translate(n.x + B, n.y + B);
                    h.rotate(3 * Math.PI / 2);
                    h.translate(-n.x - B, -n.y - B)
                }
                h.fillStyle = u;
                h.textBaseline = "top";
                h.font = j + "px " + t;
                var l = n.width;
                var q = n.height;
                if (w) {
                    l = n.height;
                    q = n.width
                }
                var k = j;
                var f = this.wrapText(h, s, l);
                if (f) {
                    var p = n.x;
                    var o = n.y;
                    h.textAlign = "left";
                    if (z == MindFusion.Diagramming.Alignment.Center) {
                        if (w) {
                            p = n.x + B
                        } else {
                            p = n.x + n.width / 2
                        }
                        h.textAlign = "center"
                    }
                    if (z == MindFusion.Diagramming.Alignment.Far) {
                        if (w) {
                            p = n.x + 2 * B
                        } else {
                            p = n.x + n.width
                        }
                        h.textAlign = "right"
                    }
                    var A = f.length * k;
                    if (A < q) {
                        if (g == MindFusion.Diagramming.Alignment.Center) {
                            o += (q - A) / 2
                        }
                        if (g == MindFusion.Diagramming.Alignment.Far) {
                            o += q - A
                        }
                    }
                    for (var v = 0; v < f.length; v++) {
                        var r = f[v];
                        h.fillText(r, p, o);
                        o += k
                    }
                }
                h.restore()
            },
            wrapText: function(g, l, k) {
                var p = l.split("\n");
                if (k == Number.MAX_VALUE) {
                    return p
                }
                var o = [];
                for (var h = 0; h < p.length; h++) {
                    var j = p[h].split(" ");
                    var n = "";
                    for (var h = 0; h < j.length; h++) {
                        var f = j[h];
                        m = g.measureText(n + f).width;
                        if (m < k) {
                            if (h === 0) {
                                n += f
                            } else {
                                n += " " + f
                            }
                        } else {
                            if (n != "") {
                                o.push(n)
                            }
                            n = f
                        }
                        if (h === j.length - 1) {
                            o.push(n);
                            break
                        }
                    }
                }
                return o
            },
            drawHeader: function(j, f, q) {
                var o = q;
                var h = q.context;
                this.drawRectangle(h, f, j.getStyle());
                var p = j.getStyle();
                var g = this.getEffectiveFontName(p);
                var r = this.getEffectiveFontSize(p);
                var n = this.getEffectiveTextColor(p);
                var l = this.getEffectiveTextAlignment(p);
                var k = this.getEffectiveLineAlignment(p);
                this.drawText(h, j.getTitle(), g, r, l, k, n, f, j.getRotateTitle())
            },
            drawCells: function(j) {
                var u = this.getTotalColumnHeight();
                var A = this.getTotalRowWidth();
                var t = this.leftMargin + A;
                for (var D = 0; D < this.getColumnCount(); D++) {
                    var l = this.getColumn(D);
                    var o = l.getWidth();
                    var s = this.topMargin + u;
                    for (var z = 0; z < this.getRowCount(); z++) {
                        var p = this.getRow(z);
                        var h = p.getHeight();
                        var g = this.cells.get(D, z);
                        var q = new MindFusion.Drawing.Rect(t, s, o, h);
                        s += p.getHeight();
                        var C = g.getStyle();
                        this.drawRectangle(j, q, C);
                        var v = g.getText();
                        if (v) {
                            var w = this.getEffectiveFontName(C);
                            var k = this.getEffectiveFontSize(C);
                            var n = this.getEffectiveTextColor(C);
                            var B = this.getEffectiveTextAlignment(C);
                            var f = this.getEffectiveLineAlignment(C);
                            this.drawText(j, g.getText(), w, k, B, f, n, q, false)
                        }
                    }
                    t += l.getWidth()
                }
            },
            collectLeaves: function(g, h) {
                for (var f = 0; f < g.length; f++) {
                    if (g[f].subHeaders.length == 0) {
                        h.push(g[f]);
                        continue
                    }
                    this.collectLeaves(g[f].subHeaders, h)
                }
            },
            onColumnHeaderHeightChanged: function(q, k) {
                var l = this.getTotalColumnHeight();
                var o = this.getTotalColumnHeightIf(q, k);
                var n = [];
                this.collectLeaves(this.rowHeader.subHeaders, n);
                var j = [];
                this.collectLeaves(this.columnHeader.subHeaders, j);
                if (o != l) {
                    var p = l - o;
                    var s = this.getColumnCount();
                    var v = this.getRowCount();
                    var w = this.leftMargin + this.getTotalRowWidth();
                    for (var t = 0; t < s; t++) {
                        var u = this.topMargin + this.getTotalColumnHeight();
                        for (var h = 0; h < v; h++) {
                            var z = this.cells.get(t, h);
                            var g = new b(w, u, j[t].width, n[h].height);
                            var f = g;
                            f.y -= p;
                            u += n[h].height
                        }
                        w += j[t].width
                    }
                }
            },
            onRowHeaderWidthChanged: function(p, k) {
                var l = this.getTotalRowWidth();
                var q = this.getTotalRowWidthIf(p, k);
                var n = [];
                this.collectLeaves(this.rowHeader.subHeaders, n);
                var j = [];
                this.ollectLeaves(this.columnHeader.subHeaders, j);
                if (q != l) {
                    var o = l - q;
                    var s = this.getColumnCount();
                    var v = this.getRowCount();
                    var w = this.leftMargin + this.getTotalRowWidth();
                    for (var t = 0; t < s; t++) {
                        var u = this.topMargin + getTotalColumnHeight();
                        for (var h = 0; h < v; h++) {
                            var z = this.cells.get(t, h);
                            var g = new b(w, u, j[t].width, n[h].height);
                            var f = g;
                            f.x -= o;
                            u += n[h].height
                        }
                        w += j[t].width
                    }
                }
            },
            resolveEffectiveStyle: function(f) {
                if (this.parent) {
                    var g = this.parent.style;
                    if (g && f.apply(g)) {
                        return g
                    }
                    var j = this.parent.theme;
                    if (j) {
                        var h = this.resolveInheritedStyle(f, j);
                        if (h) {
                            return h
                        }
                    }
                }
                return this.resolveInheritedStyle(f, MindFusion.Diagramming.Theme.Default)
            },
            resolveInheritedStyle: function(f, h) {
                var g = h.styles["std:Diagram"];
                if (g) {
                    if (f.apply(g)) {
                        return g
                    }
                }
                return null
            },
            getEffectivePropertyValue: function(j, f, h) {
                var k;
                if (j) {
                    k = f.apply(j);
                    if (k !== undefined) {
                        return k
                    }
                }
                if (this.style) {
                    k = f.apply(this.style);
                    if (k !== undefined) {
                        return k
                    }
                }
                if (h) {
                    var g = this.resolveEffectiveStyle(h);
                    if (g) {
                        return h.apply(g)
                    }
                }
            },
            getEffectiveBackground: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getBackgroundBrush, MindFusion.Diagramming.Style.prototype.getBrush);
                if (g !== undefined) {
                    return g
                }
                return "white"
            },
            getEffectiveLeftBorderPen: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getLeftBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (g !== undefined) {
                    return g
                }
                return "black"
            },
            getEffectiveLeftBorderThickness: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getLeftBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (g !== undefined) {
                    return g
                }
                return 0
            },
            getEffectiveTopBorderPen: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getTopBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (g !== undefined) {
                    return g
                }
                return "black"
            },
            getEffectiveTopBorderThickness: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getTopBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (g !== undefined) {
                    return g
                }
                return 0
            },
            getEffectiveRightBorderPen: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getRightBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (g !== undefined) {
                    return g
                }
                return "black"
            },
            getEffectiveRightBorderThickness: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getRightBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (g !== undefined) {
                    return g
                }
                return 0
            },
            getEffectiveBottomBorderPen: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getBottomBorderPen, MindFusion.Diagramming.Style.prototype.getStroke);
                if (g !== undefined) {
                    return g
                }
                return "black"
            },
            getEffectiveBottomBorderThickness: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getBottomBorderThickness, MindFusion.Diagramming.Style.prototype.getStrokeThickness);
                if (g !== undefined) {
                    return g
                }
                return 0
            },
            getEffectiveFontName: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getFontName, MindFusion.Diagramming.Style.prototype.getFontName);
                if (g !== undefined) {
                    return g
                }
                return "sans-serif"
            },
            getEffectiveFontSize: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getFontSize, MindFusion.Diagramming.Style.prototype.getFontSize);
                if (g !== undefined) {
                    return g
                }
                return 4
            },
            getEffectiveTextColor: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getTextColor, MindFusion.Diagramming.Style.prototype.getTextColor);
                if (g !== undefined) {
                    return g
                }
                return "black"
            },
            getEffectiveTextAlignment: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getTextAlignment);
                if (g !== undefined) {
                    return g
                }
                return MindFusion.Diagramming.Alignment.Center
            },
            getEffectiveLineAlignment: function(f) {
                var g = this.getEffectivePropertyValue(f, e.Style.prototype.getLineAlignment);
                if (g !== undefined) {
                    return g
                }
                return MindFusion.Diagramming.Alignment.Center
            },
            getColumn: function(f) {
                return this.getHeader(this.columnHeader.getSubHeaders(), f)
            },
            getRow: function(f) {
                return this.getHeader(this.rowHeader.getSubHeaders(), f)
            },
            hitTestHeader: function(h, f, g) {
                if (f.containsPoint(g.testPoint)) {
                    g.hitHeader = h;
                    g.headerBounds = f
                }
            },
            getHeaderFromPoint: function(g, k, h) {
                if (!h) {
                    h = new d(0, 0)
                }
                var j = {
                    testPoint: g
                };
                var o = this;
                var n = function(r, p, q) {
                    o.hitTestHeader(r, p, q)
                };
                var f = 0;
                var l = 0;
                if (this.hookHeaders && h) {
                    f = h.x;
                    l = h.y
                }
                this.processColumnHeaders(n, f, l, j);
                this.processRowHeaders(n, f, l, j);
                if (k) {
                    k.headerBounds = j.headerBounds
                }
                return j.hitHeader
            },
            getCellFromPoint: function(o, n) {
                var l = o.x - this.getTotalRowWidth() - this.leftMargin;
                var k = o.y - this.getTotalColumnHeight() - this.topMargin;
                var g = 0;
                var q = 0;
                if (l < 0 || k < 0) {
                    return
                }
                var h = -1;
                var s = -1;
                for (var j = 0, p = this.cells.getColumnCount(); j < p; j++) {
                    g = this.getColumn(j).getWidth();
                    l -= g;
                    if (l < 0) {
                        h = j;
                        break
                    }
                }
                for (var f = 0; f < this.cells.getRowCount(); f++) {
                    q = this.getRow(f).getHeight();
                    k -= q;
                    if (k < 0) {
                        s = f;
                        break
                    }
                }
                if (h >= 0 && s >= 0) {
                    if (n) {
                        n.cellBounds = new MindFusion.Drawing.Rect(o.x - l - g, o.y - k - q, g, q);
                        n.column = h;
                        n.row = s
                    }
                    return this.cells.get(h, s)
                }
                return null
            },
            getCellColumn: function(f) {
                for (var k = 0, g = this.getColumnCount(); k < g; k++) {
                    for (var h = 0, j = this.getRowCount(); h < j; h++) {
                        if (this.cells.get(k, h) === f) {
                            return k
                        }
                    }
                }
                return -1
            },
            getCellRow: function(f) {
                for (var k = 0, g = this.getColumnCount(); k < g; k++) {
                    for (var h = 0, j = this.getRowCount(); h < j; h++) {
                        if (this.cells.get(k, h) === f) {
                            return h
                        }
                    }
                }
                return -1
            },
            getColumnIndex: function(f) {
                if (f.getSubHeaders().length > 0) {
                    return -1
                }
                if (f.isRowHeader()) {
                    return -1
                }
                return this.getIndex(f)
            },
            getRowIndex: function(f) {
                if (f.getSubHeaders().length > 0) {
                    return -1
                }
                if (f.isColumnHeader()) {
                    return -1
                }
                return this.getIndex(f)
            },
            getHeader: function(j, f) {
                var h = 0;
                for (var g = 0; g < j.length; g++) {
                    var n = j[g];
                    var l = h;
                    var k = l + n.getDeepChildCount() - 1;
                    if (n.getSubHeaders().length === 0) {
                        if (l <= f && f <= k) {
                            return n
                        }
                    }
                    if (l <= f && f <= k) {
                        return this.getHeader(n.getSubHeaders(), f - h)
                    }
                    h = k + 1
                }
                return null
            },
            invalidate: function(f) {
                if (this.parent) {
                    this.parent.invalidate();
                    if (f === undefined) {
                        f = true
                    }
                    if (f && this.parent.setDirty) {
                        this.parent.setDirty(true)
                    }
                }
            },
            getStyle: function() {
                return this.style
            },
            getAllowInplaceEdit: function() {
                return this.allowInplaceEdit
            },
            setAllowInplaceEdit: function(f) {
                this.allowInplaceEdit = f
            },
            getAllowResizeHeaders: function() {
                return this.allowResizeHeaders
            },
            setAllowResizeHeaders: function(f) {
                this.allowResizeHeaders = f
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Lanes.Grid")
    })(MindFusion.Diagramming.Lanes);
    (function(a) {
        var b = a.Header = function() {
            mflayer.initializeBase(b, this);
            this.subHeaders = [];
            this.width = 0;
            this.height = 0;
            this.resizeType = MindFusion.Diagramming.Lanes.ResizeType.Proportional;
            this.title = "";
            this.rotateTitle = false;
            this.titleColor = "#000000";
            this.style = new a.Style()
        };
        b.prototype = {
            fromJson: function(d) {
                this.subHeaders = [];
                for (var c = 0; c < d.subHeaders.length; c++) {
                    var e = new a.Header();
                    e.fromJson(d.subHeaders[c]);
                    e.parent = this;
                    this.subHeaders.push(e)
                }
                this.width = d.width || 0;
                this.height = d.height || 0;
                this.resizeType = d.resizeType || MindFusion.Diagramming.Lanes.ResizeType.Proportional;
                this.title = d.title || "";
                this.rotateTitle = d.rotateTitle || false;
                this.titleColor = d.titleColor || "#000000";
                if (d.style) {
                    this.style.fromJson(d.style)
                }
                if (this.getHeight() === 0) {
                    this.height = 20
                }
            },
            toJson: function() {
                var c = {
                    subHeaders: this.serializeSubHeaders(),
                    width: this.width,
                    height: this.height,
                    resizeType: this.resizeType,
                    title: this.title,
                    rotateTitle: this.rotateTitle,
                    titleColor: this.titleColor,
                    style: this.style.toJson()
                };
                return c
            },
            saveToXml: function(h, g) {
                g.writeFloat(this.width, "Width", h);
                g.writeFloat(this.height, "Height", h);
                g.writeInt(this.resizeType, "ResizeType", h);
                g.writeString(this.title, "Title", h);
                g.writeBool(this.rotateTitle, "RotateTitle", h);
                g.writeColor(this.titleColor, "TitleColor", h);
                if (this.style && (this.style.fontName || this.style.fontSize)) {
                    var d = {};
                    if (this.style.fontName) {
                        d.name = this.style.fontName
                    }
                    if (this.style.fontSize) {
                        d.size = this.style.fontSize
                    }
                    g.writeFont(d, "TitleFont", h)
                }
                if (this.style && (this.style.textAlignment != undefined || this.style.lineAlignment != undefined)) {
                    var e = {};
                    if (this.style.textAlignment !== undefined) {
                        e.alignment = this.style.textAlignment
                    }
                    if (this.style.lineAlignment != undefined) {
                        e.lineAlignment = this.style.lineAlignment
                    }
                    g.writeStringFormat(e, "TitleFormat", h)
                }
                var c = g.addChildElement("Style", h);
                this.style.saveToXml(c, g);
                var j = g.addChildElement("SubHeaders", h);
                for (var f = 0; f < this.subHeaders.length; f++) {
                    g.saveHeaderToXml(this.subHeaders[f], j, "Header")
                }
            },
            loadFromXml: function(l, d) {
                this.width = d.readFloat("Width", l);
                this.height = d.readFloat("Height", l);
                this.resizeType = d.readInt("ResizeType", l);
                this.title = d.readString("Title", l);
                this.rotateTitle = d.readBool("RotateTitle", l);
                this.titleColor = d.readColor("TitleColor", l);
                var e = d.readFont("TitleFont", l);
                if (e) {
                    if (e.name) {
                        this.style.fontName = e.name
                    }
                    if (e.size) {
                        this.style.fontSize = e.size
                    }
                }
                var k = d.readStringFormat("TitleFormat", l);
                if (k) {
                    if (k.alignment) {
                        this.style.textAlignment = k.alignment
                    }
                    if (k.lineAlignment) {
                        this.style.lineAlignment = k.lineAlignment
                    }
                }
                var j = d.selectSingleNode("Style", l);
                this.style.loadFromXml(j, d);
                var f = d.selectSingleNode("SubHeaders", l);
                this.subHeaders = [];
                var c = d.selectNodes("Header", f);
                for (var g = 0; g < c.length; g++) {
                    var h = d.loadHeaderFromXml(c[g]);
                    h.parent = this;
                    this.subHeaders.push(h)
                }
            },
            serializeSubHeaders: function() {
                var c = [];
                for (var d = 0; d < this.subHeaders.length; d++) {
                    c.push(this.subHeaders[d].toJson())
                }
                return c
            },
            isDescendantOf: function(c) {
                if (this.parent === c) {
                    return true
                }
                if (!this.parent) {
                    return false
                }
                return this.parent.isDescendantOf(c)
            },
            setParent: function(c) {
                this.parent = c
            },
            setChildrenWidths: function(f, g) {
                if (this.subHeaders.length === 0) {
                    return
                }
                var p = 0;
                var e = 0;
                for (var h = 0; h < this.subHeaders.length; h++) {
                    var j = this.subHeaders[h];
                    if (j.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                        p++;
                        e += j.getWidth()
                    }
                }
                var c = this.getMinSize();
                if (f < g) {
                    if (p > 0) {
                        var o = g - f;
                        for (var h = 0; h < this.subHeaders.length; h++) {
                            var j = this.subHeaders[h];
                            if (j.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                j.setWidthNoNotify(j.getWidth() + o * j.getWidth() / e)
                            }
                        }
                    } else {
                        var d = this.subHeaders[this.subHeaders.length - 1];
                        d.setWidthNoNotify(d.getWidth() + g - f)
                    }
                } else {
                    var l = 0;
                    if (p > 0) {
                        var n = f - g;
                        for (var h = 0; h < this.subHeaders.length; h++) {
                            var j = this.subHeaders[h];
                            if (j.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                var k = j.getWidth() - n * j.getWidth() / e;
                                if (k < c) {
                                    l = c - k;
                                    k = c
                                }
                                j.setWidthNoNotify(k)
                            }
                        }
                    } else {
                        l = f - g
                    }
                    if (l > 0) {
                        for (var h = this.subHeaders.length - 1; h >= 0; h--) {
                            var j = this.subHeaders[h];
                            if (j.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Fixed) {
                                var k = j.getWidth() - l;
                                if (k < c) {
                                    k = c
                                }
                                j.setWidthNoNotify(k)
                            }
                        }
                    }
                }
            },
            setChildrenHeights: function(n, c) {
                if (this.subHeaders.length === 0) {
                    return
                }
                var o = 0;
                var p = 0;
                for (var g = 0; g < this.subHeaders.length; g++) {
                    var h = this.subHeaders[g];
                    if (h.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                        o++;
                        p += h.getHeight()
                    }
                }
                var e = this.getMinSize();
                if (n < c) {
                    if (o > 0) {
                        var l = c - n;
                        for (var g = 0; g < this.subHeaders.length; g++) {
                            var h = this.subHeaders[g];
                            if (h.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                h.setHeightNoNotify(h.getHeight() + l * h.getHeight() / p)
                            }
                        }
                    } else {
                        var f = this.subHeaders[this.subHeaders.length - 1];
                        f.setHeightNoNotify(f.getHeight() + c - n)
                    }
                } else {
                    var j = 0;
                    if (o > 0) {
                        var k = n - c;
                        for (var g = 0; g < this.subHeaders.length; g++) {
                            var h = this.subHeaders[g];
                            if (h.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Proportional) {
                                var d = h.getHeight() - k * h.getHeight() / p;
                                if (d < e) {
                                    j = e - d;
                                    d = e
                                }
                                h.setHeightNoNotify(d)
                            }
                        }
                    } else {
                        j = n - c
                    }
                    if (j > 0) {
                        for (var g = this.subHeaders.Count - 1; g >= 0; g--) {
                            var h = this.subHeaders[g];
                            if (h.getResizeType() === MindFusion.Diagramming.Lanes.ResizeType.Fixed) {
                                var d = h.getHeight() - j;
                                if (d < e) {
                                    d = e
                                }
                                h.setHeightNoNotify(d)
                            }
                        }
                    }
                }
            },
            ensureWidth: function(d) {
                if (this.subHeaders.length === 0) {
                    if (this.width < d) {
                        this.width = d
                    }
                } else {
                    for (var c = 0; c < this.subHeaders.length; c++) {
                        this.subHeaders[c].ensureWidth(d)
                    }
                }
            },
            ensureHeight: function(c) {
                if (this.subHeaders.length === 0) {
                    if (this.height < c) {
                        this.height = c
                    }
                } else {
                    for (var d = 0; d < this.subHeaders.length; d++) {
                        this.subHeaders[d].ensureHeight(c)
                    }
                }
            },
            zeroWidth: function() {
                this.width = 0;
                for (var c = 0; c < this.subHeaders.length; c++) {
                    this.subHeaders[c].setWidth(0)
                }
            },
            zeroHeight: function() {
                this.height = 0;
                for (var c = 0; c < this.subHeaders.length; c++) {
                    this.subHeaders[c].setHeight(0)
                }
            },
            notifyHeaderChanged: function(c) {
                if (this.parent) {
                    this.parent.notifyHeaderChanged(c)
                }
            },
            setWidthNoNotify: function(e) {
                if (this.isColumnHeader()) {
                    if (e < this.getMinSize()) {
                        e = this.getMinSize()
                    }
                } else {
                    if (e < 0) {
                        e = 0
                    }
                }
                if (this.width === e) {
                    return
                }
                var d = this.width;
                if (this.subHeaders.length === 0) {
                    this.width = e;
                    return
                }
                var c = this.getWidth();
                this.width = e;
                if (this.isColumnHeader()) {
                    this.setChildrenWidths(c, this.width)
                }
                if (this.isRowHeader()) {
                    this.onRowHeaderWidthChanged(this, d)
                }
            },
            setHeightNoNotify: function(c) {
                if (this.isRowHeader()) {
                    if (c < this.getMinSize()) {
                        c = this.getMinSize()
                    }
                } else {
                    if (c < 0) {
                        c = 0
                    }
                }
                if (this.height === c) {
                    return
                }
                var e = this.height;
                if (this.subHeaders.length === 0) {
                    this.height = c;
                    if (this.isColumnHeader()) {
                        this.parent.onColumnHeaderHeightChanged(this, e)
                    }
                    return
                }
                var d = this.getHeight();
                this.height = c;
                if (this.isRowHeader()) {
                    this.setChildrenHeights(d, this.height)
                }
                if (this.isColumnHeader()) {
                    this.onColumnHeaderHeightChanged(this, e)
                }
            },
            onColumnHeaderHeightChanged: function(d, c) {
                this.parent.onColumnHeaderHeightChanged(d, c)
            },
            onRowHeaderWidthChanged: function(d, c) {
                this.parent.onRowHeaderWidthChanged(d, c)
            },
            getParent: function() {
                return this.parent
            },
            getSubHeaders: function() {
                return this.subHeaders
            },
            getDeepChildCount: function() {
                if (this.subHeaders.length === 0) {
                    return 1
                }
                var c = 0;
                for (var d = 0; d < this.subHeaders.length; d++) {
                    c += this.subHeaders[d].getDeepChildCount()
                }
                return c
            },
            getWidth: function() {
                if (this.subHeaders.length === 0) {
                    return this.width
                }
                if (this.isRowHeader()) {
                    return this.width
                }
                var c = 0;
                for (var d = 0; d < this.subHeaders.length; d++) {
                    c += this.subHeaders[d].getWidth()
                }
                if (c == 0) {
                    return this.width
                }
                return c
            },
            setWidth: function(c) {
                this.setWidthNoNotify(c)
            },
            getHeight: function() {
                if (this.subHeaders.length == 0) {
                    return this.height
                }
                if (this.isColumnHeader()) {
                    return this.height
                }
                var d = 0;
                for (var c = 0; c < this.subHeaders.length; c++) {
                    d += this.subHeaders[c].getHeight()
                }
                if (d == 0) {
                    return this.height
                }
                return d
            },
            setHeight: function(c) {
                this.setHeightNoNotify(c)
            },
            getResizeType: function() {
                return this.resizeType
            },
            setResizeType: function(c) {
                this.resizeType = c
            },
            getTitle: function() {
                return this.title
            },
            setTitle: function(c) {
                if (this.title === c) {
                    return
                }
                this.title = c;
                this.notifyHeaderChanged(this)
            },
            getRotateTitle: function() {
                return this.rotateTitle
            },
            setRotateTitle: function(c) {
                if (this.rotateTitle === c) {
                    return
                }
                this.rotateTitle = c;
                this.notifyHeaderChanged(this)
            },
            getStyle: function() {
                return this.style
            },
            setStyle: function(c) {
                if (!c) {
                    return
                }
                if (this.style === c) {
                    return
                }
                this.style = c;
                this.notifyHeaderChanged(this)
            },
            isColumnHeader: function() {
                if (this.parent) {
                    return this.parent.isColumnHeader()
                }
                return false
            },
            isRowHeader: function() {
                if (this.parent) {
                    return this.parent.isRowHeader()
                }
                return false
            },
            getMinSize: function() {
                if (this.parent) {
                    return this.parent.getMinSize()
                }
                return 0
            }
        };
        MindFusion.registerClass(b, "MindFusion.Diagramming.Lanes.Header")
    })(MindFusion.Diagramming.Lanes);
    (function(b) {
        var a = b.MasterHeader = function(c, d) {
            mflayer.initializeBase(a, this);
            this.grid = c;
            this.rowHeader = d
        };
        a.prototype = {
            fromJson: function(c) {
                mflayer.callBaseMethod(a, this, "fromJson", [c]);
                this.rowHeader = c.rowHeader
            },
            toJson: function() {
                var c = mflayer.callBaseMethod(a, this, "toJson", []);
                c.rowHeader = this.rowHeader;
                return c
            },
            notifyHeaderChanged: function(c) {
                if (this.grid) {
                    this.grid.invalidate()
                }
            },
            isColumnHeader: function() {
                return !this.rowHeader
            },
            isRowHeader: function() {
                return this.rowHeader
            },
            getMinSize: function() {
                return this.grid.getMinHeaderSize()
            },
            onColumnHeaderHeightChanged: function(d, c) {
                this.grid.onColumnHeaderHeightChanged(d, c)
            },
            onRowHeaderWidthChanged: function(d, c) {
                this.grid.onRowHeaderWidthChanged(d, c)
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Lanes.MasterHeader", b.Header)
    })(MindFusion.Diagramming.Lanes);
    (function(b) {
        var a = b.Style = function() {
            mflayer.initializeBase(a, this)
        };
        a.prototype = {
            fromJson: function(c) {
                this.backgroundBrush = c.backgroundBrush;
                this.leftBorderPen = c.leftBorderPen;
                this.leftBorderThickness = c.leftBorderThickness || 1;
                this.topBorderPen = c.topBorderPen;
                this.topBorderThickness = c.topBorderThickness || 1;
                this.rightBorderPen = c.rightBorderPen;
                this.rightBorderThickness = c.rightBorderThickness || 1;
                this.bottomBorderPen = c.bottomBorderPen;
                this.bottomBorderThickness = c.bottomBorderThickness || 1;
                this.textColor = c.textColor;
                this.fontName = c.fontName;
                this.fontSize = c.fontSize;
                this.textAlignment = c.textAlignment;
                this.lineAlignment = c.lineAlignment
            },
            toJson: function() {
                var c = {
                    backgroundBrush: this.backgroundBrush,
                    leftBorderPen: this.leftBorderPen,
                    leftBorderThickness: this.leftBorderThickness,
                    topBorderPen: this.topBorderPen,
                    topBorderThickness: this.topBorderThickness,
                    rightBorderPen: this.rightBorderPen,
                    rightBorderThickness: this.rightBorderThickness,
                    bottomBorderPen: this.bottomBorderPen,
                    bottomBorderThickness: this.bottomBorderThickness,
                    textColor: this.textColor,
                    fontName: this.fontName,
                    fontSize: this.fontSize,
                    textAlignment: this.textAlignment,
                    lineAlignment: this.lineAlignment
                };
                return c
            },
            saveToXml: function(d, c) {
                c.writeBrush(this.backgroundBrush, "BackgroundBrush", d);
                c.writePen({
                    brush: this.leftBorderPen,
                    width: this.leftBorderThickness
                }, "LeftBorderPen", d);
                c.writePen({
                    brush: this.topBorderPen,
                    width: this.toptBorderThickness
                }, "TopBorderPen", d);
                c.writePen({
                    brush: this.rightBorderPen,
                    width: this.rightBorderThickness
                }, "RightBorderPen", d);
                c.writePen({
                    brush: this.bottomBorderPen,
                    width: this.bottomBorderThickness
                }, "BottomBorderPen", d)
            },
            loadFromXml: function(d, c) {
                this.backgroundBrush = c.readBrush("BackgroundBrush", d);
                var e = c.readPen("LeftBorderPen", d);
                if (e) {
                    if (e.brush) {
                        this.leftBorderPen = e.brush
                    }
                    if (e.width) {
                        this.leftBorderThickness = e.width
                    }
                }
                e = c.readPen("TopBorderPen", d);
                if (e) {
                    if (e.brush) {
                        this.topBorderPen = e.brush
                    }
                    if (e.width) {
                        this.rightBorderThickness = e.width
                    }
                }
                e = c.readPen("RightBorderPen", d);
                if (e) {
                    if (e.brush) {
                        this.rightBorderPen = e.brush
                    }
                    if (e.width) {
                        this.rightBorderThickness = e.width
                    }
                }
                e = c.readPen("BottomBorderPen", d);
                if (e) {
                    if (e.brush) {
                        this.bottomBorderPen = e.brush
                    }
                    if (e.width) {
                        this.bottomBorderThickness = e.width
                    }
                }
            },
            getBackgroundBrush: function() {
                return this.backgroundBrush
            },
            setBackgroundBrush: function(c) {
                this.backgroundBrush = c
            },
            getLeftBorderPen: function() {
                return this.leftBorderPen
            },
            setLeftBorderPen: function(c) {
                this.leftBorderPen = c
            },
            getLeftBorderThickness: function() {
                return this.leftBorderThickness
            },
            setLeftBorderThickness: function(c) {
                this.leftBorderThickness = c
            },
            getTopBorderPen: function() {
                return this.topBorderPen
            },
            setTopBorderPen: function(c) {
                this.topBorderPen = c
            },
            getTopBorderThickness: function() {
                return this.topBorderThickness
            },
            setTopBorderThickness: function(c) {
                this.topBorderThickness = c
            },
            getRightBorderPen: function() {
                return this.rightBorderPen
            },
            setRightBorderPen: function(c) {
                this.rightBorderPen = c
            },
            getRightBorderThickness: function() {
                return this.rightBorderThickness
            },
            setRightBorderThickness: function(c) {
                this.rightBorderThickness = c
            },
            getBottomBorderPen: function() {
                return this.bottomBorderPen
            },
            setBottomBorderPen: function(c) {
                this.bottomBorderPen = c
            },
            getBottomBorderThickness: function() {
                return this.bottomBorderThickness
            },
            setBottomBorderThickness: function(c) {
                this.bottomBorderThickness = c
            },
            getTextColor: function() {
                return this.textColor
            },
            setTextColor: function(c) {
                this.textColor = c
            },
            getFontName: function() {
                return this.fontName
            },
            setFontName: function(c) {
                this.fontName = c
            },
            getFontSize: function() {
                return this.fontSize
            },
            setFontSize: function(c) {
                this.fontSize = c
            },
            getTextAlignment: function() {
                return this.textAlignment
            },
            setTextAlignment: function(c) {
                this.textAlignment = c
            },
            getLineAlignment: function() {
                return this.lineAlignment
            },
            setLineAlignment: function(c) {
                this.lineAlignment = c
            }
        };
        MindFusion.registerClass(a, "MindFusion.Diagramming.Lanes.Style")
    })(MindFusion.Diagramming.Lanes);
    return MindFusion;
}));